/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/api/audit-logs/v1/events": {
    /**
     * @description Get activity for actions performed on an account. Can be filtered
     * by a list of actors, and date range. For zap actions, also allows
     * filtering by app and by folders.
     * Please see the parameters above for a comprehensive filter list.
     */
    get: operations["api_audit-logs_v1_events_list"];
  };
  "/api/checkpoint/v1/account-restrictions/": {
    /**
     * Endpoint for setting account level restrictions.
     * @description Allows setting publish approval flows on or off at the account level.
     * This data is stored in the `Relationship` model of the `identity`
     * database, via `identity.access` interfaces.
     */
    get: operations["api_checkpoint_v1_account-restrictions_list"];
    /**
     * Endpoint for setting account level restrictions.
     * @description Allows setting publish approval flows on or off at the account level.
     * This data is stored in the `Relationship` model of the `identity`
     * database, via `identity.access` interfaces.
     */
    put: operations["api_checkpoint_v1_account-restrictions_update"];
  };
  "/api/checkpoint/v1/approvals/": {
    /**
     * Checkpoint service proxy for Publish Approval requests.
     * @description For full API documentation, see the [Checkpoint service](https://checkpoint.k8s.zapier.com/api/schema/)
     */
    get: operations["api_checkpoint_v1_approvals_list"];
    /**
     * Checkpoint service proxy for Publish Approval requests.
     * @description For full API documentation, see the [Checkpoint service](https://checkpoint.k8s.zapier.com/api/schema/)
     */
    post: operations["api_checkpoint_v1_approvals_create"];
  };
  "/api/checkpoint/v1/approvals/{id}/": {
    /**
     * Checkpoint service proxy for Publish Approval requests.
     * @description For full API documentation, see the [Checkpoint service](https://checkpoint.k8s.zapier.com/api/schema/)
     */
    get: operations["api_checkpoint_v1_approvals_read"];
    /**
     * Checkpoint service proxy for Publish Approval requests.
     * @description For full API documentation, see the [Checkpoint service](https://checkpoint.k8s.zapier.com/api/schema/)
     */
    put: operations["api_checkpoint_v1_approvals_update"];
    /**
     * Checkpoint service proxy for Publish Approval requests.
     * @description For full API documentation, see the [Checkpoint service](https://checkpoint.k8s.zapier.com/api/schema/)
     */
    patch: operations["api_checkpoint_v1_approvals_partial_update"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/api/nap/internal/emails/send/": {
    /** @description Sends an email using mailgun and returns the response. */
    post: operations["api_nap_internal_emails_send_create"];
  };
  "/api/nap/internal/emails/send_canvas_notification_email/": {
    /**
     * @description Sends an email using mailgun and returns the response.
     * This is a copy of the above logic, but also hydrates in user data
     * into the template_context's comment(s).
     *
     * This is meant to be a TEMPORARY WORKAROUND because the
     * /api/v4/accounts/:id/members/:member_id/ endpoint does not support S2S auth yet.
     * This was the path of least resistance to getting email notifications for
     * Canvas thread comments working and _shipped_.
     */
    post: operations["api_nap_internal_emails_send_canvas_notification_email_create"];
  };
  "/api/v1/assets/": {
    get: operations["api_v1_assets_list"];
  };
  "/api/v1/controlled-apps-strategies/": {
    get: operations["api_v1_controlled-apps-strategies_read"];
    put: operations["api_v1_controlled-apps-strategies_update"];
  };
  "/api/v1/projects/": {
    get: operations["api_v1_projects_list"];
    post: operations["api_v1_projects_create"];
  };
  "/api/v1/projects/{id}/": {
    get: operations["api_v1_projects_read"];
    delete: operations["api_v1_projects_delete"];
    patch: operations["api_v1_projects_partial_update"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/api/v1/projects/{id}/share/": {
    post: operations["api_v1_projects_share"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/api/v1/projects/{id}/shares/": {
    get: operations["api_v1_projects_shares"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/api/v1/projects/{id}/unshare/": {
    post: operations["api_v1_projects_unshare"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/api/v1/projects/{projects_pk}/assets/": {
    get: operations["api_v1_projects_assets_list"];
    post: operations["api_v1_projects_assets_create"];
    parameters: {
      path: {
        projects_pk: string;
      };
    };
  };
  "/api/v1/projects/{projects_pk}/assets/{asset_identifier}/": {
    delete: operations["api_v1_projects_assets_delete"];
    parameters: {
      path: {
        projects_pk: string;
        asset_identifier: string;
      };
    };
  };
  "/api/v1/search/zaps/": {
    get: operations["api_v1_search_zaps_list"];
  };
  "/api/v3/data/export/completion": {
    /**
     * @description This endpoint receives a POST request from the exporter when the userdata export is complete
     * for each of the user accounts.
     *
     * Example Request:
     * POST v3/data/export/completion
     * {
     *     "export_job_id": "customuser_id/action_id/account_id",
     *     "export_location": "https://s3.amazonaws.com/...",
     * }
     *
     * Example Responses:
     * - 200 OK { "message": "Completed."}
     * - 400 Bad Request { "errors": ["Param xxx is required.", "Malformed xxx."]}
     * - 404 Not Found { "errors": ["No action found."]}
     * - 409 Conflict {'message': 'Duplicate.'}
     */
    post: operations["api_v3_data_export_completion_create"];
  };
  "/api/v4/abtesting/identity/{identity}/assign_experiment/": {
    /**
     * /api/v4/abtesting/identity/<identity_id>/assign_experiment/
     * @description An endpoint to assign an experiment to an identity.
     * Pass in the experiment_collection_slug as the payload.
     * Returns the assigned variant.
     */
    post: operations["api_v4_abtesting_identity_assign_experiment"];
    parameters: {
      path: {
        identity: string;
      };
    };
  };
  "/api/v4/account-discovery/": {
    /**
     * Deduce the best account for sign in for this user
     * @description We need to figure out if the user can sign in with credentials
     * or with SAML, as well as the best account ID to sign in given
     * an email address and an optional account_id
     */
    get: operations["api_v4_account-discovery_list"];
  };
  "/api/v4/accounts/": {
    get: operations["api_v4_accounts_list"];
  };
  "/api/v4/accounts/access/": {
    get: operations["api_v4_accounts_access"];
  };
  "/api/v4/accounts/{account_id}/campaignoffers/{campaign_slug}": {
    /** @description Returns list of offer data associated with campaigns */
    get: operations["api_v4_accounts_campaignoffers_read"];
    parameters: {
      path: {
        account_id: string;
        campaign_slug: string;
      };
    };
  };
  "/api/v4/accounts/{account_id}/invoice-items/": {
    post: operations["api_v4_accounts_invoice-items_create"];
    parameters: {
      path: {
        account_id: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/controlled-apps/": {
    /**
     * Endpoint for denied and allowed apps
     * @description The app access control allows a team administrator
     * to deny certain apps.
     */
    get: operations["api_v4_accounts_controlled-apps_list"];
    /**
     * @description Overwrite create method so that we can ensure schema generation
     * with the appropriate serializer.
     */
    post: operations["api_v4_accounts_controlled-apps_create"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/controlled-apps/users/": {
    /** @description Search the users that use the given app */
    post: operations["api_v4_accounts_controlled-apps_get_app_users"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/controlled-apps/{app_pk}/members/": {
    get: operations["api_v4_accounts_controlled-apps_members_list"];
    /** @description Add the given user to this controlled app */
    post: operations["api_v4_accounts_controlled-apps_members_create"];
    parameters: {
      path: {
        account_pk: string;
        app_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/controlled-apps/{app_pk}/members/{id}/": {
    get: operations["api_v4_accounts_controlled-apps_members_read"];
    /** @description Remove the member from the given controlled app */
    delete: operations["api_v4_accounts_controlled-apps_members_delete"];
    parameters: {
      path: {
        account_pk: string;
        app_pk: string;
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/controlled-apps/{app_pk}/teams/": {
    get: operations["api_v4_accounts_controlled-apps_teams_list"];
    /**
     * Control the underlying app with a team ID or with all team members
     * @description This API expects a `team_id` parameter sent as a payload, in the form
     * `{team_id: id|`all`}`
     *
     * If it is sent as an `id`, it needs to be the ID of an already existing team.
     * That team will be added to the underlying controlled app, either as a permitted
     * or as a restricted operation.
     */
    post: operations["api_v4_accounts_controlled-apps_teams_create"];
    parameters: {
      path: {
        account_pk: string;
        app_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/controlled-apps/{app_pk}/teams/{id}/": {
    get: operations["api_v4_accounts_controlled-apps_teams_read"];
    /**
     * Remove the given team from the underlying controlled app
     * @description The app can be restricted or permitted for a team if the URL has a
     * team ID, or can be controlled from everyone in the account,
     * if the URL uses the special `all` ID.
     *
     * `all` represents all users in a team account, which is separate
     * than all the members in a team workspace.
     */
    delete: operations["api_v4_accounts_controlled-apps_teams_delete"];
    parameters: {
      path: {
        account_pk: string;
        app_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/controlled-apps/{id}/": {
    /**
     * Endpoint for denied and allowed apps
     * @description The app access control allows a team administrator
     * to deny certain apps.
     */
    get: operations["api_v4_accounts_controlled-apps_read"];
    /**
     * Endpoint for denied and allowed apps
     * @description The app access control allows a team administrator
     * to deny certain apps.
     */
    delete: operations["api_v4_accounts_controlled-apps_delete"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this Access Control App. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/domain-requests/": {
    get: operations["api_v4_accounts_domain-requests_list"];
    /** @description Custom POST method handler to track verification request creation. */
    post: operations["api_v4_accounts_domain-requests_create"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/domain-requests/{id}/": {
    get: operations["api_v4_accounts_domain-requests_read"];
    /**
     * @description Custom PUT method handler to refresh the expiry period for the
     * verification request object.
     */
    put: operations["api_v4_accounts_domain-requests_update"];
    delete: operations["api_v4_accounts_domain-requests_delete"];
    /** @description Custom PATCH method handler to check domain */
    patch: operations["api_v4_accounts_domain-requests_partial_update"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this Domain Verification Request. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/domains/": {
    get: operations["api_v4_accounts_domains_list"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/domains/{domain_pk}/members/": {
    get: operations["api_v4_accounts_domains_members_list"];
    parameters: {
      path: {
        account_pk: string;
        domain_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/domains/{domain_pk}/members/export/": {
    post: operations["api_v4_accounts_domains_members_export_members"];
    parameters: {
      path: {
        account_pk: string;
        domain_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/domains/{id}/": {
    get: operations["api_v4_accounts_domains_read"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this organization domain. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/experts/": {
    /** @description This endpoint is used to retrieve all experts associated with the context account */
    get: operations["api_v4_accounts_experts_list"];
    post: operations["api_v4_accounts_experts_create"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/feature-enrollment/": {
    get: operations["api_v4_accounts_feature-enrollment_list"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/feature-enrollment/{id}/": {
    get: operations["api_v4_accounts_feature-enrollment_read"];
    put: operations["api_v4_accounts_feature-enrollment_update"];
    patch: operations["api_v4_accounts_feature-enrollment_partial_update"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this account feature enrollment. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/folders/": {
    get: operations["api_v4_accounts_folders_list"];
    post: operations["api_v4_accounts_folders_create"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/folders/{id}/": {
    get: operations["api_v4_accounts_folders_read"];
    put: operations["api_v4_accounts_folders_update"];
    delete: operations["api_v4_accounts_folders_delete"];
    patch: operations["api_v4_accounts_folders_partial_update"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this folder. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/identity-providers/": {
    get: operations["api_v4_accounts_identity-providers_list"];
    /** @description Custom POST method handler to track identity provider creation. */
    post: operations["api_v4_accounts_identity-providers_create"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/identity-providers/{id}/": {
    get: operations["api_v4_accounts_identity-providers_read"];
    put: operations["api_v4_accounts_identity-providers_update"];
    delete: operations["api_v4_accounts_identity-providers_delete"];
    patch: operations["api_v4_accounts_identity-providers_partial_update"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this identity provider. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/identity-providers/{id}/notify_members/": {
    post: operations["api_v4_accounts_identity-providers_notify_members"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this identity provider. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/internal/offers/campaigns/{campaign_id}/": {
    /** @description Separate ViewSet for managing requests from internal approved services */
    get: operations["api_v4_accounts_internal_offers_campaigns_list"];
    /**
     * @description Creating an Offer can only be performed by an approve-listed Service
     * (A call that comes from within Zapier's owned services)
     */
    post: operations["api_v4_accounts_internal_offers_campaigns_create"];
    parameters: {
      path: {
        account_pk: string;
        campaign_id: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/internal/offers/campaigns/{campaign_id}/{id}/": {
    /** @description Separate ViewSet for managing requests from internal approved services */
    get: operations["api_v4_accounts_internal_offers_campaigns_read"];
    /** @description Separate ViewSet for managing requests from internal approved services */
    put: operations["api_v4_accounts_internal_offers_campaigns_update"];
    /** @description Separate ViewSet for managing requests from internal approved services */
    delete: operations["api_v4_accounts_internal_offers_campaigns_delete"];
    /** @description Separate ViewSet for managing requests from internal approved services */
    patch: operations["api_v4_accounts_internal_offers_campaigns_partial_update"];
    parameters: {
      path: {
        account_pk: string;
        campaign_id: string;
        /** @description A unique integer value identifying this campaign offer. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/invitations/": {
    get: operations["api_v4_accounts_invitations_list"];
    post: operations["api_v4_accounts_invitations_create"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/invitations/{id}/": {
    get: operations["api_v4_accounts_invitations_read"];
    /** @description Revoke the given invitation */
    delete: operations["api_v4_accounts_invitations_delete"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this invitation. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/invitations/{id}/resend/": {
    /**
     * Resend the given invitation
     * @description If the invitation is visible to the user doing the action,
     * then it will be resent, otherwise a 404 will be returned.
     *
     * If the user is not a admin or owner then a 403 is returned
     *
     * If the user's name is spam then a 400 is returned.
     */
    post: operations["api_v4_accounts_invitations_resend"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this invitation. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/members/": {
    get: operations["api_v4_accounts_members_list"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/members/{id}/": {
    get: operations["api_v4_accounts_members_read"];
    put: operations["api_v4_accounts_members_update"];
    /** @description Remove the given user from this account */
    delete: operations["api_v4_accounts_members_delete"];
    patch: operations["api_v4_accounts_members_partial_update"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/memberships/": {
    get: operations["api_v4_accounts_memberships_list"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/memberships/{id}/": {
    get: operations["api_v4_accounts_memberships_read"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/offers/": {
    post: operations["api_v4_accounts_offers_create"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/offers/{id}/": {
    get: operations["api_v4_accounts_offers_read"];
    put: operations["api_v4_accounts_offers_update"];
    patch: operations["api_v4_accounts_offers_partial_update"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this campaign offer. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/provision/": {
    /** @description API for configuring user provisioning */
    get: operations["api_v4_accounts_provision_list"];
    /** @description Custom POST method handler to track account provision creation. */
    post: operations["api_v4_accounts_provision_create"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/provision/{id}/": {
    /** @description API for configuring user provisioning */
    get: operations["api_v4_accounts_provision_read"];
    /** @description API for configuring user provisioning */
    put: operations["api_v4_accounts_provision_update"];
    /** @description API for configuring user provisioning */
    delete: operations["api_v4_accounts_provision_delete"];
    /** @description API for configuring user provisioning */
    patch: operations["api_v4_accounts_provision_partial_update"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this account provision. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/provision/{id}/refresh_token/": {
    /** @description Refresh the token of the underlying provision instance */
    post: operations["api_v4_accounts_provision_refresh_token"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this account provision. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/teams/": {
    get: operations["api_v4_accounts_teams_list"];
    /**
     * @description Overwrite create method so that we can ensure schema generation
     * with the appropriate serializer.
     */
    post: operations["api_v4_accounts_teams_create"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/teams/{id}/": {
    get: operations["api_v4_accounts_teams_read"];
    /**
     * @description Overwrite update method so that we can ensure schema generation
     * with the appropriate serializer.
     */
    put: operations["api_v4_accounts_teams_update"];
    delete: operations["api_v4_accounts_teams_delete"];
    /**
     * @description Overwrite partial_update method so that we can ensure schema generation
     * with the appropriate serializer.
     */
    patch: operations["api_v4_accounts_teams_partial_update"];
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/teams/{team_pk}/members/": {
    get: operations["api_v4_accounts_teams_members_list"];
    /**
     * @description Overwrite create method so that we can ensure schema generation
     * with the appropriate serializer.
     */
    post: operations["api_v4_accounts_teams_members_create"];
    parameters: {
      path: {
        account_pk: string;
        team_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/teams/{team_pk}/members/{id}/": {
    get: operations["api_v4_accounts_teams_members_read"];
    /**
     * Remove the authenticated user from this team
     * @description You can remove yourself from a team as long as you
     * are not the team owner. If you are the team owner,
     * transfer the team to someone else before leaving.
     */
    delete: operations["api_v4_accounts_teams_members_delete"];
    parameters: {
      path: {
        account_pk: string;
        team_pk: string;
        /** @description A unique integer value identifying this team member. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/teams/{team_pk}/requests/": {
    get: operations["api_v4_accounts_teams_requests_list"];
    post: operations["api_v4_accounts_teams_requests_create"];
    parameters: {
      path: {
        account_pk: string;
        team_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/teams/{team_pk}/requests/{id}/": {
    get: operations["api_v4_accounts_teams_requests_read"];
    put: operations["api_v4_accounts_teams_requests_update"];
    patch: operations["api_v4_accounts_teams_requests_partial_update"];
    parameters: {
      path: {
        account_pk: string;
        team_pk: string;
        /** @description A unique integer value identifying this team request. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/virtual-folders/": {
    /** @description Return a list of virtual folders. */
    get: operations["api_v4_accounts_virtual-folders_list"];
    parameters: {
      path: {
        account_pk: string;
      };
    };
  };
  "/api/v4/accounts/{account_pk}/virtual-folders/{id}/": {
    get: operations["api_v4_accounts_virtual-folders_read"];
    parameters: {
      path: {
        account_pk: string;
        id: string;
      };
    };
  };
  "/api/v4/accounts/{id}/": {
    get: operations["api_v4_accounts_read"];
    put: operations["api_v4_accounts_update"];
    patch: operations["api_v4_accounts_partial_update"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/app-stats/": {
    get: operations["api_v4_accounts_get_app_stats"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/discounts/": {
    /**
     * @description Return a list of serialized discounts that have been applied
     * to an account.
     */
    get: operations["api_v4_accounts_discounts"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/entitlements/": {
    /** @description Return a list of entitlements for the account. */
    get: operations["api_v4_accounts_entitlements"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/join/": {
    /**
     * @description Implements join functionality for domain members who meet the
     * criteria for joining their organization's company account.
     */
    post: operations["api_v4_accounts_join"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/metered-pricing-opt-in/": {
    /** @description Opt-in to metered pricing for the account. */
    post: operations["api_v4_accounts_metered_pricing_opt_in"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/policy/": {
    put: operations["api_v4_accounts_set_policy"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/polling-interval-opt-in/": {
    /**
     * @description Opt-in to faster polling interval for the account, after it has been
     * migrated to a higher plan.
     */
    post: operations["api_v4_accounts_polling_interval_opt_in"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/private-apps/": {
    /** @description Get private apps in use by an account and data about them. */
    get: operations["api_v4_accounts_get_private_apps"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/public-apps/": {
    /** @description Get public apps in use by an account and data about them. */
    get: operations["api_v4_accounts_get_public_apps"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/recommend-plan/": {
    /** @description Recommend a plan based on the role/industry of the account owner */
    get: operations["api_v4_accounts_recommend_plan"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/recommended-services/": {
    get: operations["api_v4_accounts_recommended_services"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/recommended-zap-templates/": {
    get: operations["api_v4_accounts_recommended_zap_templates"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/subscription/": {
    patch: operations["api_v4_accounts_modify_subscription"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/task-usage/": {
    /**
     * Get the task usage for the current account and specified facets
     * @description The facets can be specified via query params. Multiple facets can
     * be used in tandem, and they will all be taken in account when generating
     * the aggregation. That is, passing both `folder_id` and `app` means that
     * the aggregation will be done on the tasks belonging to Zaps that are
     * in the given folder and use the said app.
     *
     * The following facets are supported:
     *
     * * `customuser_id`
     *    Generate the task usage for the given customuser. The current user needs
     *    to be an account member to be able to view the tasks of a different
     *    member.
     *
     * * `folder_id`
     *    Generate the task usage for the Zaps found in the given folder ID
     *
     * * `app`
     *    Generate the task usage for the Zaps using this app
     *
     * * `customuser_ids`
     *    Like `customuser_id`, but looks for Zaps owned by any of the
     *    specified customusers.
     *
     * * `folder_ids`
     *    Like `folder_id`, but looks for Zaps in any of the specified folders
     *
     * * `kinds`
     *   Look for Zaps of any of the specified kinds (workflow, transfer, etc.)
     *
     * * `root_ids`
     *    Only looks for Zaps with these ids
     *
     * * `selected_apis`
     *    Like `app`, but looks for Zaps with any of the specified
     *    apps/selected_api values.
     *
     * * `period_start` and `period_end`
     *
     *   Generate the task usage between the specified period.
     *   These dates should be in ISO-8601 format, e.g .` YYYY-MM-DDTHH:MM:SS.mmmmmm`, but we also
     *   support the following variation `YYYY-MM-DD`.
     *   The dates will be converted to the timezone of the user doing the action.
     *
     *   If the difference between `period_start` and `period_end` is large enough, the aggregations
     *   will be done for each individual month between the start and the end. Otherwise daily
     *   aggregations will be computed.
     *
     * The endpoint will return a dictionary of stats, having the following structure:
     *
     * * `interval`: Whether the aggregation buckets in `tasks_breakdown` are `daily`
     *    or `monthly`
     * * `total_tasks_count`: The total number of tasks in the given period
     * * `billable_tasks_count`: The total number of billable tasks in the given period
     * * `tasks_breakdown`
     *    A per date breakdown for the tasks. Each entry will be a dictionary mapping
     *    from a date to a list of status counts for that day / month.
     *    The task breakdown is either per day or per month, depending how big the
     *    gap between `period_start` and `period_end` is.
     * * `status_aggregation`: A dictionary of task statuses to counts
     *
     *         {
     *             "total_tasks_count": <int>
     *             "status_aggregation": {
     *                 "status": <int>,
     *                 ...
     *             },
     *             "tasks_breakdown": {
     *                 "<day>": {
     *                     "status":  <int>
     *                 },
     *                 ...
     *             }
     *         }
     */
    get: operations["api_v4_accounts_get_task_usage"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/top-users/": {
    get: operations["api_v4_accounts_top_users"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/top-zaps/": {
    /**
     * Get the top Zaps for the current account and specified facets
     * @description This view powers up parts of the usage dashboard.
     * The facets can be specified via query params. Multiple facets can
     * be used in tandem, and they will all be taken in account when generating
     * the top Zaps. That is, passing both `folder_id` and `app` means that
     * the aggregation will be done on the tasks belonging of Zaps that are
     * in the given folder and use the said app.
     *
     * The following facets are supported:
     *
     * * `customuser_id`
     *
     *    Find the top Zaps for the given customuser. The current user needs
     *    to be an account member to be able to view the tasks of a different
     *    member.
     *
     * * `folder_id`
     *
     *    Order the Zaps found in `folder_id` by their usage.
     *
     * * `app`
     *
     *    Find the top Zaps that use this app
     *
     * * `period_start` and `period_end`
     *
     *    Find the top Zaps between the specified period.
     *    These dates should be in ISO-8601 format, e.g .` YYYY-MM-DDTHH:MM:SS.mmmmmm`, but we also
     *    support the following variation `YYYY-MM-DD`.
     *    The dates will be converted to the timezone of the user doing the action.
     *
     * * `customuser_ids`
     *
     *    Like `customuser_id`, but looks for Zaps owned by any of the
     *    specified customusers.
     *
     * * `folder_ids`
     *
     *    Like `folder_id`, but looks for Zaps in any of the specified
     *    folders.
     *
     * * `kinds`
     *
     *    Look for Zaps of any of the specified kinds (workflow, transfer, etc.)
     *
     * * `root_ids`
     *
     *    Only looks for Zaps with these ids
     *
     * * `selected_apis`
     *
     *    Like `app`, but looks for Zaps with any of the specified
     *    apps/selected_api values.
     */
    get: operations["api_v4_accounts_get_top_zaps"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/trial-report/": {
    /** @description Get trial statistics report for the current account */
    get: operations["api_v4_accounts_trial_report"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/accounts/{id}/usage/": {
    /** @description Get the zap usage for the current account */
    get: operations["api_v4_accounts_usage"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/actions/controls/": {
    /** @description The endpoint for updating action controls. */
    patch: operations["api_v4_actions_controls"];
  };
  "/api/v4/actions/{var}/": {
    get: operations["api_v4_actions_read"];
    parameters: {
      path: {
        var: string;
      };
    };
  };
  "/api/v4/app-directory/categories/": {
    get: operations["api_v4_app-directory_categories_list"];
  };
  "/api/v4/app-directory/categories/{slug}/": {
    get: operations["api_v4_app-directory_categories_read"];
    parameters: {
      path: {
        slug: string;
      };
    };
  };
  "/api/v4/app-directory/categories/{slug}/apps/": {
    /** @description Returns all of the apps associated with this child apps of this category. */
    get: operations["api_v4_app-directory_categories_apps"];
    parameters: {
      path: {
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
  };
  "/api/v4/app-directory/categories/{slug}/children/": {
    get: operations["api_v4_app-directory_categories_children"];
    parameters: {
      path: {
        slug: string;
      };
    };
  };
  "/api/v4/appextensions/proxy/{which_endpoint}/": {
    get: operations["api_v4_appextensions_proxy_read"];
    put: operations["api_v4_appextensions_proxy_update"];
    post: operations["api_v4_appextensions_proxy_create"];
    delete: operations["api_v4_appextensions_proxy_delete"];
    patch: operations["api_v4_appextensions_proxy_partial_update"];
    parameters: {
      path: {
        which_endpoint: string;
      };
    };
  };
  "/api/v4/appextensions/proxy/{which_endpoint}/{entry_id}/": {
    get: operations["api_v4_appextensions_proxy_read"];
    put: operations["api_v4_appextensions_proxy_update"];
    post: operations["api_v4_appextensions_proxy_create"];
    delete: operations["api_v4_appextensions_proxy_delete"];
    patch: operations["api_v4_appextensions_proxy_partial_update"];
    parameters: {
      path: {
        which_endpoint: string;
        entry_id: string;
      };
    };
  };
  "/api/v4/appextensions/proxy/{which_endpoint}/{entry_id}/{subpath}/": {
    get: operations["api_v4_appextensions_proxy_read"];
    put: operations["api_v4_appextensions_proxy_update"];
    post: operations["api_v4_appextensions_proxy_create"];
    delete: operations["api_v4_appextensions_proxy_delete"];
    patch: operations["api_v4_appextensions_proxy_partial_update"];
    parameters: {
      path: {
        which_endpoint: string;
        entry_id: string;
        subpath: string;
      };
    };
  };
  "/api/v4/apps/": {
    get: operations["api_v4_apps_list"];
  };
  "/api/v4/apps/{app_slug}/discover-zap-templates/": {
    get: operations["api_v4_apps_discover-zap-templates_list"];
    parameters: {
      path: {
        app_slug: string;
      };
    };
  };
  "/api/v4/apps/{app_slug}/discover-zap-templates/{id}/": {
    get: operations["api_v4_apps_discover-zap-templates_read"];
    parameters: {
      path: {
        app_slug: string;
        /** @description A unique integer value identifying this discovery page. */
        id: number;
      };
    };
  };
  "/api/v4/apps/{slug}/": {
    get: operations["api_v4_apps_read"];
    parameters: {
      path: {
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
  };
  "/api/v4/apps/{slug}/exist/": {
    /**
     * @description Check if a service exists, return 404 if it doesn't
     * If an app exists, return simple service data without querying category
     */
    get: operations["api_v4_apps_exist"];
    parameters: {
      path: {
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
  };
  "/api/v4/authentications/": {
    /**
     * List Authentications
     * @description List all authentications visible to the user.
     */
    get: operations["api_v4_authentications_list"];
  };
  "/api/v4/authentications/create/": {
    /**
     * Create Authentication
     * @description Allows the creation of Authentication objects directly; only feasibly
     * used by the Public API as partners are the ones who hold their users'
     * access tokens.
     */
    post: operations["api_v4_authentications_create_auth"];
  };
  "/api/v4/authentications/user-count/": {
    /**
     * Counts of Authentications API
     * @description When provided a list of customuser_ids, returns a list of objects showing how many
     * authentication records each user has.
     *
     * POST a list of customuser_ids in a JSON body to fetch the list of counts for those users.
     * Any user not found will be returned in the response with an auth count of 0
     *
     * To limit the scope of the lookup to a single account, it must be passed in using the
     * `account_id` in the query string
     */
    post: operations["api_v4_authentications_user-count_list"];
  };
  "/api/v4/authentications/zap-count/": {
    /**
     * List visible authentication ids and how many Zaps use them
     * @description Lists the authentications visible to the calling user and how many Zaps
     * use each of them.
     */
    get: operations["api_v4_authentications_zap-count_list"];
  };
  "/api/v4/authentications/{authentication_pk}/members/": {
    /** @description API for accessing the members with which auths have been shared */
    get: operations["api_v4_authentications_members_list"];
    /**
     * @description Share the authentication with the given customuser.
     *
     *             The authentication can be shared with the given customuser
     *             only if the user that does the action is the authentication's owner.
     */
    post: operations["api_v4_authentications_members_create"];
    parameters: {
      path: {
        authentication_pk: string;
      };
    };
  };
  "/api/v4/authentications/{authentication_pk}/members/{id}/": {
    /** @description API for accessing the members with which auths have been shared */
    get: operations["api_v4_authentications_members_read"];
    /**
     * Unshare the authentication from the given customuser
     * @description The authentication can be unshared with the given customuser
     * only if the user that does the action can see the authentication.
     * The current owner of the authentication cannot be removed.
     */
    delete: operations["api_v4_authentications_members_delete"];
    parameters: {
      path: {
        authentication_pk: string;
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/authentications/{authentication_pk}/teams/": {
    /** @description API for accessing the teams with which auths have been shared */
    get: operations["api_v4_authentications_teams_list"];
    /**
     * Share the authentication with a team ID or with all team members
     * @description Only the authentication's owner can share an authentication.
     *
     * This API expects a `team_id` parameter sent as a payload, in the form
     * `{team_id: id|`all`}`
     *
     * If it is sent as an `id`, it needs to be the ID of an already existing team.
     * That team will be able to see this authentication.
     * If it is sent as `all`, then the authentication will be shared with all
     * team account members. A fake payload will be returned in that case, as
     * there is no team that encompasses all the team members other than the magic
     * `all` variable.
     */
    post: operations["api_v4_authentications_teams_create"];
    parameters: {
      path: {
        authentication_pk: string;
      };
    };
  };
  "/api/v4/authentications/{authentication_pk}/teams/{id}/": {
    /** @description API for accessing the teams with which auths have been shared */
    get: operations["api_v4_authentications_teams_read"];
    /**
     * Unshare the given authentication from the given team
     * @description The authentication can be unshared from a team, if the URL has a
     * team ID, or can be unshared from everyone in the team account,
     * if the URL uses the special `all` ID.
     *
     * `all` represents all users in a team account, which is separate
     * than all the members in a team workspace. When doing the operation
     * against `all`, `shared_with_all` flag is set to `False`. We will still
     * keep memberships for members and teams around, those won't be destroyed
     * unless manually removed or if the authentication is completely unshared.
     * When passing `all`, the user that did the action will be added to the list
     * of members that can access the authentication.
     *
     * If `all` is not used, but instead a proper team ID is used, that team will
     * no longer have access to access this authentication.
     */
    delete: operations["api_v4_authentications_teams_delete"];
    parameters: {
      path: {
        authentication_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
  };
  "/api/v4/authentications/{id}/": {
    /**
     * Retrieve Authentication
     * @description Retrieve a specific authentication if visible to the user.
     */
    get: operations["api_v4_authentications_read"];
    delete: operations["api_v4_authentications_delete"];
    patch: operations["api_v4_authentications_partial_update"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this authentication. */
        id: number;
      };
    };
  };
  "/api/v4/authentications/{id}/call/": {
    /**
     * Call Authentication's API
     * @deprecated
     * @description Call the API behind the authentications, if visible to the user.
     *
     * This endpoint is deprecated. You should use the new Conjurer service https://docs.k8s.zapier.com/conjurer/
     */
    post: operations["api_v4_authentications_call"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this authentication. */
        id: number;
      };
    };
  };
  "/api/v4/authentications/{id}/data/": {
    get: operations["api_v4_authentications_data"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this authentication. */
        id: number;
      };
    };
  };
  "/api/v4/authentications/{id}/search/": {
    /**
     * Mildly dangerous endpoint! Authentication is only via JWT, issued by the Notary service.
     * @description Returns Authentication IDs based on the passed in Trigger Susbcription ID or combination of
     * customuser id, account id, and selected api.
     */
    get: operations["api_v4_authentications_search"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this authentication. */
        id: number;
      };
    };
  };
  "/api/v4/authentications/{id}/test/": {
    /**
     * Test the Authentication against it's API to make sure it has been set up correctly and is
     * still valid.
     * @description If the test fails due to a `StaleAuthentication` error then the authentication is marked stale
     * without alerting (no email is sent).
     */
    post: operations["api_v4_authentications_test"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this authentication. */
        id: number;
      };
    };
  };
  "/api/v4/blog-posts/": {
    get: operations["api_v4_blog-posts_list"];
  };
  "/api/v4/blog-posts/{slug}/": {
    get: operations["api_v4_blog-posts_read"];
    parameters: {
      path: {
        slug: string;
      };
    };
  };
  "/api/v4/blogs/": {
    get: operations["api_v4_blogs_list"];
  };
  "/api/v4/blogs/{slug}/": {
    get: operations["api_v4_blogs_read"];
    parameters: {
      path: {
        /** @description This will be the URL for the blog. Ex.: `engineering` will be accessible at zapier.com/engineering/ */
        slug: string;
      };
    };
  };
  "/api/v4/categories/": {
    get: operations["api_v4_categories_list"];
  };
  "/api/v4/categories/{slug}/": {
    get: operations["api_v4_categories_read"];
    parameters: {
      path: {
        slug: string;
      };
    };
  };
  "/api/v4/categories/{slug}/children/": {
    get: operations["api_v4_categories_children"];
    parameters: {
      path: {
        slug: string;
      };
    };
  };
  "/api/v4/communicate/ingest/looker/enqueue/": {
    post: operations["api_v4_communicate_ingest_looker_enqueue_create"];
  };
  "/api/v4/communicate/subscriptions/": {
    post: operations["api_v4_communicate_subscriptions_create"];
  };
  "/api/v4/communicate/sync/": {
    post: operations["api_v4_communicate_sync_create"];
  };
  "/api/v4/communicate/sync/{id}/": {
    delete: operations["api_v4_communicate_sync_delete"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/api/v4/communicate/unsubscribe/": {
    post: operations["api_v4_communicate_unsubscribe_create"];
  };
  "/api/v4/communicate/unsubscriptions/": {
    post: operations["api_v4_communicate_unsubscriptions_create"];
  };
  "/api/v4/communicate/users/subscribedtoblog/{identity}/": {
    /** @description Retrieve User's blog subscription */
    get: operations["api_v4_communicate_users_subscribedtoblog_read"];
    parameters: {
      path: {
        identity: string;
      };
    };
  };
  "/api/v4/confirm-authentication/": {
    /**
     * Start an authentication confirm flow
     * @description This flow asks the user to authenticate in order to confirm them
     * before getting access to a particular feature or action of the product.
     *
     * For instance transfer membership or deleting an account would be the
     * focus of this confirmation flow, in which the user can use either
     * normal username / password combo, Google SSO or any other form of SSO,
     * SAML SSO etc.
     */
    post: operations["api_v4_confirm-authentication_create"];
  };
  "/api/v4/confirm-masquerade/": {
    /** @description Confirm whether the current session is a masquerade session. */
    get: operations["api_v4_confirm-masquerade_list"];
  };
  "/api/v4/currencies/": {
    get: operations["api_v4_currencies_list"];
  };
  "/api/v4/currencies/rates/": {
    get: operations["api_v4_currencies_rates"];
  };
  "/api/v4/data-flow/check/": {
    /**
     * @description Instantiates `selected_api` and calls its `revalidate_data_flow()`
     * method on every item inside `destination_selected_apis`.
     *
     * Will also check if every `destination_selected_api` points to an existing
     * implementation.
     */
    post: operations["api_v4_data-flow_data_flow_check"];
  };
  "/api/v4/debug/": {
    /** @description These endpoints help us trigger errors and test alerting in API clients. */
    get: operations["api_v4_debug_list"];
    /** @description These endpoints help us trigger errors and test alerting in API clients. */
    post: operations["api_v4_debug_create"];
  };
  "/api/v4/debug/{id}/": {
    /** @description These endpoints help us trigger errors and test alerting in API clients. */
    get: operations["api_v4_debug_read"];
    /** @description These endpoints help us trigger errors and test alerting in API clients. */
    put: operations["api_v4_debug_update"];
    /** @description These endpoints help us trigger errors and test alerting in API clients. */
    delete: operations["api_v4_debug_delete"];
    /** @description These endpoints help us trigger errors and test alerting in API clients. */
    patch: operations["api_v4_debug_partial_update"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/api/v4/domain-discovery/": {
    /**
     * @description Check if an email's domain is associated with a Company account that is eligible for domain capture.
     * Accepted parameters: email (string), code (string) - optional
     *
     * Returns an object with the account details if an account with that verified domain is found
     * and the customuser_id if a user with that email exists.
     */
    get: operations["api_v4_domain-discovery_list"];
  };
  "/api/v4/error-notifications/trigger-alert-email": {
    /** @description Send the error alert email to the user based on the user context provided within a Service JWT. */
    post: operations["api_v4_error-notifications_send_alert_email"];
  };
  "/api/v4/error-notifications/zap-visibility/{zap_id}": {
    /** @description Checks if a user has vibility to Zap */
    get: operations["api_v4_error-notifications_get_zap_visibility"];
    parameters: {
      path: {
        zap_id: string;
      };
    };
  };
  "/api/v4/folder-discovery/{id}/": {
    /**
     * Discover the account a folder is in if the user has access to that folder
     * @description Returns the `account_id` where the folder can be found.
     */
    get: operations["api_v4_folder-discovery_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this folder. */
        id: number;
      };
    };
  };
  "/api/v4/followed-apps/": {
    get: operations["api_v4_followed-apps_list"];
  };
  "/api/v4/generator/": {
    /** @description Creates a random (for now) account */
    post: operations["api_v4_generator_create"];
  };
  "/api/v4/guided-recipes/": {
    get: operations["api_v4_guided-recipes_list"];
  };
  "/api/v4/guided-recipes/{id}/": {
    get: operations["api_v4_guided-recipes_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this Guided Zap. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/autocomplete/": {
    /** @description Return a list of app_action values for a given Service ID. */
    get: operations["api_v4_helpdocs_autocomplete_list"];
  };
  "/api/v4/helpdocs/best-troubleshooting/": {
    /**
     * @description View that provides all matching ``helpdocs.models.Generic`` based
     * on the context passed into the query parameters, order by relevancy.
     *
     * These params are supported:
     *
     * * app:           an app's selected_api
     * * app_action:    the key of a particular action (e.g. new_card)
     * * action_type:   trigger, action, or search
     * * related_codes: a CSV with codes to get docs for and order them by
     * * limit          maximum number of tutorials to return
     */
    get: operations["api_v4_helpdocs_best-troubleshooting_list"];
  };
  "/api/v4/helpdocs/best-tutorials/": {
    /**
     * @description View that provides all matching ``helpdocs.models.Tutorial`` based
     * on the context passed into the query parameters, order by relevancy.
     *
     * The following are all the valid query parameters it can pass in.
     *
     * * app - The currently selected Service (slug).
     * * app_action - The selected action for the app.
     * * action_type - Is this a trigger, action, or search?
     * * location - What part of the Zap setup this is in (one of
     *     ``helpdocs.constants.EditorLocation``).
     * * limit - Maximum number of tutorials to return.
     */
    get: operations["api_v4_helpdocs_best-tutorials_list"];
  };
  "/api/v4/helpdocs/best/": {
    /** @description Return the best matching tutorial based on the passed state. */
    get: operations["api_v4_helpdocs_best_list"];
  };
  "/api/v4/helpdocs/categories/": {
    get: operations["api_v4_helpdocs_categories_list"];
  };
  "/api/v4/helpdocs/categories/tree/": {
    get: operations["api_v4_helpdocs_categories_tree"];
  };
  "/api/v4/helpdocs/categories/{id}/": {
    get: operations["api_v4_helpdocs_categories_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this category. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/categories/{id}/content/": {
    get: operations["api_v4_helpdocs_categories_content"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this category. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/category/redirect/{category}/": {
    /** @description This view handles requests that used to go to web-ssr to serve pre-Zendesk */
    get: operations["api_v4_helpdocs_category_redirect_read"];
    parameters: {
      path: {
        category: string;
      };
    };
  };
  "/api/v4/helpdocs/content/redirect/{slug}/": {
    /**
     * @description View intended to capture traffic that used to go to web-ssr to serve pre-Zendesk
     * helpdocs. Usually the redirect url results in yet another redirect defined in an AWS
     * lambda function. We didn't want to disconnect this traffic to lose thousands of requests
     * per day
     *
     * * slug - The slug of the content to redirect to.
     */
    get: operations["api_v4_helpdocs_content_redirect_read"];
    parameters: {
      path: {
        slug: string;
      };
    };
  };
  "/api/v4/helpdocs/content/{slug}/": {
    /** @description Return the first content with matching slug. */
    get: operations["api_v4_helpdocs_content_read"];
    parameters: {
      path: {
        slug: string;
      };
    };
  };
  "/api/v4/helpdocs/faqs/": {
    get: operations["api_v4_helpdocs_faqs_list"];
  };
  "/api/v4/helpdocs/faqs/{id}/": {
    get: operations["api_v4_helpdocs_faqs_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this faq. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/faqs/{id}/suggested/": {
    get: operations["api_v4_helpdocs_faqs_suggested"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this faq. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/feedback/": {
    /**
     * @description Create only view for creating feedback on a doc. Must be a logged
     * in user.
     */
    post: operations["api_v4_helpdocs_feedback_create"];
  };
  "/api/v4/helpdocs/feedback/{id}/": {
    /**
     * @description Create only view for creating feedback on a doc. Must be a logged
     * in user.
     */
    put: operations["api_v4_helpdocs_feedback_update"];
    /**
     * @description Create only view for creating feedback on a doc. Must be a logged
     * in user.
     */
    patch: operations["api_v4_helpdocs_feedback_partial_update"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this feedback. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/generics/": {
    get: operations["api_v4_helpdocs_generics_list"];
  };
  "/api/v4/helpdocs/generics/{id}/": {
    get: operations["api_v4_helpdocs_generics_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this generic. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/generics/{id}/suggested/": {
    get: operations["api_v4_helpdocs_generics_suggested"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this generic. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/ratings/": {
    /**
     * @description Create only view for creating feedback on a doc. Must be a logged
     * in user.
     */
    post: operations["api_v4_helpdocs_ratings_create"];
  };
  "/api/v4/helpdocs/ratings/{id}/": {
    /**
     * @description Create only view for creating feedback on a doc. Must be a logged
     * in user.
     */
    put: operations["api_v4_helpdocs_ratings_update"];
    /**
     * @description Create only view for creating feedback on a doc. Must be a logged
     * in user.
     */
    patch: operations["api_v4_helpdocs_ratings_partial_update"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this feedback. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/references/": {
    get: operations["api_v4_helpdocs_references_list"];
  };
  "/api/v4/helpdocs/references/{id}/": {
    get: operations["api_v4_helpdocs_references_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this reference. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/references/{id}/suggested/": {
    get: operations["api_v4_helpdocs_references_suggested"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this reference. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/steps/{id}/suggested/": {
    /**
     * @description Exists solely to provide the suggested action for hyperlinking
     * in the StepSerializer
     */
    get: operations["api_v4_helpdocs_steps_suggested"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this step. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/sxp-1229/": {
    /** @description View to debug https://zapierorg.atlassian.net/browse/SXP-1229 */
    get: operations["api_v4_helpdocs_sxp-1229_list"];
  };
  "/api/v4/helpdocs/troubleshooting/": {
    get: operations["api_v4_helpdocs_troubleshooting_list"];
  };
  "/api/v4/helpdocs/troubleshooting/{id}/": {
    get: operations["api_v4_helpdocs_troubleshooting_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this troubleshooting. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/troubleshooting/{id}/suggested/": {
    get: operations["api_v4_helpdocs_troubleshooting_suggested"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this troubleshooting. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/tutorials/": {
    get: operations["api_v4_helpdocs_tutorials_list"];
  };
  "/api/v4/helpdocs/tutorials/{id}/": {
    get: operations["api_v4_helpdocs_tutorials_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this tutorial. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/tutorials/{id}/suggested/": {
    get: operations["api_v4_helpdocs_tutorials_suggested"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this tutorial. */
        id: number;
      };
    };
  };
  "/api/v4/helpdocs/videos/": {
    get: operations["api_v4_helpdocs_videos_list"];
  };
  "/api/v4/helpdocs/videos/{id}/": {
    get: operations["api_v4_helpdocs_videos_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this video. */
        id: number;
      };
    };
  };
  "/api/v4/i-was-here/": {
    get: operations["api_v4_i-was-here_list"];
  };
  "/api/v4/identity/": {
    /** @description Displays the identity and authentication status of a user. */
    get: operations["api_v4_identity_list"];
  };
  "/api/v4/identity/{id}/": {
    /** @description Displays the identity and authentication status of a user. */
    get: operations["api_v4_identity_read"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/api/v4/idp-discovery/": {
    /**
     * Find the proper IDP for a provided email address
     * @description If the email has a domain that we know of, we return the URLs
     * that the user should hit to start the SAML flow.
     */
    get: operations["api_v4_idp-discovery_list"];
  };
  "/api/v4/implementations-meta/": {
    /**
     * It's perferred to use /api/v4/implementations for a list of implementations.
     * @description If you want a list of ONLY public implementations, then you'll want to use
     * /implementations-meta
     */
    get: operations["api_v4_implementations-meta_list"];
  };
  "/api/v4/implementations-meta/by-category/": {
    /**
     * Implementations by Category
     * @description Provides performant lookup for public/private Implementations that are related
     * to the provided category and to which the caller has access. This endpoint
     * returns limited details about the Implementation; additional details can be
     * retrieved from other implementations(-meta) endpoints.
     */
    get: operations["api_v4_implementations-meta_get"];
  };
  "/api/v4/implementations-meta/private/": {
    /**
     * List Implementation Meta Info for Private Apps
     * @description Retrieve the meta info about private implementations a user has access to. If one of the implementations they own
     * is publicly available, it will appear in this list as well as the public endpoint. This endpoint excludes details
     * about the actions supported; use the implementations endpoint if you need that.
     * Service Tier: 1
     */
    get: operations["api_v4_implementations-meta_private"];
  };
  "/api/v4/implementations-meta/public/": {
    /**
     * List Implementation Meta Info for Public Apps
     * @description Retrieve the meta info about public implementations. This excludes details about the actions supported; use
     * the implementations endpoint if you need that.
     * By default, returns all records using an efficient query.
     */
    get: operations["api_v4_implementations-meta_public"];
  };
  "/api/v4/implementations-meta/search/": {
    /**
     * Implementation Search
     * @description Provides performant querying for public/private Implementations that the caller
     * has access to. This endpoint returns limited details about the Implementation;
     * additional details can be retrieved from other implementations(-meta) endpoints.
     */
    get: operations["api_v4_implementations-meta_get"];
  };
  "/api/v4/implementations/": {
    /**
     * List Implementations
     * @description Retrieve implementations that are visible to the user. There are a few possible usecases:
     *
     *     1. Public and Private Apps - Use `global=true&public_only=false`
     *     2. Only Public Apps - Use `global=true&public_only=true`
     *     3. Only Private Apps - Use `global=false&public_only=false`
     *     4. A subset of Apps - Use the `selected_apis` filter. The global and public_only flags still apply.
     *
     * An empty list is possible if public apps are excluded and the user has no private apps.
     */
    get: operations["api_v4_implementations_list"];
  };
  "/api/v4/implementations/choices/": {
    /**
     * Get the choices for a dynamic dropdown need.
     * @description Either (`action_id` AND `input_field_id`) OR `prefill` must be provided. If all three
     * are provided, prefill lookup via `action_id` and `input_field_id` will take precedence,
     * and the provided `prefill` value in the request will be used as a fallback.
     *
     * E.g. Google sheets has a "new row in spreadsheet" trigger (new_row_notify_hook).
     * One of the pieces of information it **needs** to know to listen for that trigger
     * is the specific spreadsheet. Because the number of spreadsheets a user has for
     * Google sheets is not static it's called a dynamic need. This view will provide
     * the possible choices for that dynamic need by calling out to the partner api
     * for the information. How to populate the choices is determined by the `prefill`
     * string. It'll look something like `"spreadsheet.id.title"` which is split on
     * `"."` to give the action, id key, and label key.
     */
    post: operations["api_v4_implementations_need_choices"];
  };
  "/api/v4/implementations/details/": {
    /**
     * Check Implementation Visibility
     * @description Check if the requesting customuser has access to the implementation. Response status codes are used to
     * indicate the result of the check:
     *
     * - `204`: requesting customuser has access to the implementation
     * - `400`: invalid request (missing selected_api)
     * - `403`: requesting customuser does not have access to the implementation
     * - `404`: implementation does not exist
     */
    get: operations["api_v4_implementations_details_read"];
  };
  "/api/v4/implementations/gives/": {
    post: operations["api_v4_implementations_gives"];
  };
  "/api/v4/implementations/gives/public/": {
    post: operations["api_v4_implementations_gives_gives"];
  };
  "/api/v4/implementations/invoke/": {
    /**
     * Invoke
     * @description Invokes any action on any app visible to the authenticated user
     *
     * ## Asynchronous Invocation
     *
     * When making an asynchronous invocation, the endpoint will return a
     * `invocation_id` value. This value is a unique identifier that can
     * be used to poll for the results of the invocation.
     *
     * ```python
     * response = requests.post(
     *     url="https://zapier.com/api/v4/implementations/invoke/",
     *     headers={"X-Api-Key": "secret"},
     *     json={
     *         "action": "recipe",
     *         "sync": False,
     *         "type_of": "read",
     *         "selected_api": "App110413CLIAPI@1.0.0",
     *     },
     * )
     *
     * invocation_id = response.json()['invocation_id']
     *
     * response = requests.get(
     *     url=f"https://zapier.com/api/v4/implementations/invoke/{invocation_id}/",
     *     headers={"X-Api-Key": "secret"},
     * )
     * ```
     *
     * Internally, an asynchronous call to this endpoint spawns a celery task. This task handles
     * the actual invocation of the appropriate lambda function for the app, and then stores the
     * response payload, along with some meta data, into S3. Polling for results using the `invocation_id`
     * simply checks if the results exist in S3, and returns them to the caller if they do.
     *
     *
     * ## Synchronous Invocation
     *
     * You can no longer call this endpoint synchronously (unless DEBUG=True), it will respond with a 403 if you try.
     * Please use the Conjurer backed endpoint `/api/v4/implementations/invoke-sync` and see
     * Conjurer docs for more information: https://docs.k8s.zapier.com/conjurer/
     *
     * ## A note about dynamic dropdowns
     * If you are trying to use `/invoke` to fetch options for a dynamic dropdown, you will need to pass along `page=0` in the request body (then `page=1`, `page=2`, etc until you get nothing back or the same set of results as the previous page). Passing along this field will set the `prefill=True` option in meta when we call `read_poll` on the app. This is important to include because many apps change their behavior if they are populating a drop down vs doing a regular poll.
     */
    post: operations["api_v4_implementations_invoke"];
  };
  "/api/v4/implementations/invoke/{invocation_id}/": {
    get: operations["api_v4_implementations_invoke_read"];
    parameters: {
      path: {
        invocation_id: string;
      };
    };
  };
  "/api/v4/implementations/needs/": {
    /**
     * Needs for Implementation
     * @description Get the needs for any action on any app visible to the authenticated user.
     *
     * A few specific conditions to keep in mind for authenticated and unauthenticated api:
     *     - if an auth id is passed in and available to the user, all needs will be returned,
     *       including custom needs if the api does not encounter an error
     *     - if an auth id is not passed in, but a legacy_node_id is passed in, an error will be
     *       returned. auth_id is required if the selected api requires authentication
     *     - if neither an auth or a legacy_node_id is passed in, we'll return as much information
     *       as possible (static needs)
     *     - if the endpoint is unauthenticated, we'll return all the needs including custom needs
     *
     * Call repeatedly with extended `params` matching `needs` keys as there could be custom
     * needs in future results.
     *
     * For example, you might have a `needs` with a single `{key: formId, required: true}`
     * need. Subsequent calls to the needs endpoint with `params` of `{formId: 1234}` will
     * likely result in many more needs.
     */
    post: operations["api_v4_implementations_needs"];
  };
  "/api/v4/implementations/needs/public/": {
    /** @description An endpoint to return the public only needs for an API */
    post: operations["api_v4_implementations_needs_needs"];
  };
  "/api/v4/integrations/shopify/partner/": {
    /** @description This endpoint is used by shopify external app store to initiate the OAuth flow */
    get: operations["api_v4_integrations_shopify_partner_list"];
  };
  "/api/v4/integrations/shopify/partner/auth/": {
    /**
     * @description We handle the OAuth response from shopify.
     * We do security checks but we currently do not store or do anything with token from this flow
     * Reason - this is implemented to meet the App review requirments only.
     */
    get: operations["api_v4_integrations_shopify_partner_auth_list"];
  };
  "/api/v4/integrations/shopify/partner/gdpr/": {
    /** @description Requested when actions from shopify */
    post: operations["api_v4_integrations_shopify_partner_gdpr_create"];
  };
  "/api/v4/internal/accounts/{id}/": {
    get: operations["api_v4_internal_accounts_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/internal/accounts/{id}/entitlements/": {
    get: operations["api_v4_internal_accounts_entitlements"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/internal/accounts/{id}/usage/": {
    get: operations["api_v4_internal_accounts_usage"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
  };
  "/api/v4/internal/recommendations/{id}/": {
    get: operations["api_v4_internal_recommendations_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/internal/users/": {
    get: operations["api_v4_internal_users_list"];
  };
  "/api/v4/internal/users/{id}/": {
    get: operations["api_v4_internal_users_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/internal/users/{id}/ab_tests/": {
    get: operations["api_v4_internal_users_ab_tests"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/internal/users/{id}/aliases/": {
    post: operations["api_v4_internal_users_aliases"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/internal/users/{id}/implementations/": {
    get: operations["api_v4_internal_users_implementations"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/internal/users/{id}/is_hellbanned/": {
    get: operations["api_v4_internal_users_is_hellbanned"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/internal/users/{id}/is_high_value/": {
    get: operations["api_v4_internal_users_is_high_value"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/internal/users/{id}/mailgun/": {
    get: operations["api_v4_internal_users_mailgun"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/internal/users/{id}/notes/": {
    get: operations["api_v4_internal_users_notes"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/internal/users/{id}/zaps/": {
    get: operations["api_v4_internal_users_zaps"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
  };
  "/api/v4/internal/zaps/{id}/exempt/": {
    /** @description Set is_billing_exempt for a zap */
    put: operations["api_v4_internal_zaps_exempt"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this node. */
        id: number;
      };
    };
  };
  "/api/v4/invitations/{invitation_code}/": {
    /**
     * Endpoint for retrieving an invitation given a valid invitation code
     * @description This is accessible by anonymous users.
     */
    get: operations["api_v4_invitations_read"];
    /**
     * Accept the given invitation
     * @description The user needs to be authenticated to access this endpoint.
     * The invitation must be addressed to the authenticated user for the operation
     * to succeed.
     *
     * If the invitation was successfully accepted, a 200 status code
     * response will be returned with no payload.
     *
     * If the invitation acceptance failed, a 400 status code will be returned.
     * A `reason` field might be present, which indicates one of the following possible
     * reasons to fail:
     *
     *   * revoked - The invitation was already revoked
     *   * expired - The invitation expired
     *   * used - The invitation was already used
     *   * mismatched-email - The email of the invitation is not the same as the email of the authenticated user
     *   * member-count-exceeded - Cannot join the invitation's account as it has too many members
     *
     * The invitation may also be associated with a team, in which case the
     * user accepting the invitation will also be added to the team.
     */
    patch: operations["api_v4_invitations_partial_update"];
    parameters: {
      path: {
        invitation_code: string;
      };
    };
  };
  "/api/v4/invitations/{invitation_code}/decline/": {
    /**
     * This endpoint is used for exposing invitations by code
     * @description The actual invitations endpoint is scoped under an account ID
     */
    put: operations["api_v4_invitations_decline"];
    parameters: {
      path: {
        invitation_code: string;
      };
    };
  };
  "/api/v4/jwt/token-exchange": {
    /**
     * @description
     * [DEPRECATED] - The pattern of exchanging a service JWT for a user JWT is deprecated.
     *
     * Exchange a Service JWT for a User JWT. JWTs in the `Authorization` header
     * must have their `aud` claim set to `"identity:token-exchange"` and be
     * from an allowed issuer (see `identity.jwt.constants.JWT_EXCHANGE_ISSUER_ALLOWLIST`).
     */
    post: operations["api_v4_jwt_token-exchange_create"];
  };
  "/api/v4/legal/terms-acceptance/{term_name}": {
    /**
     * @description
     * Retrieves the acceptance date for the given term
     */
    get: operations["api_v4_legal_terms-acceptance_read"];
    /**
     * @description
     * Sets the date for the given term (if it hasn't already been set)
     */
    post: operations["api_v4_legal_terms-acceptance_create"];
    parameters: {
      path: {
        term_name: string;
      };
    };
  };
  "/api/v4/masquerade/urls": {
    post: operations["api_v4_masquerade_urls_create"];
  };
  "/api/v4/noun-steps/": {
    /**
     * List Noun Step Connections
     * @description These map between actions and nouns, in one or the other direction.
     */
    get: operations["api_v4_noun-steps_list"];
  };
  "/api/v4/noun-steps/{id}/": {
    /**
     * Retrieve Noun Step Connection
     * @description Get a specific noun step connection by id.
     */
    get: operations["api_v4_noun-steps_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this noun step connection. */
        id: number;
      };
    };
  };
  "/api/v4/nouns/": {
    /**
     * List Nouns
     * @description Nouns define a set of fields that represent some schema.
     */
    get: operations["api_v4_nouns_list"];
  };
  "/api/v4/nouns/{slug}/": {
    /**
     * Retrieve Noun
     * @description Get a specific noun according to it's slug.
     */
    get: operations["api_v4_nouns_read"];
    parameters: {
      path: {
        slug: string;
      };
    };
  };
  "/api/v4/oauth/applications/": {
    /** @description Lists OAuth applications for a given integration */
    get: operations["api_v4_oauth_applications_list"];
  };
  "/api/v4/oauth/applications/{id}/": {
    /** @description Update a OAuth application. */
    put: operations["api_v4_oauth_applications_update"];
    patch: operations["api_v4_oauth_applications_partial_update"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this application. */
        id: number;
      };
    };
  };
  "/api/v4/oauth/applications/{id}/regenerate_client_secret/": {
    /** @description regenerate client secret of an OAuth application. */
    patch: operations["api_v4_oauth_applications_regenerate_client_secret"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this application. */
        id: number;
      };
    };
  };
  "/api/v4/oauth/token-exchange": {
    post: operations["api_v4_oauth_token-exchange_create"];
  };
  "/api/v4/onboardings/": {
    get: operations["api_v4_onboardings_list"];
    post: operations["api_v4_onboardings_create"];
  };
  "/api/v4/onboardings/{id}/": {
    get: operations["api_v4_onboardings_read"];
    put: operations["api_v4_onboardings_update"];
    delete: operations["api_v4_onboardings_delete"];
    patch: operations["api_v4_onboardings_partial_update"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this onboarding. */
        id: number;
      };
    };
  };
  "/api/v4/persisted-modals/": {
    get: operations["api_v4_persisted-modals_list"];
  };
  "/api/v4/persisted-modals/dismiss/": {
    post: operations["api_v4_persisted-modals_dismiss"];
  };
  "/api/v4/persisted-modals/persist/": {
    post: operations["api_v4_persisted-modals_persist"];
  };
  "/api/v4/poc/enable_poc/": {
    post: operations["api_v4_poc_enable_poc"];
  };
  "/api/v4/policies/": {
    get: operations["api_v4_policies_list"];
  };
  "/api/v4/policies/agreements/pending/": {
    get: operations["api_v4_policies_agreements_pending_list"];
  };
  "/api/v4/policies/{policy_slug}/agreements/": {
    post: operations["api_v4_policies_agreements_create"];
    parameters: {
      path: {
        policy_slug: string;
      };
    };
  };
  "/api/v4/policies/{slug}/": {
    get: operations["api_v4_policies_read"];
    parameters: {
      path: {
        /** @description A unique slug for the policy. If blank, autogenerated from the title of the policy. */
        slug: string;
      };
    };
  };
  "/api/v4/press-pages/": {
    get: operations["api_v4_press-pages_list"];
  };
  "/api/v4/press-pages/{id}/": {
    get: operations["api_v4_press-pages_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this press page article. */
        id: number;
      };
    };
  };
  "/api/v4/profile/": {
    /** @description Retrieve the current profile */
    get: operations["api_v4_profile_read"];
    /**
     * @description Delete the currently logged in user
     *
     *         The `auth_token` query parameter is required as it is needed
     *         for verifying that the user confirmed their action.
     */
    delete: operations["api_v4_profile_delete"];
  };
  "/api/v4/recommendations/company_sizes/": {
    get: operations["api_v4_recommendations_company_sizes_list"];
  };
  "/api/v4/recommendations/company_sizes/{id}/": {
    get: operations["api_v4_recommendations_company_sizes_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this company size. */
        id: number;
      };
    };
  };
  "/api/v4/recommendations/roles/": {
    get: operations["api_v4_recommendations_roles_list"];
  };
  "/api/v4/recommendations/roles/{id}/": {
    get: operations["api_v4_recommendations_roles_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this role. */
        id: number;
      };
    };
  };
  "/api/v4/registry/actions/": {
    /** @description A viewset that provides CRUD operations for the Action model. */
    get: operations["api_v4_registry_actions_list"];
    /** @description A viewset that provides CRUD operations for the Action model. */
    post: operations["api_v4_registry_actions_create"];
  };
  "/api/v4/registry/actions/{action_id}/": {
    /** @description A viewset that provides CRUD operations for the Action model. */
    get: operations["api_v4_registry_actions_read"];
    /** @description A viewset that provides CRUD operations for the Action model. */
    put: operations["api_v4_registry_actions_update"];
    /** @description A viewset that provides CRUD operations for the Action model. */
    delete: operations["api_v4_registry_actions_delete"];
    parameters: {
      path: {
        action_id: string;
      };
    };
  };
  "/api/v4/registry/actions/{action_id}/publish/": {
    /**
     * @description A specific endpoint for changing an action's status to `public`.
     * It is only available to staff users, for now.
     */
    post: operations["api_v4_registry_actions_publish"];
    parameters: {
      path: {
        action_id: string;
      };
    };
  };
  "/api/v4/registry/actions/{action_id}/share/": {
    /** @description The endpoint used for sharing an action with customusers and accounts. */
    patch: operations["api_v4_registry_actions_share"];
    parameters: {
      path: {
        action_id: string;
      };
    };
  };
  "/api/v4/review-pages/": {
    get: operations["api_v4_review-pages_list"];
  };
  "/api/v4/review-pages/{id}/": {
    get: operations["api_v4_review-pages_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this review page. */
        id: number;
      };
    };
  };
  "/api/v4/samples/action/": {
    /**
     * Initiate a sample for a action.
     * @description > Note: Requires that the user making the request is an admin.
     *
     * ---
     *
     * On success, the request will return JSON containing a `session_id` and `metadata`.
     *
     * ---
     *
     * The consumer will have two choices in receiving results:
     *
     * Option 1: the caller may want to listen for:
     *  - [SampleSuccessEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/platform.sampling.SampleSuccessEvent)
     *  - [SampleFailureEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/platform.sampling.SampleFailureEvent)
     *
     * Option 2: the caller can use the related `v4/samples/<session_id>/` endpoint to
     * retrieve results.
     */
    post: operations["api_v4_samples_sample_action"];
  };
  "/api/v4/samples/trigger/": {
    /**
     * Initiate a sample for a trigger.
     * @description > Note: Requires that the user making the request is an admin.
     *
     * ---
     *
     * On success, the request will return JSON containing a `session_id` and `metadata`.
     *
     * The `session_id` represents either an attempt or a trigger subscription claim:
     *  - An id prepended with `a.<uuid>` is an attempt id.
     *  - An id prepended with `c.<uuid>` is a trigger subscription claim id.
     *
     * ---
     *
     * The consumer will have two choices in receiving results:
     *
     * Option 1: the caller may want to listen for:
     *  - [SampleSuccessEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/platform.sampling.SampleSuccessEvent)
     *  - [SampleFailureEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/platform.sampling.SampleFailureEvent)
     *
     * Option 2: the caller can use the related `v4/samples/<session_id>/` endpoint to
     * retrieve results.
     */
    post: operations["api_v4_samples_sample_trigger"];
  };
  "/api/v4/samples/{session_id}/": {
    /**
     * @description Retrieve the samples for a trigger or action, that has been put into sampling mode via the
     * `/api/v4/samples/(trigger|action)` API.
     *
     * > Note: Requires that the user making the request is an admin.
     *
     * ---
     *
     * On success, the request will return JSON containing a `results` key which is a list of the
     * data from the sample
     *
     * On failure will return JSON containing `error_message` and `error_type` keys, which describe
     * the failure.
     *
     * ---
     *
     * For polling triggers and hooks using a polling fallback, after results are returned once,
     * subsequent calls to this endpoint with the same id will 404. This will be the way for
     * clients to know they need to call /samples/trigger again to start another poll.
     *
     * For hook triggers and actions, the endpoint should continue to return the available results until
     * the session expires. Once expired, the endpoint will 404.
     */
    get: operations["api_v4_samples_read"];
    parameters: {
      path: {
        session_id: string;
      };
    };
  };
  "/api/v4/security/domain/headers/": {
    post: operations["api_v4_security_domain_headers_create"];
  };
  "/api/v4/seo-data/": {
    get: operations["api_v4_seo-data_list"];
  };
  "/api/v4/seo-data/{id}/": {
    get: operations["api_v4_seo-data_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this seo data. */
        id: number;
      };
    };
  };
  "/api/v4/services/": {
    get: operations["api_v4_services_list"];
  };
  "/api/v4/services/{service_slug}/alternatives/": {
    get: operations["api_v4_services_alternatives_list"];
    parameters: {
      path: {
        service_slug: string;
      };
    };
  };
  "/api/v4/services/{service_slug}/alternatives/{id}/": {
    get: operations["api_v4_services_alternatives_read"];
    parameters: {
      path: {
        service_slug: string;
        /** @description A unique integer value identifying this app alternative. */
        id: number;
      };
    };
  };
  "/api/v4/services/{service_slug}/media/": {
    get: operations["api_v4_services_media_list"];
    parameters: {
      path: {
        service_slug: string;
      };
    };
  };
  "/api/v4/services/{service_slug}/media/{id}/": {
    get: operations["api_v4_services_media_read"];
    parameters: {
      path: {
        service_slug: string;
        /** @description A unique integer value identifying this app media. */
        id: number;
      };
    };
  };
  "/api/v4/services/{service_slug}/meta-updates/": {
    get: operations["api_v4_services_meta-updates_list"];
    parameters: {
      path: {
        service_slug: string;
      };
    };
  };
  "/api/v4/services/{service_slug}/pairs/": {
    get: operations["api_v4_services_pairs_list"];
    parameters: {
      path: {
        service_slug: string;
      };
    };
  };
  "/api/v4/services/{service_slug}/pairs/{slug}/": {
    get: operations["api_v4_services_pairs_read"];
    parameters: {
      path: {
        service_slug: string;
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
  };
  "/api/v4/services/{service_slug}/pricing-plans/": {
    get: operations["api_v4_services_pricing-plans_list"];
    parameters: {
      path: {
        service_slug: string;
      };
    };
  };
  "/api/v4/services/{service_slug}/pricing-plans/{id}/": {
    get: operations["api_v4_services_pricing-plans_read"];
    parameters: {
      path: {
        service_slug: string;
        /** @description A unique integer value identifying this Service Pricing Plan. */
        id: number;
      };
    };
  };
  "/api/v4/services/{service_slug}/requests/": {
    get: operations["api_v4_services_requests_list"];
    post: operations["api_v4_services_requests_create"];
    parameters: {
      path: {
        service_slug: string;
      };
    };
  };
  "/api/v4/services/{service_slug}/requests/{id}/": {
    get: operations["api_v4_services_requests_read"];
    put: operations["api_v4_services_requests_update"];
    patch: operations["api_v4_services_requests_partial_update"];
    parameters: {
      path: {
        service_slug: string;
        /** @description A unique integer value identifying this service request. */
        id: number;
      };
    };
  };
  "/api/v4/services/{service_slug}/requests/{id}/notes/": {
    /** @description Make the service request 'awesome', 'passable', or 'rejected' */
    post: operations["api_v4_services_requests_notes"];
    parameters: {
      path: {
        service_slug: string;
        /** @description A unique integer value identifying this service request. */
        id: number;
      };
    };
  };
  "/api/v4/services/{slug}/": {
    get: operations["api_v4_services_read"];
    parameters: {
      path: {
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
  };
  "/api/v4/services/{slug}/can_provide_profile/": {
    get: operations["api_v4_services_can_provide_profile"];
    parameters: {
      path: {
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
  };
  "/api/v4/services/{slug}/service_pairs/": {
    get: operations["api_v4_services_service_pairs"];
    parameters: {
      path: {
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
  };
  "/api/v4/session/": {
    /**
     * @description The URL structure here is of the list-format, but that's because
     * the primary key is implied by the session. There are several ways
     * to handle this conversion in DRF, but this is, IMO, the simplest.
     */
    get: operations["api_v4_session_list"];
  };
  "/api/v4/session/token-exchange": {
    post: operations["api_v4_session_token-exchange_create"];
  };
  "/api/v4/shared_zaps/": {
    get: operations["api_v4_shared_zaps_list"];
    post: operations["api_v4_shared_zaps_create"];
  };
  "/api/v4/shared_zaps/{link_hash}/": {
    get: operations["api_v4_shared_zaps_read"];
    put: operations["api_v4_shared_zaps_update"];
    /** @description Unshare a Zap with the given link hash */
    delete: operations["api_v4_shared_zaps_delete"];
    patch: operations["api_v4_shared_zaps_partial_update"];
    parameters: {
      path: {
        link_hash: string;
      };
    };
  };
  "/api/v4/sharing_stats/by_creator_id/{creator_id}//": {
    get: operations["api_v4_sharing_stats_by_creator_id"];
    parameters: {
      path: {
        creator_id: string;
      };
    };
  };
  "/api/v4/sharing_stats/by_selected_api/{selected_api}//": {
    get: operations["api_v4_sharing_stats_by_selected_api"];
    parameters: {
      path: {
        selected_api: string;
      };
    };
  };
  "/api/v4/sharing_stats/by_shared_zap/{zuid}//": {
    get: operations["api_v4_sharing_stats_by_shared_zap"];
    parameters: {
      path: {
        zuid: string;
      };
    };
  };
  "/api/v4/support-eligibility/": {
    /** @description Determine if a user is eligible for various types of support. */
    get: operations["api_v4_support-eligibility_list"];
  };
  "/api/v4/support-notes/": {
    /** @description Returns a set of notes associated with a hierarchy. */
    get: operations["api_v4_support-notes_list"];
  };
  "/api/v4/support-notes/{slug}/": {
    /** @description Returns a set of notes associated with a hierarchy. */
    get: operations["api_v4_support-notes_read"];
    parameters: {
      path: {
        slug: string;
      };
    };
  };
  "/api/v4/support/ticket/zendesk/": {
    /**
     * @description Create a ticket in Zendesk via their API.
     * Falls back to create a ticket by direct email if API creation fails.
     */
    post: operations["api_v4_support_ticket_zendesk_create"];
  };
  "/api/v4/testimonials/": {
    get: operations["api_v4_testimonials_list"];
  };
  "/api/v4/testimonials/{id}/": {
    get: operations["api_v4_testimonials_read"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this testimonial. */
        id: number;
      };
    };
  };
  "/api/v4/tracking/event/": {
    /**
     * @description For folks that need to emit Avro events outside of our AWS environment,
     * they can make use of the v4 Events API. Events that originate from a
     * frontend application or an external Zapier system should use this API.
     * Events that are emitted by systems within our AWS environment should
     * not use the events API. Those systems should use the events toolkit
     * directly to emit events.  This API is also not currently suitable for
     * emitting actionable events. (e.g. events that would drive transactional
     * processing by systems/services like the engine.)
     *
     * To make use of this API, you'll need to make sure the Avro schema(s) for
     * your event types include `"events_api": true` as a top-level key/value pair.
     * This schema meta information informs the Events API that an event type
     * should be allowed to be emitted.
     *
     * Please reference the Events API emitting section of the Events Toolkit
     * Manual for more background information:
     */
    post: operations["api_v4_tracking_event_create"];
  };
  "/api/v4/tracking/event/test/": {
    /**
     * @description For folks that need to emit Avro events outside of our AWS environment,
     * they can make use of the v4 Events API. Events that originate from a
     * frontend application or an external Zapier system should use this API.
     * Events that are emitted by systems within our AWS environment should
     * not use the events API. Those systems should use the events toolkit
     * directly to emit events.  This API is also not currently suitable for
     * emitting actionable events. (e.g. events that would drive transactional
     * processing by systems/services like the engine.)
     *
     * To make use of this API, you'll need to make sure the Avro schema(s) for
     * your event types include `"events_api": true` as a top-level key/value pair.
     * This schema meta information informs the Events API that an event type
     * should be allowed to be emitted.
     *
     * Please reference the Events API emitting section of the Events Toolkit
     * Manual for more background information:
     */
    post: operations["api_v4_tracking_event_test_create"];
  };
  "/api/v4/triggers/": {
    /**
     * Return all active claims for trigger subscriptions.
     * @description If the caller is service-to-service (or admin), they can provide a customuser_id
     * along with account_id (which remains subject to permissions). If you get a 403,
     * the membership of customuser_id to account_id likely why.
     */
    get: operations["api_v4_triggers_list"];
    /**
     * Create a claim on a trigger subscription.
     * @description Side effects:
     * - On success the avro event [event.zapier.app_platform.trigger.InitializationSuccessEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/event.zapier.app_platform.trigger.InitializationSuccessEvent) will be emitted.
     * - On failure the avro event [event.zapier.app_platform.trigger.InitializationFailureEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/event.zapier.app_platform.trigger.InitializationFailureEvent) will be emitted.
     *
     * If this endpoint returns a failure, we may not emit an error event. An error response from this endpoint could be because auth doesn’t match the selected_api, or user doesn’t have permission to that auth, or selected_api doesn’t exist.
     */
    post: operations["api_v4_triggers_create"];
  };
  "/api/v4/triggers/{claim_id}/": {
    /**
     * Release a claim to a trigger subscription.
     * @description Requires the user making the request to be an admin or be the claim's owner.
     */
    delete: operations["api_v4_release_claim"];
    parameters: {
      path: {
        claim_id: string;
      };
    };
  };
  "/api/v4/updates/": {
    get: operations["api_v4_updates_list"];
  };
  "/api/v4/updates/{slug}/": {
    get: operations["api_v4_updates_read"];
    parameters: {
      path: {
        slug: string;
      };
    };
  };
  "/api/v4/use-cases/": {
    get: operations["api_v4_use-cases_list"];
  };
  "/api/v4/use-cases/{slug}/": {
    get: operations["api_v4_use-cases_read"];
    parameters: {
      path: {
        slug: string;
      };
    };
  };
  "/api/v4/use-cases/{use_case_slug}/step/{step_pk}/action-search/": {
    get: operations["api_v4_use-cases_step_step_action_ranking_search"];
    parameters: {
      path: {
        use_case_slug: string;
        step_pk: string;
      };
    };
  };
  "/api/v4/use-cases/{use_case_slug}/step/{step_pk}/actions/": {
    get: operations["api_v4_use-cases_step_step_action_rankings"];
    parameters: {
      path: {
        use_case_slug: string;
        step_pk: string;
      };
    };
  };
  "/api/v4/user-photo-upload/": {
    post: operations["api_v4_user-photo-upload_create"];
  };
  "/api/v4/user-skill-levels/": {
    get: operations["api_v4_user-skill-levels_list"];
  };
  "/api/v4/user-skill-levels/{action_key}/complete/": {
    post: operations["api_v4_user-skill-levels_complete_action"];
    parameters: {
      path: {
        action_key: string;
      };
    };
  };
  "/api/v4/whoami/": {
    /**
     * @description The URL structure here is of the list-format, but that's because
     * the primary key is implied by the session. There are several ways
     * to handle this conversion in DRF, but this is, IMO, the simplest.
     */
    get: operations["api_v4_whoami_list"];
  };
  "/api/v4/zaps/": {
    /**
     * List all the Zaps that the current user has access to in this account context
     * @description The account context needs to be passed by `account_id` query param, otherwise
     * all Zaps that the user has access to across all the user's accounts will be included.
     */
    get: operations["api_v4_zaps_list"];
  };
  "/api/v4/zaps/bulk-delete/": {
    /** @description Bulk delete a list of Zaps */
    post: operations["api_v4_zaps_bulk_delete"];
  };
  "/api/v4/zaps/bulk-transfer/": {
    /** @description Bulk transfer a list of Zaps to a new owner */
    post: operations["api_v4_zaps_bulk_transfer"];
  };
  "/api/v4/zaps/export/": {
    /**
     * Export a list of zaps
     * @description There are two ways to export the zaps. One is to pass a list of zap IDs
     * with `zap_ids` POST field. The other one is to export all the zaps
     * from the account passed via `account_id` POST field.
     *
     * A list of serialized zaps will be returned.
     */
    post: operations["api_v4_zaps_export_zaps"];
  };
  "/api/v4/zaps/import/": {
    /**
     * Import zaps from a given zapfile
     * @description The import needs a `zapfile` sent as a multipart file. Additionally
     * you can send `destination_folder_id`, which should specify
     * a folder where the zaps need to be imported, and `account_id`, which scopes
     * the account in which the zaps need to be imported, as long as the user
     * doing the action is a member of the said account.
     */
    post: operations["api_v4_zaps_import_zaps"];
  };
  "/api/v4/zaps/move/": {
    /** @description Move a list of zaps to a different target account */
    post: operations["api_v4_zaps_move_zaps"];
  };
  "/api/v4/zaps/trash/": {
    /** @description Get the list of trashed zaps */
    get: operations["api_v4_zaps_get_trash"];
  };
  "/api/v4/zaps/usage/": {
    /**
     * A simple resource which returns the number of off, on, and draft Zaps
     * a user has, broken down by account ID.
     * @description Introduced to make it easier (read: possible) to decide whether the "move
     * zaps" button should be shown or not (as this depends on whether the user
     * has any Zaps in any of their accounts). In future, when we remove the
     * scoping for all endpoints, this will be more consistent!
     */
    get: operations["api_v4_zaps_get_zap_usage"];
  };
  "/api/v4/zaps/{id}/": {
    get: operations["api_v4_zaps_read"];
    /**
     * Update a Zap
     * @description Only three fields can be updated; `title`, `folder_id` and `customuser_id`.
     */
    put: operations["api_v4_zaps_update"];
    /** @description Remove the given Zap */
    delete: operations["api_v4_zaps_delete"];
    patch: operations["api_v4_zaps_partial_update"];
    parameters: {
      path: {
        /** @description A unique integer value identifying this node. */
        id: number;
      };
    };
  };
  "/api/v4/zaps/{node_pk}/choices/": {
    get: operations["api_v4_zaps_choices_list"];
    parameters: {
      path: {
        node_pk: string;
      };
    };
  };
  "/api/v4/zaps/{node_pk}/choices/{action}/": {
    get: operations["api_v4_zaps_choices_read"];
    parameters: {
      path: {
        node_pk: string;
        action: string;
      };
    };
  };
  "/api/v4/zdl/convert-to-nodes/": {
    /**
     * @description Convert the provided ZDL document to the equivalent Zap of Nodes,
     * optionally unpausing the Zap.
     */
    post: operations["api_v4_zdl_convert-to-nodes_create"];
  };
  "/api/v4/zdl/run/published": {
    post: operations["api_v4_zdl_run_published_create"];
  };
  "/api/v4/zdl/validate": {
    /** @description Validate the provided ZDL. */
    post: operations["api_v4_zdl_validate_create"];
  };
  "/api/zap-history/public/v1/zap-runs": {
    /** @description Retrieves a list of Zap runs, optionally using various filtering facets. */
    get: operations["api_zap-history_public_v1_zap-runs_list"];
  };
  "/api/zap-history/v1/task-usage": {
    /**
     * @description **Team Monitor is currently iterating on this endpoint as a replacement for `v4/accounts/{account_id}/task-usage`
     * and it may not be ready for full-time adoption.** Please reach out over in #team-monitor!
     * We want to hear feedback about how your team uses the pre-existing endpoints and what you
     * would want to see out of new ones.
     */
    get: operations["api_zap-history_v1_task-usage_list"];
  };
  "/api/zap-history/v1/top-zaps": {
    /**
     * @description **Team Monitor is currently iterating on this endpoint as a replacement for `v4/accounts/{account_id}/top-zaps`
     * and it may not be ready for full-time adoption.** Please reach out over in #team-monitor!
     * We want to hear feedback about how your team uses the pre-existing endpoints and what you
     * would want to see out of new ones.
     *
     * Retrieve the top Zaps for a given account based on the provided filters.
     */
    get: operations["api_zap-history_v1_top-zaps_list"];
  };
  "/api/zap-history/v2/analytics/error-rate-by-zap-table": {
    /**
     * @description Retrieve task usage broken down by Owner, in a format suitable
     * to populate the Top X table in the Analytics Dashboard.
     */
    get: operations["api_zap-history_v2_analytics_error-rate-by-zap-table_list"];
  };
  "/api/zap-history/v2/analytics/task-usage-by-app-table": {
    /**
     * @description Retrieve task usage broken down by App, in a format suitable
     * to populate the Top X table in the Analytics Dashboard.
     */
    get: operations["api_zap-history_v2_analytics_task-usage-by-app-table_list"];
  };
  "/api/zap-history/v2/analytics/task-usage-by-owner-table": {
    /**
     * @description Retrieve task usage broken down by Owner, in a format suitable
     * to populate the Top X table in the Analytics Dashboard.
     */
    get: operations["api_zap-history_v2_analytics_task-usage-by-owner-table_list"];
  };
  "/api/zap-history/v2/analytics/task-usage-by-zap-table": {
    /**
     * @description Retrieve task usage broken down by Zap, in a format suitable
     * to populate the Top X table in the Analytics Dashboard.
     */
    get: operations["api_zap-history_v2_analytics_task-usage-by-zap-table_list"];
  };
  "/api/zap-history/v2/runs": {
    /** @description Retrieves a list of Zap runs, optionally using various filtering facets. */
    get: operations["api_zap-history_v2_runs_list"];
  };
  "/api/zap-history/v2/runs/bulk-delete": {
    post: operations["api_zap-history_v2_runs_bulk-delete_create"];
  };
  "/api/zap-history/v2/runs/bulk-replay": {
    post: operations["api_zap-history_v2_runs_bulk-replay_create"];
  };
  "/api/zap-history/v2/runs/export": {
    post: operations["api_zap-history_v2_runs_export_create"];
  };
  "/api/zap-history/v2/runs/held-count": {
    /**
     * This is a brand new endpoint that is still being proved and not yet
     * ready for use.
     * @description Returns counts of held runs based on filters provided via query
     * parameters.
     */
    get: operations["api_zap-history_v2_runs_held-count_list"];
  };
  "/api/zap-history/v2/runs/request-logs/{invocation_id}": {
    /** @description Retrieve request/response logs for a provided invocation ID. */
    get: operations["api_zap-history_v2_runs_request-logs_read"];
    parameters: {
      path: {
        invocation_id: string;
      };
    };
  };
  "/api/zap-history/v2/runs/top-runs": {
    /** @description List top zaps for given search parameters. */
    get: operations["api_zap-history_v2_runs_top-runs_list"];
  };
  "/api/zap-history/v2/runs/usage": {
    /** @description Gets graph data of zap usage in per-day buckets. */
    get: operations["api_zap-history_v2_runs_usage_list"];
  };
  "/api/zap-history/v2/runs/zap-run-counts": {
    get: operations["api_zap-history_v2_runs_zap-run-counts_list"];
  };
  "/api/zap-history/v2/runs/{run_id}": {
    /**
     * This is a brand new endpoint that is still being proved and not yet ready for use.
     * @description Retrieves the full details of a Zap run.
     */
    get: operations["api_zap-history_v2_runs_read"];
    parameters: {
      path: {
        run_id: string;
      };
    };
  };
  "/api_public/beta/zap/{node_id}/pause": {
    /**
     * Pause a running Zap
     * @description Attempt to pause the Zap that corresponds to node `node_id`.
     * A Zap can only be paused if it is owned by the current user and the access token contains the scope `zap:pause`.
     */
    put: operations["api_public_beta_zap_pause_update"];
    parameters: {
      path: {
        node_id: string;
      };
    };
  };
  "/player/": {
    get: operations["player_list"];
    post: operations["player_create"];
  };
  "/player/confirmation": {
    get: operations["player_confirmation_list"];
    post: operations["player_confirmation_create"];
  };
  "/scim/v2/.search": {
    get: operations["scim_v2_.search_list"];
  };
  "/scim/v2/Bulk": {
    get: operations["scim_v2_Bulk_list"];
  };
  "/scim/v2/Groups": {
    get: operations["scim_v2_Groups_list"];
    /** @description Create a new team from the given SCIM blob */
    post: operations["scim_v2_Groups_create"];
  };
  "/scim/v2/Groups/.search": {
    post: operations["scim_v2_Groups_search"];
  };
  "/scim/v2/Groups/{id}": {
    /** @description Retrieve the underlying object */
    get: operations["scim_v2_Groups_read"];
    /** @description Update the underlying object with the values received from the IdP */
    put: operations["scim_v2_Groups_update"];
    /** @description Implement PATCH support for the underlying resource */
    patch: operations["scim_v2_Groups_partial_update"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/scim/v2/Me": {
    /**
     * Resource that points to the user represented by the underlying token
     * @description The endpoint will return the exact location of the user represented
     * by the token.
     */
    get: operations["scim_v2_Me_list"];
  };
  "/scim/v2/ResourceTypes": {
    /** @description Generate the resource types exposed by this endpoint */
    get: operations["scim_v2_ResourceTypes_list"];
  };
  "/scim/v2/ResourceTypes/{id}": {
    /** @description Generate the resource types exposed by this endpoint */
    get: operations["scim_v2_ResourceTypes_read"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/scim/v2/Schemas": {
    /** @description The schemas endpoint that returns to the IdP the schemas we know about */
    get: operations["scim_v2_Schemas_list"];
  };
  "/scim/v2/Schemas/{id}": {
    /** @description The schemas endpoint that returns to the IdP the schemas we know about */
    get: operations["scim_v2_Schemas_read"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
  "/scim/v2/ServiceProviderConfig": {
    /**
     * Generate the Service Provider configuration
     * @description This endpoint is called by the IdP for figuring out how our
     * API is going to behave.
     */
    get: operations["scim_v2_ServiceProviderConfig_list"];
  };
  "/scim/v2/Users": {
    get: operations["scim_v2_Users_list"];
    /** @description Create a new user from the given SCIM blob. */
    post: operations["scim_v2_Users_create"];
  };
  "/scim/v2/Users/.search": {
    post: operations["scim_v2_Users_search"];
  };
  "/scim/v2/Users/{id}": {
    /** @description Retrieve the underlying object */
    get: operations["scim_v2_Users_read"];
    /** @description Update the underlying object with the values received from the IdP */
    put: operations["scim_v2_Users_update"];
    /** @description Implement PATCH support for the underlying resource */
    patch: operations["scim_v2_Users_partial_update"];
    parameters: {
      path: {
        id: string;
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    Events: {
      /** Id */
      id: number;
      /**
       * Service
       * @description Name of the service that emitted the event
       */
      service?: string | null;
      /**
       * Actor
       * @description Entity that caused the event to happen
       */
      actor?: string | null;
      /**
       * Actor representation
       * @description Human-readable string representation of the actor at the time the event occurred
       */
      actor_representation?: string | null;
      /**
       * Actor group
       * @description Group that the actor belonged to when the event's action is initiated, e.g, an account_id
       */
      actor_group?: string | null;
      /**
       * Actor group representation
       * @description Human-readable string representation of the actor group at the time the event occurred
       */
      actor_group_representation?: string | null;
      /**
       * Action
       * @description Action that was performed in the event
       * @enum {string}
       */
      action: "auth.stale" | "user.provisioned" | "user.deprovisioned" | "team.provisioned" | "team.deprovisioned" | "team_member.provisioned" | "team_member.deprovisioned" | "zap.created" | "zap.disabled" | "zap.discarded" | "zap.owner_changed" | "zap.restored" | "zap.version_enabled" | "zap.version_published" | "zap.switched_on" | "zap.switched_off" | "zap.deleted" | "account.feature_enroll" | "account.feature_unenroll" | "zap.approval_request_approved" | "zap.approval_request_cancelled" | "zap.approval_request_denied" | "zap.approval_request_sent";
      /**
       * Direct object
       * @description Object that was directly manipulated or involved in the event's action
       */
      direct_object: string;
      /**
       * Direct object type
       * @description Type of the object that's directly involved in the event's action
       */
      direct_object_type?: string | null;
      /**
       * Direct object representation
       * @description Human-readable string representation of the object that initiated the action in the event
       */
      direct_object_representation?: string | null;
      /**
       * Indirect object
       * @description Object that is indirectly related to the event. This object won't be initiating the action in the event, but could be on the receiving end
       */
      indirect_object?: string | null;
      /**
       * Indirect object type
       * @description Data type of the indirect object that is related to the event that occurred
       */
      indirect_object_type?: string | null;
      /**
       * Indirect object representation
       * @description Human-readable string representation of the indirect object at the time the event happened
       */
      indirect_object_representation?: string | null;
      /**
       * Event date
       * Format: date-time
       * @description Datetime when the event happened
       */
      event_date: string;
      /**
       * Description
       * @description Description of the event
       */
      description?: string | null;
      /**
       * Event data
       * @description Data involved in the event
       */
      event_data?: Record<string, unknown> | null;
    };
    EventsListResponse: {
      /** Offset */
      offset?: number;
      /** Limit */
      limit?: number;
      /** Count */
      count: number;
      objects: components["schemas"]["Events"][];
    };
    ErrorDetails: {
      /** Field */
      field?: string;
      /** Message */
      message: string;
      /** Details */
      details?: {
        [key: string]: string | null;
      };
    };
    ZapHistoryError: {
      /** Status */
      status: number;
      /** type */
      _type: string;
      _errors: components["schemas"]["ErrorDetails"][];
    };
    SendEmailResponse: {
      /**
       * Task id
       * @description The celery task ID, or None if the task was sent.
       */
      task_id?: string;
    };
    ProjectsPartial: {
      /** Title */
      title: string;
      /**
       * Id
       * Format: uuid
       */
      id?: string;
      /** Owner id */
      owner_id: number;
    };
    AssetFetch: {
      project?: components["schemas"]["ProjectsPartial"];
      /** Asset type */
      asset_type: string;
      /** Asset id */
      asset_id: string;
    };
    AppAccessControlStrategy: {
      /** ID */
      id?: number;
      /**
       * Strategy
       * @enum {string}
       */
      strategy?: "allowlist" | "denylist";
      /** Account id */
      account_id?: number;
    };
    ProjectsList: {
      /**
       * Id
       * Format: uuid
       */
      id?: string;
      /** Title */
      title?: string;
      /** Description */
      description?: string;
      /** Owner id */
      owner_id?: number;
      /** Account id */
      account_id?: number;
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
      /**
       * Updated at
       * Format: date-time
       */
      updated_at?: string;
    };
    Projects: {
      /**
       * Id
       * Format: uuid
       */
      id?: string;
      /** Title */
      title: string;
      /**
       * Description
       * @default
       */
      description?: string;
      /** Owner id */
      owner_id?: number;
      /** Account id */
      account_id?: number;
    };
    ProjectsUpdateRequest: {
      /** Title */
      title?: string;
      /** Description */
      description?: string;
    };
    ShareAndUnshareRequest: {
      /** Subject id */
      subject_id: number;
      /**
       * Subject type
       * @enum {string}
       */
      subject_type: "team" | "user" | "account";
      /**
       * Subject type group
       * @enum {string}
       */
      subject_type_group?: "member";
      /**
       * Role
       * @enum {string}
       */
      role: "editor";
    };
    ProjectAsset: {
      /**
       * Asset type
       * @enum {string}
       */
      asset_type: "zap" | "canvas" | "interface" | "table" | "chatbot";
      /** Asset id */
      asset_id: string;
      /** Asset identifier */
      asset_identifier?: string;
    };
    ZapSearch: {
      /** Id */
      id?: string;
      /**
       * Zap id
       * Format: uuid
       */
      zap_id: string;
      /** Title */
      title: string;
      apps: string[];
      authentications: number[];
      /**
       * Updated at
       * Format: date-time
       */
      updated_at?: string;
      /** Search rank */
      search_rank?: string;
    };
    AccountAccessPolicy: {
      /** ID */
      id?: number;
      /**
       * Account
       * @description Account for which this access policy is to be enforced.
       */
      account: number;
      /**
       * Access level
       * @description Chosen access level for the associated account.
       * @enum {string}
       */
      access_level?: "auto_join" | "invite_only";
      /**
       * Verify emails
       * @description Should email confirmation be enforced for joining members?
       */
      verify_emails?: boolean;
    };
    BillingAccount: {
      access_policy?: components["schemas"]["AccountAccessPolicy"];
      /** Allow data retention config */
      allow_data_retention_config?: string;
      /** Allow task replay */
      allow_task_replay?: string;
      /** Autoreplay errored tasks override */
      autoreplay_errored_tasks_override?: string;
      /** Block and release */
      block_and_release?: string;
      /** Companies trial end date */
      companies_trial_end_date?: string;
      /** Companies trial start date */
      companies_trial_start_date?: string;
      /**
       * Company account end date
       * Format: date-time
       * @description Marks the date when the company account ended.
       */
      company_account_end_date?: string | null;
      /** Company address */
      company_address?: string;
      /** Company name */
      company_name?: string;
      /** Currency */
      currency?: string;
      /** Customer id */
      customer_id?: string | null;
      /** Data retention days */
      data_retention_days?: number;
      disallowed_payment_methods?: readonly (string | null)[];
      /** Enabled trial extensions */
      enabled_trial_extensions?: Record<string, never>;
      /** Enterprise account end date */
      enterprise_account_end_date?: string;
      /** Enterprise trial end date */
      enterprise_trial_end_date?: string;
      /** Enterprise trial start date */
      enterprise_trial_start_date?: string;
      /** Has been in enterprise trial */
      has_been_in_enterprise_trial?: string;
      /** First known upgrade date */
      first_known_upgrade_date?: string;
      /**
       * Has been in companies trial
       * @description Used to mark accounts that have been in a Companies trial, so they can't do repeat runs
       */
      has_been_in_companies_trial?: boolean | null;
      /** Has modern pricing plan */
      has_modern_pricing_plan?: boolean;
      /**
       * Icon
       * Format: uri
       */
      icon?: string;
      /** ID */
      id?: number;
      /** Invoice email */
      invoice_email?: string;
      /** Is chat eligible */
      is_chat_eligible?: boolean;
      /** Is company account */
      is_company_account?: boolean;
      /** Is controlled by identity provider */
      is_controlled_by_identity_provider?: string;
      /** Is google domain verification supported */
      is_google_domain_verification_supported?: string;
      /** Is in experts mvp */
      is_in_experts_mvp?: string;
      /** Is premier chat eligible */
      is_premier_chat_eligible?: boolean;
      /** Is saml required */
      is_saml_required?: string;
      /** Is team account */
      is_team_account?: boolean;
      /** Is trialing companies */
      is_trialing_companies?: string;
      /** Is trialing enterprise */
      is_trialing_enterprise?: string;
      /** Is trialing teams */
      is_trialing_teams?: string;
      /** Is trialing */
      is_trialing?: string;
      /** Is unlimited */
      is_unlimited?: string;
      /** Last charge fail */
      last_charge_fail?: string;
      /** Last plan change at */
      last_plan_change_at?: string;
      /** Last plan id */
      last_plan_id?: string;
      /** Logo choice */
      logo_choice?: string | null;
      /** Logo url */
      logo_url?: string;
      /** Name */
      name?: string;
      /** Offer returning trial extension */
      offer_returning_trial_extension?: boolean;
      /** Owner */
      owner?: string;
      /** Paid manually for next period */
      paid_manually_for_next_period?: string;
      /** Paying */
      paying?: string;
      /** Pays manually */
      pays_manually?: string;
      /** Period end */
      period_end?: string;
      /** Period start */
      period_start?: string;
      /** Plan group id */
      plan_group_id?: number;
      /** Plan info */
      plan_info?: string;
      /** Polling interval */
      polling_interval?: string;
      /** Send invoice email */
      send_invoice_email?: string;
      /** Surveys submitted */
      surveys_submitted?: string;
      /** Switches */
      switches?: string;
      /** Team account end date */
      team_account_end_date?: string;
      /** Teams trial end date */
      teams_trial_end_date?: string;
      /** Trial auto upgrade */
      trial_auto_upgrade?: boolean | null;
      /** Trial end date */
      trial_end_date?: string;
      /** Active offer id */
      active_offer_id?: number | null;
      /** Pending offer id */
      pending_offer_id?: number;
      /** Promotion plan group id */
      promotion_plan_group_id?: number | null;
      /**
       * Task buffer override
       * Format: decimal
       * @description Buffer multiplier for task usage limit in a billing period
       */
      task_buffer_override?: string | null;
      /**
       * Teams trial auto upgrade
       * @description Automatically upgrade to Teams once a teams trial is over
       */
      teams_trial_auto_upgrade?: boolean;
      /**
       * Companies trial auto upgrade
       * @description Automatically upgrade to Companies once a companies trial is over
       */
      companies_trial_auto_upgrade?: boolean | null;
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
      /** Has overdue invoice */
      has_overdue_invoice?: string;
      /** Subscription renewal date */
      subscription_renewal_date?: string;
      /** Metered pricing opt in info */
      metered_pricing_opt_in_info?: string;
      /** Has annual task limit */
      has_annual_task_limit?: string;
      /** Is eligible for faster polling interval */
      is_eligible_for_faster_polling_interval?: boolean;
    };
    AppAccessControl: {
      /** ID */
      id?: number;
      /** Selected api */
      selected_api?: string;
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
      /** Account */
      account?: number;
      /** Is app private */
      is_app_private?: string;
      /** Is restricted */
      is_restricted?: string;
      /** Human readable */
      human_readable?: string;
      /**
       * Applies to all
       * @description If the controlled app applies to all account members or not
       */
      applies_to_all?: boolean;
      /** Groups */
      groups?: string;
      /** Members */
      members?: string;
      /** Slug */
      slug?: string;
      /** App image */
      app_image?: string;
      /** App images */
      app_images?: string;
      /**
       * Status
       * @default denied
       * @enum {string}
       */
      status?: "denied" | "allowed";
    };
    AppAccessControlMembership: {
      /** ID */
      id?: number;
      /** App id */
      app_id?: number;
    };
    AppAccessControlTeamMembership: {
      /** ID */
      id?: number;
      /** App id */
      app_id?: number;
    };
    DomainVerificationRequest: {
      /** ID */
      id?: number;
      /**
       * Code
       * @description Unique domain verification code.
       */
      code?: string | null;
      /**
       * Status
       * @enum {string}
       */
      status?: "E" | "V" | "P";
      /** Domain */
      domain: string;
      /**
       * Expiry
       * Format: date
       * @description Verification window expiry date.
       */
      expiry?: string | null;
      /**
       * Account
       * @description Account that initiated the domain verification attempt
       */
      account?: number;
      /** Domain name */
      domain_name?: string;
      /**
       * Updated at
       * Format: date-time
       * @description Verification update timestamp.
       */
      updated_at?: string | null;
    };
    OrganizationDomain: {
      /**
       * Account
       * @description Account that administers this domain
       */
      account?: number | null;
      /** Domain */
      domain: string;
      /** Email provider */
      email_provider?: boolean;
      /** Enriched */
      enriched?: boolean;
      /** ID */
      id?: number;
      /**
       * Organization
       * @description Organization managing this domain
       */
      organization?: number | null;
      /** Ownership verified */
      ownership_verified?: boolean;
      verification_request?: components["schemas"]["DomainVerificationRequest"];
    };
    ExpertClientRelationship: {
      /** ID */
      id?: number;
      /**
       * Expert email
       * Format: email
       */
      expert_email: string;
      /**
       * State
       * @enum {string}
       */
      state?: "active" | "client_accepted" | "disabled" | "expert_initiated";
      /** Client account id */
      client_account_id?: string;
      /** Client customuser id */
      client_customuser_id?: string;
      /** Expert customuser id */
      expert_customuser_id?: string;
    };
    AccountFeatureEnrollment: {
      /** ID */
      id?: number;
      /** Account id */
      account_id?: string;
      /**
       * Feature name
       * @description Name of feature available to account
       * @enum {string}
       */
      feature_name?: "AUTO_UPGRADE";
      /**
       * Is enrolled
       * @description Specifies whether the user has enrolled in this feature.
       */
      is_enrolled?: boolean;
      /** Upgrade plan id */
      upgrade_plan_id?: number | null;
    };
    FolderMember: {
      /** ID */
      id?: number;
      /** Email */
      email?: string;
      /**
       * Photo url
       * @default /static/img/person.png
       */
      photo_url?: string;
      /** Full name */
      full_name?: string;
    };
    FolderGroup: {
      /** Id */
      id?: string;
      /** Name */
      name?: string;
      /**
       * Photo url
       * @default /static/img/team.png
       */
      photo_url?: string;
      /** Member count */
      member_count?: number;
      /** Group id */
      group_id: string;
    };
    Folder: {
      /** ID */
      id?: number;
      /** Title */
      title: string;
      /** Account id */
      account_id?: string;
      /** Is shared */
      is_shared?: boolean;
      owner?: components["schemas"]["FolderMember"];
      groups?: components["schemas"]["FolderGroup"];
      members?: components["schemas"]["FolderMember"];
      /** Parent id */
      parent_id?: string;
      /** Root id */
      root_id?: string;
      /** Zap count */
      zap_count?: number;
      /** Counts */
      counts?: string;
    };
    IdentityProvider: {
      /** ID */
      id?: number;
      /**
       * Mapping
       * @default {}
       */
      mapping?: {
        [key: string]: string | null;
      };
      /** Acs */
      acs?: string;
      /** Sp slo url */
      sp_slo_url?: string;
      /** Sp sso url */
      sp_sso_url?: string;
      /** Debug sso url */
      debug_sso_url?: string;
      /** Slo certificate */
      slo_certificate?: string;
      /**
       * Created at
       * Format: date-time
       * @description The time the IDP was created
       */
      created_at?: string;
      /**
       * Entity id
       * @description The entity identifier of this identity provider.
       */
      entity_id?: string | null;
      /**
       * Sso url
       * Format: uri
       * @description The SSO url for this identity provider
       */
      sso_url?: string | null;
      /**
       * Slo url
       * Format: uri
       * @description The SLO (single logout) url for this identity provider
       */
      slo_url?: string | null;
      /**
       * Certificate
       * @description The X509 certificate for this identity provider. The certificate is used for signing requests and decrypting payloads between the identity provider and the service provider.
       */
      certificate: string;
      /**
       * Identifier
       * Format: uuid
       * @description Distinct ID for accessing the IDP
       */
      identifier?: string;
      /**
       * Signed slo
       * @description Checked if the SLO needs to be signed
       */
      signed_slo?: boolean;
      /**
       * Slo sig alg
       * @description The signature algorithm for signed SLO requests
       * @enum {string}
       */
      slo_sig_alg?: "rsa_sha256" | "rsa_sha384" | "rsa_sha512";
      /**
       * Enabled
       * @description Enable the provider for all users of organization.
       */
      enabled?: boolean;
      /** Account */
      account: number;
    };
    Campaign: {
      /** ID */
      id?: number;
      /**
       * Name
       * @description Name of the campaign
       */
      name: string;
      /**
       * Max uses
       * @description DEPRECATED AND TO BE REMOVED. Use max_uses field in coupon_mapping
       */
      max_uses?: number;
      /**
       * Slug
       * Format: slug
       * @description Unique identifier for a campaign. Auto-generated from campaign name on initial save. Does not update on campaign name change after initial save/creation.
       */
      slug?: string | null;
    };
    CampaignPlan: ({
      /** ID */
      id?: number;
      /** Name */
      name: string;
      /**
       * Display short name
       * @description A short name used in web and email. e.g. "Company"
       */
      display_short_name?: string;
      /**
       * Interval
       * @description Cannot edit.
       * @enum {string}
       */
      interval?: "month" | "year";
      /**
       * Amount
       * @description Price in cents. Can be 0 for free. Cannot edit.
       */
      amount: number;
    }) | null;
    CampaignTrial: {
      /** ID */
      id?: number;
      /**
       * Name
       * @description Plan Type
       */
      name: string;
    } | null;
    CampaignPlanGroup: {
      /** ID */
      id?: number;
      /** Name */
      name: string;
    } | null;
    CampaignVariant: {
      /** ID */
      id?: number;
      /**
       * Name
       * @description Name of campaign variant
       */
      name: string;
      campaign?: components["schemas"]["Campaign"];
      destination_plan?: components["schemas"]["CampaignPlan"];
      destination_trial?: components["schemas"]["CampaignTrial"];
      promotion_plan_group?: components["schemas"]["CampaignPlanGroup"];
      /**
       * Terms
       * @description Campaign terms to be displayed to a user, if applicable. Currently only sent in notifier, needs to be setup in Iterable/email tool to be used in an offer email.
       */
      terms?: string | null;
      /**
       * Monthly cost
       * @description Holds the monthly inferred cost for this offer variant (in cents). For example 500. This is emitted only in the notifier (for email use).
       */
      monthly_cost?: number;
      /**
       * Total cost
       * @description Holds the total inferred cost for this offer variant (in cents). For example 1500. This is emitted only in the notifier (for email use).
       */
      total_cost?: number;
      /**
       * Is control
       * @description Used in experiments. When true, indicates that this variant is a control group.
       */
      is_control?: boolean;
    };
    CampaignOffer: {
      /** ID */
      id?: number;
      /** Account id */
      account_id?: string;
      variant?: components["schemas"]["CampaignVariant"];
      /**
       * Created at
       * Format: date-time
       * @description Date and time of offer creation.
       */
      created_at?: string;
      /**
       * Accepted at
       * Format: date-time
       * @description Date and time of offer acceptance.
       */
      accepted_at?: string | null;
      /**
       * Expiry
       * Format: date-time
       * @description Date and time of offer expiration. Defaults to now + Availability in days (in account's local time).
       */
      expiry?: string | null;
      /** Discount mapping */
      discount_mapping?: Record<string, unknown> | null;
      /** Target plan id */
      target_plan_id?: number | null;
    };
    Invitation: {
      /** ID */
      id?: number;
      /** Account */
      account?: number;
      /**
       * Code
       * Format: uuid
       */
      code?: string;
      teams?: number[];
      /**
       * Email
       * Format: email
       */
      email: string;
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
      /** Created by */
      created_by?: number;
      /**
       * Role
       * @default member
       * @enum {string}
       */
      role?: "super_admin" | "admin" | "member";
      /** Status */
      status?: string;
      /** Email hash */
      email_hash?: string;
      /**
       * Is access request
       * @description If the user requested access to join this account
       */
      is_access_request?: boolean;
    };
    FullAccountMember: {
      /** ID */
      id?: number;
      /** Full name */
      full_name: string;
      /**
       * Photo url
       * @default /static/img/person.png
       */
      photo_url?: string;
      /** Email */
      email: string;
      /**
       * Code
       * @description Get user's code for id
       */
      code?: string;
      /**
       * Role
       * @default member
       */
      role?: string;
      /** Email hash */
      email_hash?: string;
      /** Num zaps */
      num_zaps?: string;
      /** Num tasks */
      num_tasks?: string;
    };
    SlimTeamRead: {
      /** ID */
      id?: number;
      /**
       * Name
       * @description Name of the team
       */
      name: string;
      /**
       * Description
       * @description Team description
       */
      description?: string | null;
      /**
       * Logo
       * @default /static/img/team.png
       */
      logo?: string;
      /**
       * Logo choice
       * @description Logo selection
       */
      logo_choice?: string | null;
    };
    AccountProvision: {
      /** ID */
      id?: number;
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
      /** Account */
      account?: number;
      /** Enabled */
      enabled?: boolean;
      /** Token */
      token?: string;
      /** Schema */
      schema?: string;
      /** Scim base url */
      scim_base_url?: string;
    };
    Member: {
      /** ID */
      id?: number;
      /** Full name */
      full_name?: string;
      /**
       * Photo url
       * @default /static/img/person.png
       */
      photo_url?: string;
      /** Email */
      email?: string;
    };
    OptimizedMember: {
      /** ID */
      id?: number;
      /** Full name */
      full_name: string;
      /**
       * Photo url
       * @default /static/img/person.png
       */
      photo_url?: string;
      /** Email */
      email: string;
    };
    TeamRead: {
      /** ID */
      id?: number;
      /**
       * Name
       * @description Name of the team
       */
      name: string;
      owner?: components["schemas"]["Member"];
      /**
       * Description
       * @description Team description
       */
      description?: string | null;
      /**
       * Logo
       * @default /static/img/team.png
       */
      logo?: string;
      /** Member count */
      member_count?: string;
      member_preview?: readonly components["schemas"]["OptimizedMember"][];
      /**
       * Logo choice
       * @description Logo selection
       */
      logo_choice?: string | null;
    };
    TeamWrite: {
      /**
       * Owner
       * @description Creator of this team
       */
      owner?: number | null;
      /** New owner id */
      new_owner_id?: number;
      /**
       * Logo
       * Format: uri
       * @description Team icon
       */
      logo?: string | null;
      /**
       * Name
       * @description Name of the team
       */
      name: string;
      /**
       * Description
       * @description Team description
       */
      description?: string | null;
      /**
       * Logo choice
       * @description Logo selection
       */
      logo_choice?: string | null;
    };
    TeamMemberRead: {
      /** ID */
      id?: number;
      customuser?: components["schemas"]["Member"];
      /**
       * Is active
       * @default true
       */
      is_active?: boolean;
    };
    TeamMemberWrite: {
      /** ID */
      id?: number;
      /** Customuser */
      customuser: number;
      /**
       * Is active
       * @default true
       */
      is_active?: boolean;
    };
    TeamRequest: {
      /** ID */
      id?: number;
      customuser?: components["schemas"]["OptimizedMember"];
      /** Team */
      team: number;
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
      /**
       * Status
       * @enum {string}
       */
      status?: "pending" | "accepted" | "rejected";
    };
    TeamRequestWrite: {
      /** ID */
      id?: number;
      /** Customuser */
      customuser?: number;
      /** Team */
      team?: number;
      /**
       * Status
       * @enum {string}
       */
      status?: "accepted" | "rejected";
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
    };
    VirtualFolder: {
      /** Id */
      id: number;
      /** Name */
      name: string;
      /** Account id */
      account_id: number;
      /** Zap count */
      zap_count: number;
      /** Counts */
      counts: {
        [key: string]: string | null;
      };
    };
    AccountAppStatsResponse: {
      /** Selected api */
      selected_api: string;
      /** Auth count */
      auth_count: number;
      /** Member count */
      member_count: number;
      /** Zap count */
      zap_count: number;
    };
    Discount: {
      /** Id */
      id?: string;
      /** Coupon name */
      coupon_name?: string;
      /** Coupon type */
      coupon_type?: string;
    };
    AccountEntitlements: {
      /** Plan status */
      plan_status?: {
        [key: string]: string | null;
      };
      /** Limits */
      limits: {
        [key: string]: string | null;
      };
      /** Quotas */
      quotas?: {
        [key: string]: string | null;
      };
    };
    AccountPrivateAppsResponse: {
      /** Id */
      id?: number;
      /** Selected api */
      selected_api?: string;
      /** Title */
      title?: string;
      /** Images */
      images?: {
        [key: string]: string | null;
      };
      /** Has stale auth */
      has_stale_auth?: boolean;
      /** Banner */
      banner?: string;
    };
    AccountAppsResponse: {
      /** Id */
      id: number;
      /** Slug */
      slug: string;
      /** Selected api */
      selected_api: string;
      /** Title */
      title: string;
      /** Images */
      images?: {
        [key: string]: string | null;
      };
      /** Has stale auth */
      has_stale_auth?: boolean;
    };
    Plan: {
      /**
       * Zap length
       * @description Maximum steps in a zap - filters between nodes count as 1. -1 is unlimited.
       */
      zap_length?: number | null;
      /**
       * Apps
       * @description Number of apps at a time. -1 is unlimited.
       */
      apps?: number;
      /**
       * Actions
       * @description Number of writes per month. -1 is unlimited.
       */
      actions?: number;
      /**
       * Minimum number of seats
       * @description Minimum number of seats for per-seat pricing. For example, if "amount" is 1000 ($10) and "min seats" is 10, the minimum cost this plan would be 10000 ($100). Cannot edit.
       */
      min_seats?: number;
      /**
       * Throttle multiplier
       * @description How much extra headroom a plan gets.
       */
      throttle_multiplier?: number;
      /**
       * Enable metered task pricing?
       * @description Line items will be added to invoices based on how many tasks were used in the preceeding month, according to "metered task pricing tiers" (below). If enabled, you will probably want to set the "actions" limit to unlimited (-1). Cannot edit.
       */
      metered_task_pricing?: boolean;
      /**
       * Enable per-seat pricing?
       * @description Use per-seat pricing for this plan (see "minimum number of seats" also). Cannot edit.
       */
      per_seat_pricing?: boolean;
      /**
       * Metered task pricing tiers
       * @description Defines the pricing tiers for metered tasks, one per line: the max number of tasks in the tier, and the price per task in cents. Last tier must have a max of 'inf'. Cannot edit.
       */
      metered_pricing_tiers?: string;
      /**
       * Polling interval minutes
       * @description How often we poll in minutes. 0 is never.
       */
      polling_interval_minutes?: number;
      /**
       * Authentications
       * @description Number of authentications at a time. -1 is unlimited.
       */
      authentications?: number;
      /**
       * Maximum number of members allowed
       * @description Sets the upper limit on the number of team members that are allowed to belong to teams that are on this plan.
       */
      member_limit?: number | null;
      /**
       * Current default
       * @description There can only be a single default per plan group. We will clear out any dupes.
       */
      current_default?: boolean;
      /**
       * Allow premium apps?
       * @description Grant access to all premium apps, when enabled this overrides the "allowed_premium_apps" field below.
       */
      allow_premium_apps?: boolean;
      /**
       * Date
       * Format: date-time
       */
      date?: string;
      /**
       * Trial period days
       * @description None is no trial. Cannot edit.
       */
      trial_period_days?: number | null;
      /**
       * Zaps
       * @description Number of zaps at a time. -1 is unlimited.
       */
      zaps?: number;
      /** Name */
      name: string;
      /** Descriptive name */
      descriptive_name?: string;
      /** Short name */
      short_name?: string;
      /**
       * Interval
       * @description Cannot edit.
       * @enum {string}
       */
      interval?: "month" | "year";
      /**
       * Amount
       * @description Price in cents. Can be 0 for free. Cannot edit.
       */
      amount: number;
      /**
       * Can autoreplay errored tasks
       * @description Automatically rerun failed zaps (up to 5 times: ASAP, 30 minute delay, 1 hour delay, 3 hour delay, 6 hour delay). Enable to autoreplay tasks.
       */
      can_autoreplay_errored_tasks?: boolean;
      /**
       * Allow teams?
       * @description Allow adding additional members to account.
       */
      allow_teams?: boolean;
      /**
       * Lastchanged
       * Format: date-time
       */
      lastchanged?: string;
      /** ID */
      id?: number;
      /**
       * Has annual task limit
       * @description if true, this plan is an Annual Task Limit Plan
       */
      has_annual_task_limit?: boolean;
    };
    AccountPlanRecommendation: {
      monthly_plan?: components["schemas"]["Plan"];
      yearly_plan?: components["schemas"]["Plan"];
    };
    ThinService: {
      /** ID */
      id?: number;
      /** Image */
      image?: string;
      /** Name */
      name: string;
      /** Popularity */
      popularity: number;
      /** Service url */
      service_url: string;
      /**
       * Slug
       * @description You should **not** change this after it is public!
       */
      slug: string;
      /**
       * Url
       * Format: uri
       * @description URL for this service.
       */
      url?: string | null;
      /** Zap usage count */
      zap_usage_count?: string;
    };
    ThinGuidedRecipeService: {
      /** Id */
      id?: string;
      /** Name */
      name: string;
      /** Key */
      key?: string;
      /**
       * Slug
       * @description You should **not** change this after it is public!
       */
      slug: string;
    };
    ThinGuidedRecipe: {
      /** Id */
      id: string;
      /**
       * Slug
       * Format: slug
       */
      slug?: string | null;
      /**
       * Title
       * @description Title-cased. Titles are important. Mix the use case in with the functionality. Ex. "Get Notified of Important Emails in Slack"
       */
      title?: string | null;
      /** Status */
      status: string;
      /** Description html */
      description_html?: string;
      head_service: components["schemas"]["ThinGuidedRecipeService"];
      tail_service: components["schemas"]["ThinGuidedRecipeService"];
      /** Steps */
      steps: Record<string, never>;
      /** Url */
      url?: string;
      /** Used */
      used: number;
    };
    AccountModifySubscription: {
      /** Currency */
      currency?: string;
      /**
       * Invoiced at
       * Format: date-time
       */
      invoiced_at?: string;
      /** Payment intent id */
      payment_intent_id?: string;
      /** Plan id */
      plan_id?: number;
      addons?: (string | null)[];
    };
    TaskUsageAggregate: {
      /** Filtered */
      filtered?: number;
      /** Success */
      success?: number;
      /** Throttled */
      throttled?: number;
      /** Error */
      error?: number;
      /** Scheduled */
      scheduled?: number;
      /** Pending */
      pending?: number;
    };
    TaskUsageResponse: {
      /** Total tasks count */
      total_tasks_count: number;
      /**
       * Interval
       * @enum {string}
       */
      interval: "daily" | "monthly";
      status_aggregation: components["schemas"]["TaskUsageAggregate"];
      /** Tasks breakdown */
      tasks_breakdown: {
        [key: string]: components["schemas"]["TaskUsageAggregate"];
      };
    };
    AccountTopUser: {
      /** ID */
      id?: number;
      /** Email */
      email?: string;
      /** Full name */
      full_name?: string;
      /** Hours saved */
      hours_saved?: string;
      /** Live zaps */
      live_zaps?: string;
      /** Paused zaps */
      paused_zaps?: string;
      /**
       * Photo url
       * @default /static/img/person.png
       */
      photo_url?: string;
    };
    TopZapsTasks: {
      /** Billable */
      billable?: number;
      /** Delayed */
      delayed?: number;
      /** Error */
      error?: number;
      /** Filtered */
      filtered?: number;
      /** Halted */
      halted?: number;
      /** Pending */
      pending?: number;
      /** Scheduled */
      scheduled?: number;
      /** Skipped */
      skipped?: number;
      /** Success */
      success?: number;
      /** Throttled */
      throttled?: number;
    };
    TopZapsZaps: {
      /** Id */
      id: number;
      tasks: components["schemas"]["TopZapsTasks"];
      /**
       * Last run
       * Format: date-time
       */
      last_run: string;
    };
    TopZaps: {
      /** Count */
      count: number;
      objects: components["schemas"]["TopZapsZaps"][];
    };
    AccountTrialReport: {
      /** Tasks used */
      tasks_used?: number;
      /** Minutes saved */
      minutes_saved?: number;
      /** Estimated monthly tasks */
      estimated_monthly_tasks?: number;
    };
    AccountUsageLimit: {
      /** Action limit */
      action_limit: number;
      /** Zap limit */
      zap_limit: number;
    };
    AccountUsageZapMetrics: {
      /** Total tasks */
      total_tasks: number;
      /** Hours saved */
      hours_saved: number;
      /** Zap on count */
      zap_on_count: number;
      /** Zap off count */
      zap_off_count: number;
      /** Zap draft count */
      zap_draft_count: number;
      /** Zap total count */
      zap_total_count: number;
    };
    AccountUsage: {
      /** ID */
      id?: number;
      limit?: components["schemas"]["AccountUsageLimit"];
      /** Name */
      name?: string;
      /** Period start */
      period_start?: string;
      /** Period end */
      period_end?: string;
      /** Period reset */
      period_reset?: string;
      zap_metrics?: components["schemas"]["AccountUsageZapMetrics"];
    };
    /** @description Updates to the action's permissions at the account level */
    ActionControlsBase: {
      /**
       * Can use
       * @description Whether the action can be used.
       */
      can_use: boolean;
    };
    /** @description Updates to the action's permissions at the team level */
    TeamControlsBase: {
      /**
       * Can use
       * @description Whether the action can be used.
       */
      can_use: boolean;
      /**
       * Team id
       * @description The ID of the team to be controlled.
       */
      team_id: number;
    };
    /** @description Updates to the action's permissions at the customuser level */
    CustomuserControlsBase: {
      /**
       * Can use
       * @description Whether the action can be used.
       */
      can_use: boolean;
      /**
       * Customuser id
       * @description The ID of the customuser to be controlled.
       */
      customuser_id: number;
    };
    ActionControlsAction: {
      /**
       * Id
       * @description The ID of the action to be controlled.
       */
      id: string;
      account_controls?: components["schemas"]["ActionControlsBase"];
      team_controls?: components["schemas"]["TeamControlsBase"];
      customuser_controls?: components["schemas"]["CustomuserControlsBase"];
    };
    ActionControlsRequest: {
      /** @description A list of updates to action controls. */
      actions: components["schemas"]["ActionControlsAction"][];
    };
    ActionControlsResponse: {
      /**
       * Updated action count
       * @description The number of actions that were successfully updated.
       */
      updated_action_count: number;
    };
    /** @description An object containing references to the primary source of the error. */
    ErrorSource: {
      /**
       * Pointer
       * @description Pointer to the value in the request document that caused the error e.g. `/actions`.
       */
      pointer?: string;
      /**
       * Parameter
       * @description A string indicating which URI query parameter caused the error.
       */
      parameter?: string;
      /**
       * Header
       * @description A string indicating the name of a single request header which caused the error.
       */
      header?: string;
    } | null;
    ActionError: {
      /**
       * Status
       * @description The HTTP status code applicable to this problem.
       */
      status?: number;
      /**
       * Code
       * @description A unique identifier for this particular occurrence of the problem.
       */
      code?: string;
      /**
       * Error title
       * @description A short summary of the problem.
       */
      error_title?: string;
      /**
       * Detail
       * @description A human-readable explanation specific to this occurrence of the problem.
       */
      detail?: string;
      source?: components["schemas"]["ErrorSource"];
      /** Meta */
      meta?: ({
        [key: string]: string | null;
      }) | null;
    };
    ActionErrorResponse: {
      /** @description An array of error objects. */
      errors: components["schemas"]["ActionError"][];
    };
    ActionBaseResponse: {
      /** Detail */
      detail: string;
    };
    ImplementationMeta: Record<string, never>;
    service_category: {
      /** ID */
      id?: number;
      /** Title */
      title: string;
      /**
       * Slug
       * Format: slug
       */
      slug: string;
      /**
       * Description
       * @description Markdown enabled.
       */
      description?: string;
      /** Url */
      url?: string;
      /**
       * Type of
       * @description The type of the category. Curated categories are maintained by humans at Zapier, automatically generated are maintained by robots and populated in the management command rebuild_special_categories, and other are categories created manually for other purposes. If you want the category to show up on an apps individual profile page set this to curated, otherwise other is a good choice.
       */
      type_of?: string;
      /** Featured entry slug */
      featured_entry_slug?: string;
      /** Role */
      role?: string;
    };
    App: {
      /** Age in days */
      age_in_days?: string;
      /**
       * Api docs url
       * Format: uri
       * @description URL for the API's documentation.
       */
      api_docs_url?: string | null;
      /** App profile url */
      app_profile_url: string;
      /** Banner */
      banner?: string;
      categories?: readonly components["schemas"]["service_category"][];
      /**
       * Canonical id
       * Format: uuid
       */
      canonical_id?: string;
      /** Current implementation id */
      current_implementation_id: string;
      /** Days since last update */
      days_since_last_update?: string;
      /**
       * Description
       * @description Markdown enabled.
       */
      description: string;
      /** External url */
      external_url: string;
      /** Hashtag */
      hashtag?: string;
      /** ID */
      id?: number;
      /** Image */
      image?: string;
      /** Images */
      images?: string;
      /**
       * Integration overview html
       * @description Integration overview rendered as HTML.
       */
      integration_overview_html?: string | null;
      /** Internal id */
      internal_id: string;
      /**
       * Invite url
       * Format: uri
       * @description Signifies a pre-launch, "upcoming" invite only dev app page.
       */
      invite_url?: string | null;
      /** Is beta */
      is_beta?: string;
      /** Is built in */
      is_built_in?: string;
      /** Is featured */
      is_featured?: string;
      /**
       * Premium
       * @description Premium services are only available to paid customers.
       */
      is_premium?: boolean;
      /** Is public */
      is_public?: string;
      /** Is upcoming */
      is_upcoming?: string;
      /** Learn more url */
      learn_more_url: string;
      /** Name */
      name: string;
      /** Popularity */
      popularity: number;
      /** Primary color */
      primary_color: string;
      /** Request count */
      request_count?: string;
      /**
       * Slug
       * @description You should **not** change this after it is public!
       */
      slug: string;
      /**
       * Zap usage count
       * @description Steps + auths count that determines popularity/ordering.
       */
      zap_usage_count?: number | null;
    };
    PaginatedAppList: {
      /**
       * Prev
       * @description The previous page of App results
       */
      prev: string;
      /**
       * Next
       * @description The next page of App results
       */
      next: string;
      /**
       * Count
       * @description The total number of App results
       */
      count: number;
      results: components["schemas"]["App"][];
    };
    GuidedRecipeService: {
      /** Id */
      id?: string;
      /**
       * Canonical id
       * Format: uuid
       */
      canonical_id?: string;
      /** Current implementation id */
      current_implementation_id: string;
      /** Name */
      name: string;
      /**
       * Slug
       * @description You should **not** change this after it is public!
       */
      slug: string;
      /** Url */
      url?: string;
      /** Service url */
      service_url?: string;
      /** App url */
      app_url: string;
      /** Learn more url */
      learn_more_url: string;
      categories?: readonly components["schemas"]["service_category"][];
      /** Image */
      image?: string;
      /** Images */
      images?: string;
      /**
       * Description
       * @description Markdown enabled.
       */
      description: string;
      /** Banner */
      banner?: string;
      /** Age in days */
      age_in_days?: string;
      /** Days since last update */
      days_since_last_update?: string;
      /** Primary color */
      primary_color: string;
      /**
       * Premium
       * @description Premium services are only available to paid customers.
       */
      is_premium?: boolean;
      /** Is public */
      is_public?: string;
      /** Is built in */
      is_built_in?: string;
      /** Is beta */
      is_beta?: string;
      /** Is featured */
      is_featured?: string;
      /** Is upcoming */
      is_upcoming?: string;
      /** Is requested */
      is_requested?: string;
      /** Popularity */
      popularity: number;
      /**
       * Zap usage count
       * @description Steps + auths count that determines popularity/ordering.
       */
      zap_usage_count?: number | null;
      /**
       * Integration overview html
       * @description Integration overview rendered as HTML.
       */
      integration_overview_html?: string | null;
      /** Hashtag */
      hashtag?: string;
      /** Filters */
      filters?: string;
      /** Reads */
      reads?: string;
      /** Writes */
      writes?: string;
      /** Searches */
      searches?: string;
      /** Searches or writes */
      searches_or_writes?: string;
    };
    GuidedRecipe: {
      /** Id */
      id: string;
      /**
       * Canonical id
       * Format: uuid
       */
      canonical_id?: string;
      /** Url */
      url?: string;
      /** Guided recipe url */
      guided_recipe_url: string;
      /** Min url */
      min_url: string;
      /** Webintent url */
      webintent_url: string;
      /**
       * Slug
       * Format: slug
       */
      slug?: string | null;
      /**
       * Title
       * @description Title-cased. Titles are important. Mix the use case in with the functionality. Ex. "Get Notified of Important Emails in Slack"
       */
      title?: string | null;
      /** Description */
      description: string;
      /** Description html */
      description_html: string;
      /** Status */
      status: string;
      head_service: components["schemas"]["GuidedRecipeService"];
      tail_service: components["schemas"]["GuidedRecipeService"];
      /** Steps */
      steps: Record<string, never>;
      /** Rank */
      rank?: string;
      services: components["schemas"]["GuidedRecipeService"][];
      matched_services: components["schemas"]["GuidedRecipeService"][];
      /** Awesomeness */
      awesomeness: number;
      /** Activation */
      activation: number;
      /** Used */
      used: number;
      /** Template root node id */
      template_root_node_id: number;
      /** Link hash */
      link_hash: string;
      labels: (string | null)[];
      /**
       * Lastchanged
       * Format: date-time
       */
      lastchanged?: string;
    };
    DiscoverZapTemplates: {
      /**
       * Name
       * @description If persona, use plural. Use the triple store below to provide singular name.
       */
      name: string;
      /** ID */
      id?: number;
      /**
       * Date
       * Format: date-time
       */
      date?: string;
      /**
       * Lastchanged
       * Format: date-time
       */
      lastchanged?: string;
      /**
       * Excerpt
       * @description Zarkdown and Django template enabled. [Insecure! Trusted admins only.]
       */
      excerpt?: string | null;
      /**
       * Body
       * @description Zarkdown and Django template enabled. [Insecure! Trusted admins only.]
       */
      body?: string | null;
      zap_templates?: readonly components["schemas"]["GuidedRecipe"][];
    };
    Authentication: {
      /**
       * Date
       * Format: date-time
       */
      date?: string;
      /** Groups */
      groups?: string;
      /** ID */
      id?: number;
      /** Account id */
      account_id: number;
      /** Customuser id */
      customuser_id?: number;
      /**
       * Lastchanged
       * Format: date-time
       */
      lastchanged?: string;
      /** Is invite only */
      is_invite_only: boolean;
      /** Is private */
      is_private: boolean;
      /** Is stale */
      is_stale?: string;
      /**
       * Label
       * @description An app-provided aid to identify which account was connected here.
       */
      label?: string | null;
      /**
       * Marked stale at
       * Format: date-time
       */
      marked_stale_at?: string | null;
      /** Members */
      members?: string;
      /** Selected api */
      selected_api: string;
      /** Shared with all */
      shared_with_all: boolean;
      /**
       * Title
       * @description Useful if you have multiple accounts with the same service.
       */
      title?: string | null;
      /**
       * Url
       * Format: uri
       */
      url?: string;
      /**
       * Destination selected api
       * @description A special selected_api reference that helps us adhere to data flow restrictions (Gmail only now). You can read more at https://zapier.quip.com/ZKNWAR5wcA3z.
       */
      destination_selected_api?: string | null;
      /** Is shared */
      is_shared?: string;
      /**
       * Identifier
       * @description Similar to label but reserved for "trusted" and consistent reverse identities for an authentication. Think user_id or unique_email or username or something. Initially used for secondary auths
       */
      identifier?: string | null;
      /**
       * Permissions
       * @description
       * Explicitly signal what actions the requesting user can take
       * with the authentication returned (and thus what the front end
       * might show in the UI).
       */
      permissions?: {
        [key: string]: boolean;
      };
    };
    AuthCustomUserCountRequest: {
      customuser_ids: number[];
    };
    AuthCustomUserCountResponse: {
      results?: ({
          [key: string]: string | null;
        })[];
      errors?: ({
          [key: string]: string | null;
        })[];
    };
    AuthZapCountResponse: {
      /** Id */
      id?: number;
      /** Zap count */
      zap_count?: number;
    };
    SharedAuthenticationMember: {
      /** ID */
      id?: number;
      /** Authentication id */
      authentication_id?: number;
    };
    TeamAuthenticationMember: {
      /** ID */
      id?: number;
      /** Authentication id */
      authentication_id?: number;
    };
    AuthCallRequest: {
      /**
       * Type of
       * @enum {string}
       */
      type_of: "read" | "search" | "write";
      /** Action */
      action: string;
      /** Params */
      params?: Record<string, never>;
    };
    AuthCallResponse: {
      /** Success */
      success: boolean;
      results?: ({
          [key: string]: string | null;
        })[];
      errors?: string[];
    };
    Author: {
      /** ID */
      id?: number;
      /** Name */
      name: string;
      /** Image */
      image?: string;
      /** Email */
      email?: string;
      /** Biography */
      biography: string;
      /** Twitter username */
      twitter_username?: string;
    };
    BlogCategoryField: {
      /**
       * Date
       * Format: date-time
       */
      date?: string;
      /**
       * Lastchanged
       * Format: date-time
       */
      lastchanged?: string;
      /** Title */
      title: string;
      /**
       * Slug
       * Format: slug
       */
      slug: string;
      /**
       * Body
       * @description Plain text-only. Used for the blog index meta description and h2.
       */
      body: string;
      /** Html */
      html?: string;
    };
    Service: {
      /** ID */
      id?: number;
      /**
       * Canonical id
       * Format: uuid
       */
      canonical_id?: string;
      /** Current implementation id */
      current_implementation_id: string;
      /** Name */
      name: string;
      /**
       * Slug
       * @description You should **not** change this after it is public!
       */
      slug: string;
      /** Url */
      url?: string;
      /** Service url */
      service_url?: string;
      /** App url */
      app_url: string;
      /** Learn more url */
      learn_more_url: string;
      categories?: readonly components["schemas"]["service_category"][];
      /** Image */
      image?: string;
      /** Images */
      images?: string;
      /**
       * Description
       * @description Markdown enabled.
       */
      description: string;
      /** Banner */
      banner?: string;
      /** Age in days */
      age_in_days?: string;
      /** Days since last update */
      days_since_last_update?: string;
      /** Primary color */
      primary_color: string;
      /**
       * Premium
       * @description Premium services are only available to paid customers.
       */
      is_premium?: boolean;
      /** Is public */
      is_public?: string;
      /** Is built in */
      is_built_in?: string;
      /** Is beta */
      is_beta?: string;
      /** Is featured */
      is_featured?: string;
      /** Is upcoming */
      is_upcoming?: string;
      /** Is requested */
      is_requested?: string;
      /** Popularity */
      popularity: number;
      /**
       * Zap usage count
       * @description Steps + auths count that determines popularity/ordering.
       */
      zap_usage_count?: number | null;
      /**
       * Integration overview html
       * @description Integration overview rendered as HTML.
       */
      integration_overview_html?: string | null;
      /** Hashtag */
      hashtag?: string;
      /** Filters */
      filters?: string;
      /** Reads */
      reads?: string;
      /** Writes */
      writes?: string;
      /** Searches */
      searches?: string;
      /** Searches or writes */
      searches_or_writes?: string;
    };
    BlogPost: {
      author: components["schemas"]["Author"];
      canonical_category?: components["schemas"]["BlogCategoryField"];
      categories?: readonly components["schemas"]["BlogCategoryField"][];
      /** Sharing tags */
      sharing_tags: string;
      /** ID */
      id?: number;
      /**
       * Date
       * Format: date-time
       */
      date?: string;
      /**
       * Published date
       * Format: date-time
       */
      published_date: string;
      /**
       * Last changed date
       * Format: date-time
       */
      last_changed_date: string;
      /**
       * Title
       * @description On-page title with H1 Heading
       */
      title: string;
      /**
       * Slug
       * Format: slug
       */
      slug: string;
      /** Image */
      image: string;
      /**
       * Seo title
       * @description Title displayed on SERP and browser window. Recommended length: 50-60 characters.
       */
      seo_title?: string | null;
      /**
       * Seo description
       * @description Short description displayed on SERP. Recommended length: 150-160 characters.
       */
      seo_description?: string | null;
      /**
       * Url
       * Format: uri
       */
      url?: string;
      /** Post url */
      post_url?: string;
      /** Html */
      html: string;
      /** Excerpt html */
      excerpt_html?: string;
      /** Excerpt text */
      excerpt_text?: string;
      /** Images */
      images?: string;
      services?: readonly components["schemas"]["Service"][];
      /**
       * Subtitle
       * @description If you use a subtitle, keep the title short or the design will break!
       */
      subtitle?: string | null;
      /** Read time minutes */
      read_time_minutes?: string;
      primary_service?: components["schemas"]["Service"];
      /** Status */
      status: string;
      /** Structured data */
      structured_data?: string;
    };
    Blog: {
      /**
       * Date
       * Format: date-time
       */
      date?: string;
      /**
       * Lastchanged
       * Format: date-time
       */
      lastchanged?: string;
      /** Title */
      title: string;
      /**
       * Slug
       * @description This will be the URL for the blog. Ex.: `engineering` will be accessible at zapier.com/engineering/
       * @enum {string}
       */
      slug: "blog" | "engineering" | "jobs" | "case-studies";
      /**
       * Description
       * @description Plain text-only. Used for the blog index meta description, h2, and RSS feeds.
       */
      description: string;
      /** Description html */
      description_html?: string;
      /** Absolute url */
      absolute_url: string;
      /**
       * Url
       * Format: uri
       */
      url?: string;
    };
    DataFlowCheckResponse: {
      /** @description Contains the list of dataflow violations if the dataflow is restricted, empty otherwise */
      violations?: string[];
      /**
       * Error
       * @description Errors occuring during validation
       */
      error?: string;
    };
    /** @description Information about the service that was having problems */
    OutageService: {
      /**
       * Id
       * @description The id of the affected service
       */
      id?: number;
      /**
       * Key
       * @description The selected_api of the affected service
       */
      key?: string;
      /**
       * Slug
       * @description The slug of the affected service
       */
      slug?: string;
      /**
       * Title
       * @description The human-friendly title of the affected service
       */
      title?: string;
      /**
       * Is healthy
       * @description Is the service currently healthy or not?
       */
      is_healthy?: boolean;
      /**
       * Status
       * @description The current status of the service
       */
      status?: string;
    };
    /** @description Information about an outage with the selected_api that might have been related to the error */
    Outage: ({
      /**
       * Id
       * @description The id of the outage
       */
      id?: number;
      /**
       * Statuspageio id
       * @description The id of the outage in statuspage.io
       */
      statuspageio_id?: string | null;
      /**
       * Name
       * @description The name of the outage
       */
      name: string;
      /**
       * Status
       * @description The status of the outage
       */
      status?: string;
      /**
       * Created at
       * @description When the outage was declared
       */
      created_at?: string;
      /**
       * Updated at
       * @description When the outage was most recently updated
       */
      updated_at?: string;
      /**
       * Message
       * @description A message about the current state of the outage
       */
      message: string;
      service?: components["schemas"]["OutageService"];
    }) | null;
    AlertEmailError: {
      /**
       * Count
       * @description The number of times the error has occurred
       */
      count: number;
      /**
       * Error text
       * @description Text summarizing the error to be included in the body of the email
       */
      error_text: string;
      /**
       * Error type
       * @default action
       * @enum {string}
       */
      error_type?: "action" | "trigger";
      /**
       * Selected api
       * @description The selected api of the error step
       */
      selected_api?: string | null;
      outage?: components["schemas"]["Outage"];
    };
    TriggerAlertEmailBody: {
      /**
       * Content tag
       * @description If provided this will be used as the value for a UTM tag specific to the content of the email
       */
      content_tag?: string | null;
      /** @description Errors to be included in the email body */
      errors: components["schemas"]["AlertEmailError"][];
      /**
       * Zap id
       * @description ID of the Zap that has experienced an error
       */
      zap_id: string;
      /**
       * Zap run id
       * Format: uuid
       * @description ID of the Zap run associated with the error(s)
       */
      zap_run_id?: string | null;
    };
    TriggerAlertEmailResponse: Record<string, never>;
    ErrorNotificationsErrorDetails: {
      /** Field */
      field?: string;
      /** Message */
      message: string;
      /** Details */
      details?: {
        [key: string]: string | null;
      };
    };
    ErrorNotificationsError: {
      /** Status */
      status: number;
      /** type */
      _type: string;
      _errors: components["schemas"]["ErrorNotificationsErrorDetails"][];
    };
    ZapVisibilityCheckResponse: {
      /**
       * Account id
       * @description The account_id the Zap belongs to
       */
      account_id: number;
      /**
       * Customuser id
       * @description The customuser the Zap is owned by
       */
      customuser_id: number;
      /**
       * Id
       * @description The id of the Zap
       */
      id: string;
    };
    FollowedApp: {
      /** ID */
      id?: number;
      /** Service id */
      service_id?: string;
      /** Service slug */
      service_slug: string;
      /** Service public */
      service_public: boolean;
      /** Service selected api */
      service_selected_api: string;
      /**
       * Is active
       * @description Does the user want to receive updates about this service?
       */
      is_active?: boolean;
      /** Sources */
      sources?: string;
      /**
       * Created
       * Format: date-time
       */
      created?: string;
    };
    Generic: {
      /** Type */
      type: string;
      /** Id */
      id: number;
      /** Category id */
      category_id: number;
      /**
       * Created at
       * Format: date-time
       */
      created_at: string;
      /**
       * Last updated
       * Format: date-time
       */
      last_updated: string;
      /** Published */
      published: boolean;
      /** Title */
      title: string;
      /**
       * Slug
       * Format: slug
       */
      slug: string;
      /** Canonical path */
      canonical_path: string;
      /** Description */
      description: string;
      /** Body ast */
      body_ast: string;
      /** links */
      _links: string;
    };
    Step: {
      /** ID */
      id?: number;
      /** Title */
      title?: string;
      /**
       * Slug
       * Format: slug
       */
      slug?: string | null;
      /** Body ast */
      body_ast: string;
      /**
       * Show number
       * @description Display a number next to this step in the list of steps
       */
      show_number?: boolean;
      /** links */
      _links: string;
    };
    Tutorial: {
      /** Type */
      type: string;
      /** ID */
      id?: number;
      /** Category id */
      category_id?: string;
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
      /**
       * Last updated
       * Format: date-time
       */
      last_updated?: string;
      /** Title */
      title?: string;
      /**
       * Slug
       * Format: slug
       */
      slug?: string | null;
      /** Canonical path */
      canonical_path?: string;
      /**
       * Description
       * @description Description for SEO and helpdocs search results.
       */
      description?: string;
      /** Introduction ast */
      introduction_ast: string;
      steps: components["schemas"]["Step"][];
      /** Conclusion ast */
      conclusion_ast: string;
      /** Published */
      published?: boolean;
      /** links */
      _links: string;
    };
    Video: {
      /** ID */
      id?: number;
      /**
       * Slug
       * Format: slug
       */
      slug?: string;
      /** Title */
      title?: string;
      /** Subtitle */
      subtitle?: string;
      /**
       * Url
       * Format: uri
       */
      url?: string;
      /**
       * Length
       * @description Video length in seconds.
       */
      length?: number;
      /**
       * Series
       * @enum {string}
       */
      series?: "Zapier University";
    };
    help_category: {
      /** ID */
      id?: number;
      /**
       * Slug
       * Format: slug
       */
      slug?: string;
      /** Canonical path */
      canonical_path?: string;
      /** Title */
      title?: string;
      /** Description */
      description?: string;
      video: components["schemas"]["Video"];
      /** Parent id */
      parent_id?: string;
    };
    FAQ: {
      /** Type */
      type: string;
      /** ID */
      id?: number;
      /** Category id */
      category_id?: string;
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
      /**
       * Last updated
       * Format: date-time
       */
      last_updated?: string;
      /** Question */
      question?: string;
      /**
       * Slug
       * Format: slug
       */
      slug?: string | null;
      /** Canonical path */
      canonical_path?: string;
      /**
       * Description
       * @description Description for SEO and helpdocs search results.
       */
      description?: string;
      /** Answer ast */
      answer_ast: string;
      /** Published */
      published?: boolean;
      /** links */
      _links: string;
    };
    Feedback: {
      /** ID */
      id?: number;
      /**
       * Rating
       * @enum {integer}
       */
      rating?: 1 | -1 | 0;
      /**
       * Negative reason
       * @enum {string|null}
       */
      negative_reason?: "difficult_to_understand" | "does_not_match_seen" | "does_not_solve_problem" | "other" | null;
      /** Created by */
      created_by?: number | null;
      /** Resolved */
      resolved?: boolean;
      /** Comment */
      comment?: string;
      /** Helpcontent */
      helpcontent: string;
      /**
       * Is internal
       * @description Was this rating created by an internal user?
       */
      is_internal?: boolean;
    };
    Reference: {
      /** Type */
      type: string;
      /** ID */
      id?: number;
      /** Category id */
      category_id?: string;
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
      /**
       * Last updated
       * Format: date-time
       */
      last_updated?: string;
      /** Title */
      title?: string;
      /**
       * Slug
       * Format: slug
       */
      slug?: string | null;
      /** Canonical path */
      canonical_path?: string;
      /**
       * Description
       * @description Description for SEO and helpdocs search results.
       */
      description?: string;
      /** Introduction ast */
      introduction_ast: string;
      /** Steps */
      steps?: string;
      /** Published */
      published?: boolean;
      /** links */
      _links: string;
    };
    Troubleshooting: {
      /** Type */
      type: string;
      /** ID */
      id?: number;
      /** Category id */
      category_id?: string;
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
      /**
       * Last updated
       * Format: date-time
       */
      last_updated?: string;
      /** Title */
      title?: string;
      /**
       * Slug
       * Format: slug
       */
      slug?: string | null;
      /** Canonical path */
      canonical_path?: string;
      /**
       * Description
       * @description Description for SEO and helpdocs search results.
       */
      description?: string;
      /** Introduction ast */
      introduction_ast: string;
      steps: components["schemas"]["Step"][];
      /** Conclusion ast */
      conclusion_ast: string;
      /** Published */
      published?: boolean;
      /** links */
      _links: string;
    };
    ImplementationMetaSearchResultsActions: {
      /**
       * Read
       * @description The count of non-hidden "read" type actions.
       * @default 0
       */
      read?: number;
      /**
       * Read bulk
       * @description The count of non-hidden "read_bulk" type actions.
       * @default 0
       */
      read_bulk?: number;
      /**
       * Write
       * @description The count of non-hidden "write" type actions.
       * @default 0
       */
      write?: number;
      /**
       * Search
       * @description The count of non-hidden "search" type actions.
       * @default 0
       */
      search?: number;
      /**
       * Search or write
       * @description The count of non-hidden "search_or_write" type actions.
       * @default 0
       */
      search_or_write?: number;
      /**
       * Search and write
       * @description The count of non-hidden "search_and_write" type actions.
       * @default 0
       */
      search_and_write?: number;
      /**
       * Filter
       * @description The count of non-hidden "filter" type actions.
       * @default 0
       */
      filter?: number;
    };
    ServiceCategories: {
      /**
       * Id
       * @description The ID of the category.
       */
      id: number;
      /**
       * Title
       * @description The title of the category.
       */
      title: string;
    };
    ImplementationMetaSearchResults: {
      /**
       * Id
       * @description The "selected_api" of the Implementation.
       */
      id: string;
      /**
       * Name
       * @description The "title" of the related Service (if one exists), else the "name" of the Implementation (if specified), else the "selected_api" of the Implementation.
       */
      name: string;
      /**
       * Banner
       * @description An additional tag to display the status of the Implementation. Examples: beta, by-invite, premium, upcoming, deprecated.
       */
      banner: string;
      /**
       * Image
       * @description The URL of the Implementation's logo icon/image.
       */
      image: string;
      /**
       * Version
       * @description The version of the Implementation.
       */
      version: string | null;
      /**
       * Visibility
       * @description Either "public" or "private".
       */
      visibility: string;
      actions: components["schemas"]["ImplementationMetaSearchResultsActions"];
      /**
       * Description
       * @description The "description" of the related Service (if one exists), else the "description" of the AppVersion (if this is one) or blank.
       */
      description: string;
      /**
       * Primary color
       * @description The "dashboard_large_bg_color" of the related Service (if one exists), else the "primary_color" of the AppVersion (if this is one) or blank.
       */
      primary_color: string;
      /**
       * Secondary color
       * @description The "dashboard_small_bg_color" of the related Service (if one exists), else the "secondary_color" of the AppVersion (if this is one) or blank.
       */
      secondary_color: string;
      /** @description A list of dictionary objects for all categories related to the implementation. */
      categories: components["schemas"]["ServiceCategories"][];
    };
    ImplementationMetaSearchResponse: {
      /**
       * Count
       * @description The number of search results that were found.
       * @default 0
       */
      count?: number;
      /** @description A list of objects each representing a search result match. */
      results: components["schemas"]["ImplementationMetaSearchResults"][];
    };
    ImplementationMetaSearchError: {
      /** Errors */
      errors?: Record<string, never>;
    };
    /**
     * @description A collection of URLs that are associated with the action.
     * @default {}
     */
    ActionLinks: {
      /**
       * Action url
       * Format: uri
       * @description A URL supplied by action's provider which links to the action within their system.
       */
      action_url?: string;
    };
    /**
     * @description A collection of flags that indicate the permissions granted to the caller with respect to the action.
     * @default {
     *   "can_use": true
     * }
     */
    ActionPermissions: {
      /**
       * Can use
       * @description Indicates whether the action is able to be used by the caller.
       * @default true
       */
      can_use?: boolean;
    };
    Action: {
      /** Id */
      id?: string;
      /**
       * Type
       * @enum {string}
       */
      type: "filter" | "read" | "read_bulk" | "run" | "search" | "search_and_write" | "search_or_write" | "write";
      /**
       * Key
       * @description Machine name for this action
       */
      key: string;
      /**
       * Name
       * @description Human-readable label for this action
       */
      name: string;
      /** Noun */
      noun?: string;
      /** Description */
      description: string;
      /** Description html */
      description_html?: string;
      /** Is important */
      is_important?: boolean;
      /** Is hidden */
      is_hidden?: boolean;
      /** Needs */
      needs?: string;
      /** Meta */
      meta?: string;
      /** Selected api */
      selected_api?: string;
      links?: components["schemas"]["ActionLinks"];
      permissions?: components["schemas"]["ActionPermissions"];
    };
    Implementation: {
      /** Selected api */
      selected_api: string;
      /** App id */
      app_id?: number;
      /** Auth type */
      auth_type?: string;
      /** Auth fields */
      auth_fields?: string;
      actions?: readonly components["schemas"]["Action"][];
      /** Is deprecated */
      is_deprecated?: boolean;
      /** Is private only */
      is_private_only?: boolean;
      /** Is invite only */
      is_invite_only?: boolean;
      /**
       * Is beta
       * @default false
       */
      is_beta?: boolean;
      /**
       * Is premium
       * @default false
       */
      is_premium?: boolean;
      /** Is hidden */
      is_hidden?: string;
      /** Name */
      name?: string;
      /** Slug */
      slug?: string;
      /** Images */
      images?: {
        [key: string]: string | null;
      };
      /** Primary color */
      primary_color?: string;
      /** Secondary color */
      secondary_color?: string;
      /** Current implementation */
      current_implementation?: string;
      /** Other implementations */
      other_implementations?: string;
    };
    NeedChoicesRequest: {
      /**
       * Selected api
       * @description Something like `SlackAPI` (for Python apps) or `SplitwiseCLIAPI@1.0.0` (for CLI apps). Non-public apps are fine as long as the authed user can access them.
       */
      selected_api?: string;
      /**
       * Authentication id
       * @description If the app needs auth, provide an `authentication_id` that has the `selected_api` of the app you want to run. Can be any auth visible to the user (including shared).
       */
      authentication_id?: number;
      /**
       * Params
       * @description Object that matches the input the node would normally get. Has all the same keys/types as the `needs` of the action.
       */
      params?: Record<string, never>;
      /**
       * Page
       * @default 0
       */
      page?: number;
      /**
       * Prefill
       * @description The prefill string to indicate what we're fetching choices for. Likely something like `spreadsheet.id.title`. Must be provided alongside `selected_api` if both `action_id` and `input_field_id` are not.
       */
      prefill?: string;
      /**
       * Action id
       * @description The id that will be used to lookup the Action for prefill lookup. If provided, `input_field_id` is required, else `prefill` must be provided.
       */
      action_id?: string;
      /**
       * Input field id
       * @description The id (key) of the input field (Need) that dynamic choices are being retrieved for. If provided, `action_id` is required, else `prefill` must be provided.
       */
      input_field_id?: string;
    };
    NeedChoices: {
      /** Key */
      key?: string;
      /** Label */
      label?: string;
      /** Sample */
      sample?: string;
      /** Value */
      value?: string;
    };
    /** @description This object contains pagination meta data specific to external actions and will only be present for Choice responses from external action providers. */
    NeedChoicesResponseMeta: {
      /**
       * Page
       * @description The current page of results being returned. Could be `null` in cases where the provider doesn't implement pagination, for example.
       */
      page?: string;
    };
    /** @description This object contains the URLs to call to retrieve the next and/or previous page of results (if any) It is specific to external actions, so it should be used if returned, otherwise a follow up request should be made using the `next_page` value in the request body. */
    NeedChoicesResponseLinks: {
      /**
       * Next
       * Format: uri
       * @description The URL of the next page of paginated results.
       */
      next?: string;
      /**
       * Prev
       * Format: uri
       * @description The URL of the previous page of paginated results.
       */
      prev?: string;
    };
    NeedChoicesResponse: {
      /**
       * Success
       * @description Check this first to see the success state. If true, there will be `choices` (which still could be empty), and a status code of 200. If false, there will be an array of `errors`.
       */
      success: boolean;
      /** @description Could be empty, but will return choices for the supplied field key */
      choices?: components["schemas"]["NeedChoices"][];
      /** Next page */
      next_page?: number;
      errors?: string[];
      meta?: components["schemas"]["NeedChoicesResponseMeta"];
      links?: components["schemas"]["NeedChoicesResponseLinks"];
    };
    GivesRequest: {
      /**
       * Selected api
       * @description Something like `SlackAPI` (for Python apps) or `SplitwiseCLIAPI@1.0.0` (for CLI apps). Non-public apps are fine as long as the authed user can access them.
       */
      selected_api: string;
      /**
       * Action
       * @description Such as `new_contact`.
       */
      action: string;
      /**
       * Type of
       * @enum {string}
       */
      type_of: "read_bulk" | "write" | "read" | "search_or_write" | "search" | "run" | "filter" | "search_and_write";
      /**
       * Authentication id
       * @description If the app needs auth, provide an `authentication_id` that has the `selected_api` of the app you want to run. Can be any auth visible to the user (including shared).
       */
      authentication_id?: number;
      /**
       * Params
       * @description Object that matches the input the node would normally get. Has all the same keys/types as the `needs` of the action.
       */
      params?: Record<string, never>;
      /**
       * System context
       * @description A dictionary of contextual values that will be included in logs and emitted events.
       */
      system_context?: {
        [key: string]: {
          [key: string]: string;
        };
      };
      /**
       * Read result
       * @description Sample read in place of a Nodes sample read to help construct gives
       */
      read_result?: Record<string, never>;
    };
    Give: {
      /** Key */
      key: string;
      /** Label */
      label?: string;
      /** Score */
      score?: number;
      /** Subscore */
      subscore?: number;
      /**
       * Type
       * @default string
       * @enum {string}
       */
      type?: "integer" | "string" | "text" | "datetime" | "boolean" | "file" | "decimal" | "copy" | "password" | "dict" | "code" | "filter" | "json";
      /** Zap meta sample */
      zap_meta_sample?: Record<string, never>;
      /**
       * Custom field
       * @default false
       */
      custom_field?: boolean;
      /** Important */
      important?: boolean;
      /** From search */
      from_search?: boolean;
    };
    GivesResponse: {
      /**
       * Success
       * @description Check this first to see the success state. If true, there will be `gives` (which still could be empty). If false, there will be an array of `errors`.
       */
      success: boolean;
      /** @description Could be empty, even if the gives were successfully gathered. */
      gives?: components["schemas"]["Give"][];
      errors?: string[];
    };
    InvokeRequest: {
      /**
       * Selected api
       * @description Something like `SlackAPI` (for Python apps) or `SplitwiseCLIAPI@1.0.0` (for CLI apps). Non-public apps are fine as long as the authed user can access them.
       */
      selected_api: string;
      /**
       * Action
       * @description Such as `new_contact`.
       */
      action: string;
      /**
       * Type of
       * @enum {string}
       */
      type_of: "read_bulk" | "write" | "read" | "search_or_write" | "search" | "run" | "filter" | "search_and_write";
      /**
       * Authentication id
       * @description If the app needs auth, provide an `authentication_id` that has the `selected_api` of the app you want to run. Can be any auth visible to the user (including shared).
       */
      authentication_id?: number;
      /**
       * Params
       * @description Object that matches the input the node would normally get. Has all the same keys/types as the `needs` of the action.
       * @default {}
       */
      params?: Record<string, never>;
      /**
       * System context
       * @description A dictionary of contextual values that will be included in logs and emitted events.
       */
      system_context?: {
        [key: string]: {
          [key: string]: string;
        };
      };
      /**
       * Raw params
       * @description Like params, this is the object matches the input but before the {{}} are rendered. Useful for some legacy apps like Web Builder that rely on `action_fields_raw` in the bundle.
       */
      raw_params?: Record<string, never>;
      /**
       * Previous output
       * @description An object that represents the previous steps' output. Useful for some legacy apps like Webhook, MongoDB, or AWS SNS which expect raw_data, or in Web Builder with trigger_data.
       */
      previous_output?: {
        [key: string]: string | null;
      };
      /**
       * Idempotency id
       * @description A client chosen string that identifies the specific invocation. If this endpoint sees the same idempotency ID twice within some reasonable window, it is expected to ignore the second invoke. The workflow engine uses this to encode some task routing information for the response event.
       */
      idempotency_id?: string;
      /**
       * Attempt id
       * Format: uuid
       * @description A UUID that identifies the broader execution of an invocation, a corollary to "attempt" IDs in the former runner. Intended to "connect" multiple invocations.
       */
      attempt_id?: string;
      /**
       * Execution id
       * Format: uuid
       * @description DEPRECATED: This field is being deprecated in favor of using the attempt id
       */
      execution_id?: string;
      /**
       * Zap id
       * @description A stringified int or UUID that identifies the Zap that is running this invocation.
       */
      zap_id?: string;
      /**
       * Timeout
       * @description While we endeavour to reliably run actions, after this number of seconds, you can safely assume that a retry / replay with new idempotency_id is needed, as we guarantee we will not **generate** a response for the prior idempotency_id past this time.
       */
      timeout?: number;
      /**
       * Page
       * @description Allow individual apps to fetch a particular page of results. Defaults to None, starts at 0. If you want to fetch dynamic drop downs, you will need to include this parameter.
       */
      page?: number;
      /**
       * Paging token
       * @description When using bulk read action types, this denotes the state of the paging behavior. Defaults to None, and is given in the InvokeResponse.
       */
      paging_token?: string;
      /**
       * Is sampling
       * @description Set to True to make a sampling request. Defaults to False.
       * @default false
       */
      is_sampling?: boolean;
      /**
       * Test poll
       * @description Allow individual apps to loosen the requirements on fetching samples. Defaults to false.
       * @default false
       */
      test_poll?: boolean;
      /**
       * Sync
       * @description **Deprecated flag** - Server will respond with 403 if set to true. Will be removed soon.
       * @default false
       */
      sync?: boolean;
      /**
       * Filter referenced output
       * @description An object that represents the key/values referenced in a filter step's filter_criteria. Only used by FilterAPI and BranchingAPI filter actions to send over the outputs being tested. Ignored for all other action types.
       */
      filter_referenced_output?: {
        [key: string]: string | null;
      };
      /**
       * Is bulk read
       * @description ('Set to True to make a bulk read (e.g. Transfer) request against any paginating read action.This can be a legacy Python/CLI bulk read action (type_of="bulk_read") with "paging_token", or it can be aregular Python/CLI/WB read action (type_of="read") that may or may not support pagination using either"meta.page" number or the CLI cursor store. Defaults to False.',)
       * @default false
       */
      is_bulk_read?: boolean;
      /**
       * Context id
       * @description Provide an identifier that will be included in related events. May be used to uniquely identify the result of this invocation.
       */
      context_id?: string;
      /**
       * @description List of destination apis to check against, each one should look like an instance of `selected_api`. If any of these does not exist the endpoint will 404
       * @default []
       */
      destination_selected_apis?: string[];
    };
    InvokeAsyncResponse: {
      /**
       * Rate limit max requests
       * @description Maximum number of requests before rate limit kicks in. Absent if selected_api does not define a limit
       */
      rate_limit_max_requests?: number;
      /**
       * Rate limit remaining requests
       * @description Number of remaining requests before rate limiting. Absent if selected_api does not define a limit
       */
      rate_limit_remaining_requests?: number;
      /**
       * Rate limit reset
       * @description If currently under rate limiting, marks the epoch when the period ends. Absent if no rate limiting currently applies.
       */
      rate_limit_reset?: number;
      /**
       * Response uuid
       * Format: uuid
       * @description (Deprecated name for invocation_id as it diverged from produced Events).
       */
      response_uuid?: string;
      /**
       * Invocation id
       * Format: uuid
       * @description The UUID a client can use to poll for async InvokeResults.
       */
      invocation_id?: string;
      /**
       * Success
       * @description Check this first to see if the invoke behaved as expected. If true there will either be an array of `results` if a synchronous call, or a `response_uuid` if asynchronous. If false, there will be an array of `errors`. This is distinct from the response status, which represents the action behavior.
       */
      success: boolean;
      errors?: string[];
    };
    InvokeResponse: {
      /**
       * Rate limit max requests
       * @description Maximum number of requests before rate limit kicks in. Absent if selected_api does not define a limit
       */
      rate_limit_max_requests?: number;
      /**
       * Rate limit remaining requests
       * @description Number of remaining requests before rate limiting. Absent if selected_api does not define a limit
       */
      rate_limit_remaining_requests?: number;
      /**
       * Rate limit reset
       * @description If currently under rate limiting, marks the epoch when the period ends. Absent if no rate limiting currently applies.
       */
      rate_limit_reset?: number;
      /**
       * Response uuid
       * Format: uuid
       * @description (Deprecated name for invocation_id as it diverged from produced Events).
       */
      response_uuid?: string;
      /**
       * Invocation id
       * Format: uuid
       * @description The UUID a client can use to poll for async InvokeResults.
       */
      invocation_id?: string;
      /**
       * Success
       * @description Check this first to see if the invoke behaved as expected. If true there will either be an array of `results` if a synchronous call, or a `response_uuid` if asynchronous. If false, there will be an array of `errors`. This is distinct from the response status, which represents the action behavior.
       */
      success: boolean;
      errors?: string[];
      /**
       * Status
       * @description The status of the action call itself, influenced by the partner action. IE: you could have a success=True (Zapier succeeded) and status=error (the partner raise an error).
       * @enum {string}
       */
      status?: "delayed" | "error" | "halted" | "filtered" | "success" | "digested";
      /** @description Could be empty, even if the action was successfully run. */
      results?: ({
          [key: string]: string | null;
        })[];
      /**
       * Paging token
       * @description When using bulk read action types, this denotes the state of the paging utilities. Pass it back into the invoke endpoint.
       */
      paging_token?: string;
      /**
       * Error type
       * @description Error type of the InvokeResult object, as defined in the avro schemas. Value must be a valid member of the InvokeFailure enum
       * @enum {string}
       */
      error_type?: "user" | "authentication" | "partner" | "system" | "throttled" | "system_throttled" | "hydration";
      /**
       * Throttle delay
       * @description ('When a partner throttled the invoke call, this value will hold the number of seconds to wait before retrying. Otherwise not present in the response.',)
       */
      throttle_delay?: number;
    };
    NeedsRequest: {
      /**
       * Selected api
       * @description Something like `SlackAPI` (for Python apps) or `SplitwiseCLIAPI@1.0.0` (for CLI apps). Non-public apps are fine as long as the authed user can access them.
       */
      selected_api: string;
      /**
       * Action
       * @description Such as `new_contact`.
       */
      action: string;
      /**
       * Type of
       * @enum {string}
       */
      type_of: "read_bulk" | "write" | "read" | "search_or_write" | "search" | "run" | "filter" | "search_and_write";
      /**
       * Authentication id
       * @description If the app needs auth, provide an `authentication_id` that has the `selected_api` of the app you want to run. Can be any auth visible to the user (including shared).
       */
      authentication_id?: number;
      /**
       * Params
       * @description Object that matches the input the node would normally get. Has all the same keys/types as the `needs` of the action.
       */
      params?: Record<string, never>;
      /**
       * System context
       * @description A dictionary of contextual values that will be included in logs and emitted events.
       */
      system_context?: {
        [key: string]: {
          [key: string]: string;
        };
      };
      /**
       * Invalidate cache
       * @description Needs can be cached, provide this flag to disable it at a potential performance hit.
       * @default false
       */
      invalidate_cache?: boolean;
    };
    Need: {
      /** Alters custom fields */
      alters_custom_fields?: boolean | null;
      /** @default [] */
      capabilities?: string[];
      choices?: components["schemas"]["NeedChoices"][];
      /**
       * Computed
       * @description This value is only returned if the `computed` key is explicitly defined in the integration's need.
       */
      computed?: boolean | null;
      /**
       * Custom field
       * @default false
       */
      custom_field?: boolean;
      /** Default */
      default?: string;
      /** @default [] */
      depends_on?: string[];
      /**
       * Format
       * @enum {string}
       */
      format?: "SELECT";
      /**
       * From search
       * @default false
       */
      from_search?: boolean;
      /**
       * From write
       * @default false
       */
      from_write?: boolean;
      /** Help text */
      help_text?: string;
      /** Help text html */
      help_text_html?: string;
      input_format?: string[];
      /** Key */
      key: string;
      /** Label */
      label?: string;
      /** Language */
      language?: string;
      /** Parent key */
      parent_key?: string;
      /** Placeholder */
      placeholder?: string;
      /** Prefill */
      prefill?: string;
      /**
       * Required
       * @default false
       */
      required?: boolean;
      /** Searchfill */
      searchfill?: string;
      /**
       * Send in json
       * @default true
       */
      send_in_json?: boolean;
      /** Regex */
      regex?: string;
      /**
       * Type
       * @default string
       * @enum {string}
       */
      type?: "integer" | "string" | "text" | "datetime" | "boolean" | "file" | "decimal" | "copy" | "password" | "dict" | "code" | "filter" | "json";
      /**
       * List
       * @default false
       */
      list?: boolean;
    };
    NeedsResponse: {
      /**
       * Success
       * @description Check this first to see the success state. If true, there will be `needs` (which still could be empty). If false, there will be an array of `errors`.
       */
      success: boolean;
      /** @description Could be empty, even if the needs were successfully gathered. */
      needs?: components["schemas"]["Need"][];
      errors?: string[];
      /**
       * Last fetched at
       * Format: date-time
       * @description A timestamp representing when needs were last fetched from partners.
       */
      last_fetched_at?: string;
    };
    InternalAccount: {
      /** ID */
      id?: number;
      /**
       * Name
       * @default Personal Account
       */
      name?: string;
      /**
       * Created at
       * Format: date-time
       */
      created_at: string;
      /** Is team account */
      is_team_account: boolean;
      /** Customer id */
      customer_id?: string | null;
      /** Is unlimited */
      is_unlimited?: string;
      /**
       * Unlimited until
       * Format: date-time
       */
      unlimited_until: string;
      /** Period start */
      period_start?: string;
      /** Period end */
      period_end?: string;
      /** Is trialing */
      is_trialing: boolean;
      /** Is trialing teams */
      is_trialing_teams: boolean;
      /** Is trialing companies */
      is_trialing_companies: boolean;
      /** Is trialing enterprise */
      is_trialing_enterprise: boolean;
      /**
       * Trial end date
       * Format: date-time
       * @description Behaves like "unlimited until" but shows a trial banner to the user and only works for users on a free plan.
       */
      trial_end_date?: string | null;
      /** Cannot reset trial */
      cannot_reset_trial?: string;
      /** Plan group */
      plan_group?: string;
      /** Plan */
      plan?: string;
      /** Is chat eligible */
      is_chat_eligible: boolean;
      /** Is premier chat eligible */
      is_premier_chat_eligible: boolean;
      /**
       * Team account end date
       * Format: date-time
       */
      team_account_end_date: string;
      /**
       * Company account end date
       * Format: date-time
       */
      company_account_end_date: string;
      /**
       * Enterprise account end date
       * Format: date-time
       */
      enterprise_account_end_date: string;
      /** Has modern pricing plan */
      has_modern_pricing_plan: boolean;
      /** links */
      _links?: string;
    };
    CustomUser: {
      /** ID */
      id?: number;
      /** Email */
      email?: string;
      /** Slack handle */
      slack_handle?: string;
      /** First name */
      first_name: string;
      /** Last name */
      last_name: string;
      /**
       * Date joined
       * Format: date-time
       */
      date_joined: string;
      /** Is developer */
      is_developer: boolean;
      /** Is expert */
      is_expert: boolean;
      /**
       * Alert triggers
       * @enum {string}
       */
      alert_triggers?: "never" | "repeated" | "always" | "only_trigger";
      /**
       * Alert actions
       * @enum {string}
       */
      alert_actions?: "never" | "repeated" | "always" | "only_trigger";
      /**
       * Timezone
       * @description A valid <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank">IANA TZ database name</a>.
       */
      timezone?: string | null;
      /** Aliases */
      aliases?: string;
      /** Account memberships */
      account_memberships?: string;
      /** links */
      _links?: string;
    };
    BillingExemptZapsRequest: {
      /** Is billing exempt */
      is_billing_exempt: boolean;
    };
    BillingExemptZapsResponse: Record<string, never>;
    InvitationAccount: {
      /** ID */
      id?: number;
      /** Name */
      name?: string;
      /**
       * Logo url
       * Format: uri
       */
      logo_url: string;
      /** Has saml sso */
      has_saml_sso?: string;
    };
    InvitationCode: {
      /** ID */
      id?: number;
      /**
       * Email
       * Format: email
       */
      email: string;
      /** Email found */
      email_found?: string;
      /**
       * Code
       * Format: uuid
       */
      code: string;
      /** Status */
      status: string;
      /** Sso url */
      sso_url?: string;
      account?: components["schemas"]["InvitationAccount"];
      created_by?: components["schemas"]["Member"];
    };
    JWTTokenExchangeRequest: {
      /** Customuser id */
      customuser_id: number;
      /** Account id */
      account_id: number;
    };
    JWTTokenExchangeResponse: {
      /** Account id */
      account_id: string;
      /** Jwt */
      jwt: string;
    };
    MasqueradeLinkRequest: {
      /**
       * Entity type
       * @enum {string}
       */
      entity_type: "customuser" | "fork" | "node" | "webapp" | "cli" | "email" | "visual_builder" | "template";
      /** Entity id */
      entity_id: string;
      /** Account context */
      account_context?: string;
      /** Next url */
      next_url?: string;
      /** Next url subdomain */
      next_url_subdomain?: string;
      /** Common note */
      common_note?: string;
      /** Note */
      note?: string;
      /** Zendesk ticket id */
      zendesk_ticket_id?: string;
      /** Intercom ticket id */
      intercom_ticket_id?: string;
    };
    MasqueradeLinkResponse: {
      /**
       * Url
       * Format: uri
       */
      url?: string;
      /** Next */
      next?: string;
      /** Next subdomain */
      next_subdomain?: string;
      /** Detail */
      detail?: string;
      /** Is staff */
      is_staff: boolean;
      /**
       * Customuser email
       * Format: email
       */
      customuser_email?: string;
    };
    NounStepConnection: {
      /** ID */
      id?: number;
      /** Selected api */
      selected_api: string;
      /**
       * Type of
       * @enum {string}
       */
      type_of: "read" | "search" | "write" | "search_or_write" | "filter";
      /** Action */
      action: string;
      /**
       * Needs mapping
       * @description
       * Map _from_ a Noun _to_ the APIs needs.
       *
       * JSON should be in the format of `{"fname": "{{@first_name}}"}`
       * where "fname" is the api's needs field key and "@first_name" is
       * the noun field key.
       *
       * This is generally used more for actions/writes. Custom fields
       * should not be used here.
       */
      needs_mapping?: string;
      /**
       * Gives mapping
       * @description
       * Map from an API's gives fields _to_ a Noun.
       *
       * JSON should be in the format of `{"@first_name": "{{Field1}}"}`
       * where "@first_name" is the noun field key and "Field1" is the
       * api's gives fields.
       *
       * This is generally more used for triggers/reads. Custom fields
       * should not be used here.
       */
      gives_mapping?: string;
      /** Noun slug */
      noun_slug?: string;
    };
    Noun: {
      /**
       * Slug
       * Format: slug
       */
      slug: string;
      /** Name */
      name: string;
      /** Description */
      description?: string | null;
      /**
       * Fields
       * @description
       * A dictionary of `{"@key": {"label": "Key"}}` that this noun
       * contains.
       *
       * Careful if you edit this, for example, removing/renaming a key can
       * break noun step connections!
       */
      fields?: string;
    };
    OAuthApplication: {
      /** Id */
      id?: number;
      /** Client id */
      client_id?: string;
      /** Name */
      name?: string;
      allowlist_domains: string[];
      redirect_uris: string[];
      /**
       * Authorization grant type
       * @enum {string}
       */
      authorization_grant_type?: "authorization-code" | "implicit" | "password" | "client-credentials";
    };
    OAuthApplicationExtended: {
      /** Id */
      id?: number;
      /** Client id */
      client_id?: string;
      /** Name */
      name?: string;
      allowlist_domains: string[];
      redirect_uris: string[];
      /**
       * Authorization grant type
       * @enum {string}
       */
      authorization_grant_type?: "authorization-code" | "implicit" | "password" | "client-credentials";
      /** Client secret */
      client_secret?: string;
    };
    OauthTokenExchangeRequest: {
      /** Oauth token */
      oauth_token: string;
      scopes: string[];
    };
    _JWT: {
      /** Account id */
      account_id: string;
      /** Jwt */
      jwt: string;
    };
    _Service: {
      /** Slug */
      slug: string;
      /** Selected api */
      selected_api?: string;
    };
    _OAuthApplication: {
      /** Client id */
      client_id: string;
      service?: components["schemas"]["_Service"];
    };
    OauthTokenExchangeResponse: {
      jwts: components["schemas"]["_JWT"][];
      oauth_application: components["schemas"]["_OAuthApplication"];
      /** Customuser id */
      customuser_id: number;
    };
    Onboarding: {
      /** ID */
      id?: number;
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
      /**
       * Status
       * @enum {string|null}
       */
      status?: "complete" | "skipped" | "started" | null;
      /**
       * Intent
       * @enum {string|null}
       */
      intent?: "general" | "specific" | "uncertain" | null;
      /** Intent detail */
      intent_detail?: string | null;
      /** Customuser */
      customuser: number;
    };
    PersistedModal: {
      /** Name */
      name: string;
      /** Modal data */
      modal_data?: Record<string, unknown> | null;
    };
    Policy: {
      /** Title */
      title: string;
      /**
       * Slug
       * Format: slug
       * @description A unique slug for the policy. If blank, autogenerated from the title of the policy.
       */
      slug: string;
      /**
       * Published at
       * Format: date-time
       */
      published_at: string;
      /**
       * Url
       * Format: uri
       */
      url?: string;
    };
    PendingPolicy: {
      /** Title */
      title: string;
      /**
       * Slug
       * Format: slug
       * @description A unique slug for the policy. If blank, autogenerated from the title of the policy.
       */
      slug: string;
      /** Content */
      content: number;
      /** Tldr */
      tldr: string;
      /**
       * Published at
       * Format: date-time
       */
      published_at: string;
      /**
       * Url
       * Format: uri
       */
      url?: string;
    };
    Agreement: {
      /** User */
      user: number;
      /** Policy content */
      policy_content: number;
      /**
       * Agreed at
       * Format: date-time
       */
      agreed_at?: string;
    };
    PolicyContent: {
      /** Title */
      title: string;
      /**
       * Slug
       * Format: slug
       * @description A unique slug for the policy. If blank, autogenerated from the title of the policy.
       */
      slug: string;
      /** Tldr */
      tldr: string;
      /** Content */
      content: number;
      /** Body */
      body: string;
      /**
       * Published at
       * Format: date-time
       */
      published_at: string;
    };
    PressPageArticle: {
      /**
       * Url
       * Format: uri
       */
      url?: string;
      /**
       * Date published
       * Format: date-time
       * @description The date the article was published.
       */
      date_published: string;
      /**
       * Read time
       * @description Estimated time to read the article, in seconds. Will be shown in MM:SS format, ex. 90 seconds will show as 1:30.
       */
      read_time: number;
      /**
       * Read time in minutes
       * @description The read_time field in minutes, in the format MM:SS
       */
      read_time_minutes: string;
      /**
       * Article title
       * @description Press page title.
       */
      article_title: string;
      /**
       * Article excerpt
       * @description Press page excerpt, appears below title.
       */
      article_excerpt: string;
      /**
       * Article url
       * @description The link to the article.
       */
      article_url: string;
      /**
       * Article author
       * @description The author of the article (optional).
       */
      article_author?: string;
      /**
       * Article publisher
       * @description The publisher of the article (optional). If not specified, the domain from the article_url will be used instead.
       */
      article_publisher?: string;
      /**
       * Is public
       * @description Indicates whether we should show the article on the press page.
       */
      is_public?: boolean;
      /**
       * Headline image url
       * @description Link the optimized image URL.
       */
      headline_image_url?: string;
      /** ID */
      id?: number;
      /**
       * Order
       * @description The ascending order of the press page articles.
       */
      order?: number;
    };
    CompanySize: {
      /** ID */
      id?: number;
      /** Display range */
      display_range?: string;
      /** Is active */
      is_active?: boolean;
    };
    Role: {
      /** ID */
      id?: number;
      /**
       * Canonical id
       * Format: uuid
       */
      canonical_id?: string;
      /** Name */
      name: string;
      /**
       * Slug
       * Format: slug
       */
      slug?: string | null;
    };
    /** @description The links object returned in paginated response bodies. */
    Links: {
      /**
       * Next
       * @description The URL of the next page of paginated results.
       */
      next?: string | null;
      /**
       * Prev
       * @description The URL of the previous page of paginated results.
       */
      prev?: string | null;
    };
    /** @description The meta object returned in paginated response bodies. */
    Meta: {
      /**
       * Count
       * @description The total number of objects in the collection represented by the endpoint.
       */
      count: number;
      /**
       * Limit
       * @description The limit value used in the request.
       */
      limit: number;
      /**
       * Offset
       * @description The offset value used in the request.
       */
      offset: number;
    };
    ExternalAction: {
      /** Id */
      id: string;
      /** Key */
      key: string;
      /** Provider */
      provider: string;
      /** Provider id */
      provider_id: string;
      /** Selected api */
      selected_api: string;
      /** Type */
      type: string;
      /** Name */
      name: string;
      /** Description */
      description: string;
      /** Scope */
      scope: string;
      /** Owner */
      owner: number | null;
      customusers: number[];
      accounts: number[];
      /**
       * Status
       * @enum {string}
       */
      status: "public" | "private";
      /** Tag */
      tag: string;
    };
    ActionListResponse: {
      links: components["schemas"]["Links"];
      meta: components["schemas"]["Meta"];
      /** @description The data field returning a list of actions */
      actions: components["schemas"]["ExternalAction"][];
    };
    ActionCreate: {
      /**
       * Provider
       * @description The provider of the action.
       * @enum {string}
       */
      provider: "ae" | "bin";
      /**
       * Provider id
       * @description The backlink (i.e. the id of the action in the provider's system).
       */
      provider_id: string;
      /**
       * Selected api
       * @description The selected API of the action.
       */
      selected_api: string;
      /**
       * Type
       * @description The type of the action.
       */
      type: string;
      /**
       * Name
       * @description The name of the action.
       */
      name: string;
      /**
       * Description
       * @description The description of the action.
       */
      description?: string;
      /**
       * Scope
       * @description The scope of the action.
       */
      scope?: string;
      /**
       * Owner
       * @description The customuser ID of the action's owner.
       */
      owner?: number;
      /** @description A list of customuser IDs that can use the action. */
      customusers?: number[];
      /** @description A list of account IDs that can use the action. */
      accounts?: readonly number[];
      /**
       * Status
       * @description The status of the action (always private initially).
       * @enum {string}
       */
      status?: "public" | "private";
      /**
       * Tag
       * @description An immutable value that must be unique across versions of an action. This field will become required in the future, so action providers should specify it when creating action versions.
       * @default prod
       */
      tag?: string;
    };
    ActionCreateOrUpdateResponse: {
      /**
       * Provider
       * @description The provider of the action.
       * @enum {string}
       */
      provider: "ae" | "bin";
      /**
       * Provider id
       * @description The backlink (i.e. the id of the action in the provider's system).
       */
      provider_id: string;
      /**
       * Selected api
       * @description The selected API of the action.
       */
      selected_api: string;
      /**
       * Type
       * @description The type of the action.
       */
      type: string;
      /**
       * Name
       * @description The name of the action.
       */
      name: string;
      /**
       * Description
       * @description The description of the action.
       */
      description?: string;
      /**
       * Scope
       * @description The scope of the action.
       */
      scope?: string;
      /**
       * Owner
       * @description The customuser ID of the action's owner.
       */
      owner?: number;
      /** @description A list of customuser IDs that can use the action. */
      customusers?: number[];
      /** @description A list of account IDs that can use the action. */
      accounts?: readonly number[];
      /**
       * Status
       * @description The status of the action (always private initially).
       * @enum {string}
       */
      status?: "public" | "private";
      /**
       * Tag
       * @description An immutable value that must be unique across versions of an action. This field will become required in the future, so action providers should specify it when creating action versions.
       * @default prod
       */
      tag?: string;
      /**
       * Id
       * @description The ID of the action
       */
      id: string;
      /**
       * Key
       * @description The key of the action.
       */
      key: string;
    };
    ActionDetail: {
      /**
       * Name
       * @description The name of the action.
       */
      name?: string;
      /**
       * Description
       * @description The description of the action.
       */
      description?: string;
      /**
       * Scope
       * @description The scope of the action.
       */
      scope?: string;
      /** @description A list of custom user ids that have access to the action. */
      customusers?: readonly number[];
      /** @description A list of account ids that have access to the action. */
      accounts?: readonly number[];
      /**
       * Status
       * @description The status of the action. Use the 'publish' endpoint to change an action's status from private to public.
       * @enum {string}
       */
      status?: "public" | "private";
    };
    ActionDetailResponse: {
      /**
       * Name
       * @description The name of the action.
       */
      name?: string;
      /**
       * Description
       * @description The description of the action.
       */
      description?: string;
      /**
       * Scope
       * @description The scope of the action.
       */
      scope?: string;
      /** @description A list of custom user ids that have access to the action. */
      customusers?: readonly number[];
      /** @description A list of account ids that have access to the action. */
      accounts?: readonly number[];
      /**
       * Status
       * @description The status of the action. Use the 'publish' endpoint to change an action's status from private to public.
       * @enum {string}
       */
      status?: "public" | "private";
      /**
       * Key
       * @description The key of the action.
       */
      key: string;
    };
    ActionRoleAssignments: {
      /**
       * Id
       * @description The ID of the entity whose type is specified in `type`.
       */
      id: number;
      /**
       * Role
       * @description The role to assign the entity in relation to the action. Use `none` to remove the entity.
       * @enum {string}
       */
      role: "viewer" | "none";
      /**
       * Type
       * @description The type of entity the action is being shared with.
       * @enum {string}
       */
      type: "customuser" | "account";
    };
    ActionShareRequest: {
      /** @description A list of mappings denoting the role that each entity will be granted for the action. */
      role_assignments: components["schemas"]["ActionRoleAssignments"][];
    };
    Photo: {
      /** ID */
      id?: number;
      /** Url */
      url?: string;
      /** Filename */
      filename?: string;
      /** Title */
      title?: string | null;
      /**
       * Photo
       * Format: uri
       * @description Images are not modified. Upload images as close to the size you want to use them at as possible.
       */
      photo?: string;
    };
    ReviewPage: {
      /** ID */
      id?: number;
      /**
       * Date
       * Format: date-time
       */
      date?: string;
      /**
       * Seo title
       * @description Title displayed on SERP & browser window. Max length: 50-60 characters.
       */
      seo_title?: string | null;
      /**
       * Seo description
       * @description Short description displayed on SERP. Max length: 150-160 characters.
       */
      seo_description?: string | null;
      /** Review */
      review?: string;
      /** Review html */
      review_html?: string;
      /** Review summary */
      review_summary?: string | null;
      /** Review summary html */
      review_summary_html?: string;
      review_author: components["schemas"]["Author"];
      /**
       * Last changed
       * Format: date-time
       */
      last_changed: string;
      /** Pricing */
      pricing?: string;
      /** Pricing html */
      pricing_html?: string;
      /** Features */
      features?: string;
      /** Features html */
      features_html?: string;
      /**
       * Site url
       * Format: uri
       */
      site_url?: string | null;
      /**
       * Rating
       * @description Min 1, Max 5 | 5 = Exeptional | 4 = Baseline | 3 = OK but not great
       */
      rating?: number | null;
      homepage_screenshot: components["schemas"]["Photo"];
      photos: components["schemas"]["Photo"][];
      service: components["schemas"]["Service"];
      related_apps: components["schemas"]["Service"][];
      similar_apps: components["schemas"]["Service"][];
    };
    SampleRequest: {
      /**
       * Selected api
       * @description Something like `SlackAPI` (for Python apps) or `SplitwiseCLIAPI@1.0.0` (for CLI apps). Non-public apps are fine as long as the authed user can access them.
       */
      selected_api: string;
      /**
       * Authentication id
       * @description If the app needs auth, provide an `authentication_id` that has the `selected_api` of the app you want to run. Can be any auth visible to the user (including shared).
       */
      authentication_id?: number;
      /**
       * Account id
       * @description An `Account` id to be associated with the sample.
       */
      account_id: number;
      /**
       * Customuser id
       * @description A `Customuser` id to be associated with the sample.
       */
      customuser_id: number;
      /**
       * Action
       * @description Such as `new_contact`
       */
      action: string;
      /**
       * Type of
       * @description Such as `read` or `write`. For a sample in this instance, this will always be `read`
       */
      type_of: string;
      /**
       * Params
       * @description Object that matches the input the node would normally get. Has all the same keys/types as the `needs` of the action. If the selected API is a static hook, `seed` information must be included in the params.
       */
      params: Record<string, never>;
      /**
       * Raw params
       * @description Like params, this is the object matches the input but before the {{}} are rendered. Useful for some legacy apps like Web Builder that rely on `action_fields_raw` in the bundle.
       */
      raw_params?: Record<string, never>;
    };
    SampleResponse: {
      /**
       * Session id
       * @description An id representing either an attempt or a trigger subscription claim. An id prepended with `a.<uuid>` is an attempt id. An id prepended with `c.<uuid>` is a trigger subscription claim id.
       */
      session_id: string;
      /**
       * Metadata
       * @description Any additional information relevant to the sample. In most cases, this will be `null`. If the sample is for a static hook trigger, a `static_hook_url` will be returned in this field.
       */
      metadata: Record<string, never>;
    };
    SampleErrorResponse: {
      /** Error message */
      error_message?: string;
      /** Field errors */
      field_errors?: string;
    };
    SampleResultsResponse: {
      /** @description List containing the results from the sample. Could be empty */
      results?: ({
          [key: string]: string | null;
        })[];
    };
    SampleResultsErrorResponse: {
      /**
       * Error message
       * @description Error message from the sampling attempt.
       */
      error_message?: string;
      /**
       * Error type
       * @description Error type - one of user, auth, partner, or system.
       */
      error_type?: string;
    };
    SEOData: {
      /** ID */
      id?: number;
      /** Path */
      path: string;
      /** Cannonical path */
      cannonical_path: string;
      /** Canonical path */
      canonical_path?: string | null;
      /**
       * Lastmod override
       * Format: date-time
       * @description Adjusts the lastmod in the sitemap.
       */
      lastmod_override?: string | null;
      /** Should redirect */
      should_redirect?: boolean;
      /** Seo index tag override */
      seo_index_tag_override?: string;
      /**
       * Seo title override
       * @description 8-10 words max with title case. Overrides the title tag of the page.
       */
      seo_title_override?: string | null;
      /**
       * Seo description override
       * @description Overrides the meta name="description" tag of the page.
       */
      seo_description_override?: string | null;
      /**
       * Seo h1 override
       * @description Overrides the h1 tag of the page.
       */
      seo_h1_override?: string | null;
      /**
       * Seo structured data
       * @description Structured data, represented as LD+JSON, to render in the head of the page.
       */
      seo_structured_data?: Record<string, unknown> | null;
      /** Seo override enabled */
      seo_override_enabled?: boolean;
      /**
       * Seo experiment name
       * @description An experiment name for use in SEO experiments.
       */
      seo_experiment_name?: string | null;
      /**
       * Seo experiment lane
       * @description An experiment lane name for use in SEO experiments.
       */
      seo_experiment_lane?: string | null;
    };
    CommentAuthor: {
      /** ID */
      id?: number;
      /** Name */
      name: string;
      /** Image */
      image?: string;
    };
    AppAlternativeCommentVote: {
      /** ID */
      id?: number;
      /** Vote */
      vote?: boolean | null;
      /** Comment */
      comment?: string | null;
      user: components["schemas"]["CommentAuthor"];
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
    };
    AppAlternative: {
      /** ID */
      id?: number;
      /** Comparison */
      comparison?: string;
      comment_votes?: readonly components["schemas"]["AppAlternativeCommentVote"][];
      /** Comments */
      comments?: string;
      /** Score */
      score?: string;
    };
    AppMedia: {
      /** ID */
      id?: number;
      /** Url */
      url?: string;
      /** Type */
      type?: string;
      /** Caption */
      caption?: string | null;
      /** Tags */
      tags?: string;
      /** Featured */
      featured?: boolean;
    };
    ServicePairSerializerV2: {
      /** Id */
      id: number;
      /** Canonical id */
      canonical_id: string;
      /** Current implementation id */
      current_implementation_id: string;
      /** Name */
      name: string;
      /** Slug */
      slug: string;
      /** Url */
      url?: string;
      /** Service url */
      service_url?: string;
      /** App url */
      app_url: string;
      /** Learn more url */
      learn_more_url: string;
      categories?: readonly components["schemas"]["service_category"][];
      /** Image */
      image?: string;
      /** Images */
      images?: string;
      /** Description */
      description: string;
      /** Banner */
      banner: string;
      /** Age in days */
      age_in_days: number;
      /** Days since last update */
      days_since_last_update: number;
      /** Primary color */
      primary_color: string;
      /** Is premium */
      is_premium: boolean;
      /** Is public */
      is_public: boolean;
      /** Is built in */
      is_built_in: boolean;
      /** Is beta */
      is_beta: boolean;
      /** Is featured */
      is_featured: boolean;
      /** Is upcoming */
      is_upcoming: boolean;
      /** Popularity */
      popularity: number;
      /** Zap usage count */
      zap_usage_count: number;
      /** Integration overview html */
      integration_overview_html: string;
      /** Hashtag */
      hashtag: string;
      /** Filters */
      filters: string;
      /** Reads */
      reads: string;
      /** Writes */
      writes: string;
      /** Searches */
      searches: string;
      /** Searches or writes */
      searches_or_writes: string;
      /** Integrations count */
      integrations_count?: number | null;
      /**
       * Should index
       * @description Indicates whether or not to include this service pair in the sitemaps.
       */
      should_index?: boolean | null;
      /** Canonical url */
      canonical_url: string;
    };
    ServicePricingPlan: {
      /** ID */
      id?: number;
      /**
       * Url
       * Format: uri
       */
      url?: string;
      /**
       * Name
       * @description Name of pricing plan.
       */
      name?: string;
      /**
       * Unit
       * @description Unit of pricing plan, example: Monthly or Annually
       */
      unit?: string;
      /**
       * Description
       * @description Optional description of the pricing plan
       */
      description?: string;
      /**
       * Features
       * @description An array of features
       */
      features?: Record<string, unknown> | null;
      /** Price */
      price: string;
      /**
       * Is Active?
       * @description Used to catalog a Service's pricing history over time
       */
      is_active?: boolean;
      /**
       * Published
       * @description If True, the pricing plan will be publicly visible.
       */
      published?: boolean;
    };
    ServiceRequest: {
      /** ID */
      id?: number;
      /** Company */
      company?: string;
      /** Comment */
      comment?: string | null;
      /**
       * Created at
       * Format: date-time
       */
      created_at?: string;
      /** Name */
      name?: string;
      /** Photo url */
      photo_url?: string;
    };
    SessionTokenExchangeRequest: {
      /**
       * Session token
       * @description A session token, either from the ssoid or zapsession cookies, depending on what is specified in the session_token_source field
       */
      session_token: string;
      /**
       * Session token kind
       * @description The kind of session token to exchange for a JWT. Use zapsession for JWT token exchange from a subpath (the default) for the zap session cookie. Use ssoid for JWT token exchange from a subdomain for the ssoid cookie.
       * @default zapsession
       * @enum {string}
       */
      session_token_kind?: "zapsession" | "ssoid";
      /** Account id */
      account_id?: string;
    };
    SessionTokenExchangeResponse: {
      /** Account id */
      account_id: string;
      /** Jwt */
      jwt: string;
      /** Customuser id */
      customuser_id: string;
    };
    SharedZapCreator: {
      /** ID */
      id?: number;
      /** Name */
      name?: string;
      /** Gravatar url */
      gravatar_url?: string;
    };
    SharedZapGuidedRecipe: {
      /** ID */
      id?: number;
      /**
       * Date
       * Format: date-time
       */
      date?: string;
      /**
       * Slug
       * Format: slug
       */
      slug?: string | null;
    };
    SharedZap: {
      /** ID */
      id?: number;
      /** Zuid */
      zuid?: string | null;
      /** Link hash */
      link_hash: string;
      /** App slugs */
      app_slugs?: string;
      /**
       * Title
       * @description The title of the Shared Zap
       */
      title?: string | null;
      /**
       * Description
       * @description A lengthy description about what this Zap does and how it does it.
       */
      description?: string | null;
      /** Share visibility */
      share_visibility?: string;
      /** Origin divergence state */
      origin_divergence_state?: string;
      /** Pending selected api changes */
      pending_selected_api_changes?: string;
      creator: components["schemas"]["SharedZapCreator"];
      guided_recipe: components["schemas"]["SharedZapGuidedRecipe"];
      /** Node id */
      node_id?: string;
    };
    SharingStats: {
      /** Installation count */
      installation_count: number;
      /** Installation count for similar */
      installation_count_for_similar: number;
      /**
       * Setup time minutes
       * Format: decimal
       */
      setup_time_minutes: string;
      /**
       * Saved time hours
       * Format: decimal
       */
      saved_time_hours: string;
    };
    SupportNote: {
      /** ID */
      id?: number;
      /**
       * Date
       * Format: date-time
       */
      date?: string;
      /**
       * Lastchanged
       * Format: date-time
       */
      lastchanged?: string;
      /**
       * Title
       * @description Titles are shown at the top of each note when rendered. Titles are also used for selecting notes inside the admin.
       */
      title?: string | null;
      /**
       * Status
       * @description Should this note be visible on the site and in search?
       * @enum {string|null}
       */
      status?: "draft" | "published" | null;
      /**
       * Slug
       * Format: slug
       */
      slug?: string | null;
      /**
       * Text
       * @description Markdown and Django template enabled text box. The title of the note will automatically be included as an H1 tags ("#"). Use H2 tags ("##") as your top level heading. Use {{base_url}} to cross link between docs.
       */
      text: string;
      /** Html */
      html?: string;
    };
    Testimonial: {
      /** Id */
      id: string;
      /** Name */
      name: string;
      /** Company */
      company: string;
      /** Quote */
      quote: string;
      /**
       * Url
       * Format: uri
       */
      url?: string | null;
      /** Image */
      image?: string;
      /** Featured */
      featured?: boolean;
      /** Order */
      order?: number;
    };
    TriggerSubscriptionClaimDetail: {
      /**
       * Claim id
       * @description A TriggerSubscriptionClaim id.
       */
      claim_id: string;
      /**
       * Claimed until
       * Format: date-time
       * @description A time stamp representing when the claim will become expired
       */
      claimed_until: string;
      /**
       * Initialized
       * @description A boolean value representing whether or not the related `TriggerSubscription`has been initialized.
       * If `False` the caller should listen for [InitializationSuccessEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/event.zapier.app_platform.trigger.InitializationSuccessEvent)/[InitializationFailureEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/event.zapier.app_platform.trigger.InitializationFailureEvent) events emitted as a side effect of this request.
       * If `True`, the caller can begin to listen for [ProduceSuccessEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/event.zapier.app_platform.trigger.InitializationFailureEvent)/[ProduceFailureEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/event.zapier.app_platform.trigger.ProduceFailureEvent) events
       */
      initialized: boolean;
      /**
       * Metadata
       * @description Consists any additional claim information. For example
       *         ```
       *         {
       *             "claim_id": "017be128-702e-47c7-a5d3-f60156b0a8b6",
       *             "trigger_type": "hook_subscription",
       *             "created_at": 1631570128,
       *             "initialized": false,
       *             "hook_url": "http://localhost:8000/hooks/standard/167367/6ecdda1e92a14c4fa2ad8bbc3ced04c0/",
       *             "expires_at": null
       *         }
       *         ```
       */
      metadata?: Record<string, never>;
      /**
       * Trigger type
       * @description The type of trigger subscription claim, which reflects the trigger underlying it.
       * @enum {string}
       */
      trigger_type: "polling" | "hook_subscription" | "hook_to_poll" | "hook_static" | "hook_special";
      /**
       * Hook url
       * @description The URL for the hook trigger types, will be null for polling.
       */
      hook_url?: string;
      /**
       * Claimed at
       * Format: date-time
       * @description A time stamp representing when the claim was created.
       */
      claimed_at: string;
    };
    TriggerSubscriptionClaimDetailResponse: {
      claims: components["schemas"]["TriggerSubscriptionClaimDetail"][];
    };
    TriggerSubscriptionRequest: {
      /**
       * Selected api
       * @description Something like `SlackAPI` (for Python apps) or `SplitwiseCLIAPI@1.0.0` (for CLI apps). Non-public apps are fine as long as the authed user can access them.
       */
      selected_api: string;
      /**
       * Type of
       * @description Must be `read` currently, though may support other types of trigger in the future.
       */
      type_of: string;
      /**
       * Action
       * @description Such as `new_contact`.
       */
      action: string;
      /**
       * Authentication id
       * @description If the app needs auth, provide an `authentication_id` that has the `selected_api` of the app you want to run. Can be any auth visible to the user (including shared).
       */
      authentication_id?: number;
      /**
       * Claim for seconds
       * @description Number of seconds until the claim should be recognized as expired. Returned as a datetime in the `claimed_until` field of the response.
       * If this field is excluded from the request body, it will be assumed that the claim has no expiration date. Passing in a `null` value will result in error.
       */
      claim_for_seconds?: number;
      /**
       * Params
       * @description Object that matches the input the node would normally get. Has all the same keys/types as the `needs` of the action.
       */
      params: Record<string, never>;
      /**
       * Claimant
       * @description The name of who is making this claim. The claimant name is a value created and assigned by App Platform. If you have not been provided one then omit this field.
       */
      claimant?: string;
      /**
       * Idempotency id
       * @description A unique string to identify this claim request, if another request is made with the same idempotency_id a 200 response is returned, but no further claims are created.  You can check for an Idempotent-Replayed:True header to see if this was the case. If no ID is provided each request will be treated as unique and a claim created.
       */
      idempotency_id?: string;
      /** @description A set of selected_apis that are allowed to have data passed in */
      destination_selected_apis?: string[];
    };
    TriggerSubscriptionClaimResponse: {
      /**
       * Claim id
       * @description A TriggerSubscriptionClaim id
       */
      claim_id: string;
      /**
       * Claimed until
       * Format: date-time
       * @description A time stamp representing when the claim will become expired
       */
      claimed_until: string;
      /**
       * Initialized
       * @description A boolean value representing whether or not the related `TriggerSubscription`has been initialized.
       * If `False` the caller should listen for [InitializationSuccessEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/event.zapier.app_platform.trigger.InitializationSuccessEvent)/[InitializationFailureEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/event.zapier.app_platform.trigger.InitializationFailureEvent) events emitted as a side effect of this request.
       * If `True`, the caller can begin to listen for [ProduceSuccessEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/event.zapier.app_platform.trigger.InitializationFailureEvent)/[ProduceFailureEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/event.zapier.app_platform.trigger.ProduceFailureEvent) events
       */
      initialized: boolean;
      /**
       * Metadata
       * @description Consists any additional claim information. For example
       *         ```
       *         {
       *             "claim_id": "017be128-702e-47c7-a5d3-f60156b0a8b6",
       *             "trigger_type": "hook_subscription",
       *             "created_at": 1631570128,
       *             "initialized": false,
       *             "hook_url": "http://localhost:8000/hooks/standard/167367/6ecdda1e92a14c4fa2ad8bbc3ced04c0/",
       *             "expires_at": null
       *         }
       *         ```
       */
      metadata?: Record<string, never>;
    };
    TriggerSubscriptionError: {
      /** Field errors */
      field_errors?: Record<string, never>;
      /** Error message */
      error_message?: string;
    };
    Update: {
      /** ID */
      id?: number;
      /**
       * Title
       * @description 8-10 words max with title case.
       */
      title: string;
      /**
       * Date
       * Format: date-time
       */
      date?: string;
      /**
       * Lastchanged
       * Format: date-time
       */
      lastchanged?: string;
      /**
       * Slug
       * Format: slug
       */
      slug?: string | null;
      /**
       * Status
       * @enum {string}
       */
      status?: "draft" | "for-review" | "published";
      /** Description */
      description: string;
      /** Excerpt */
      excerpt?: string;
      /** Excerpt text */
      excerpt_text?: string;
      /**
       * Url
       * Format: uri
       */
      url?: string;
      /** Images */
      images?: string;
      /** Image */
      image: string;
      author: components["schemas"]["Author"];
    };
    UseCase: {
      /** ID */
      id?: number;
      /**
       * Canonical id
       * Format: uuid
       */
      canonical_id?: string;
      /**
       * Url
       * Format: uri
       */
      url?: string;
      /** Title */
      title?: string;
      /**
       * Slug
       * Format: slug
       */
      slug?: string | null;
      /** Description */
      description?: string;
      /**
       * Summary line
       * @description Terser is better. To be used as a summary line, like "instantly follow up with new leads or customers", phrased to come after "So you can".
       */
      summary_line?: string;
      /** Icon name */
      icon_name?: string;
      /** Icon color */
      icon_color?: string;
      /** Used by count */
      used_by_count?: number;
      /** Steps */
      steps?: string;
    };
    UseCaseStepAction: {
      /** Key */
      key: string;
      /** App implementation id */
      app_implementation_id?: string;
      /** App slug */
      app_slug?: string;
      /** App name */
      app_name?: string;
      /** Name */
      name?: string;
      /** Image */
      image?: string;
    };
    SkillLevelAction: {
      /** ID */
      id?: number;
      /**
       * Name
       * @description Human-readable label to present to user
       */
      name: string;
      /**
       * Key
       * @description Semi-human-readable string to identify via API. Changes here may require FE code changes.
       */
      key: string;
      /** Order */
      order?: string;
      /** Completed */
      completed?: string;
      /** Completion url */
      completion_url?: string;
    };
    Zap: {
      /** Id */
      id: number;
    };
    DeleteZapsRequest: {
      zap_ids: number[];
    };
    TransferZapsRequest: {
      zap_ids: number[];
      /** Customuser id */
      customuser_id: number;
      /** Account id */
      account_id: number;
    };
    ZapTransferObjectserializer: {
      /** Id */
      id: number;
      /** Title */
      title: string;
    };
    TransferZapsResponse: {
      successes: components["schemas"]["ZapTransferObjectserializer"][];
      failures: components["schemas"]["ZapTransferObjectserializer"][];
    };
    ExportZapsRequest: {
      zap_ids?: number[];
      /** Account id */
      account_id?: number;
    };
    ImportZapsRequest: {
      /** Destination folder id */
      destination_folder_id?: number;
      /** Account id */
      account_id?: number;
    };
    MoveZapsRequest: {
      zap_ids: number[];
      /** Target account id */
      target_account_id: number;
    };
    ChoiceResponse: {
      objects?: readonly ({
          [key: string]: string | null;
        })[];
    };
    ConvertZDLToNodes: {
      /**
       * Zdl
       * @description A valid ZDL v0.4 zap definition.
       */
      zdl: Record<string, never>;
      /**
       * Account id
       * @description The Account ID to execute ZDL with. Defaults to primary if it exists.
       */
      account_id?: number;
      /**
       * Title
       * @description Title to display in the Zap List.
       */
      title: string;
      /**
       * Enable
       * @description Whether to enable (unpause) the Zap.
       * @default false
       */
      enable?: boolean;
      /**
       * Dry run
       * @description Whether to not actually create any Nodes. Useful for validation
       * @default false
       */
      dry_run?: boolean;
      /**
       * Draft
       * @description Whether to skip enable (unpause) checks.
       * @default false
       */
      draft?: boolean;
      /**
       * Samples
       * @description A dictionary with samples to use instead of the default 'skipped' ones. Keys should match the step IDs in the ZDL.
       * @default {}
       */
      samples?: {
        [key: string]: string | null;
      };
    };
    ConvertZDLToNodesResponseSuccess: {
      /**
       * Paused
       * @description Whether the Zap was unpaused.
       */
      paused: boolean;
      /**
       * Root id
       * @description The Node ID of the root node.
       */
      root_id?: number;
    };
    Error: {
      /**
       * Detail
       * @description Summary of the error.
       */
      detail: string;
      /**
       * Meta
       * @description Optional context for the error.
       */
      meta?: {
        [key: string]: string | null;
      };
    };
    ConvertZDLToNodesResponseFailure: {
      /** @description List of errors. */
      errors?: components["schemas"]["Error"][];
    };
    ZDLRunPublished: {
      /**
       * Zap
       * @description The id of the Zap you wish to run.
       */
      zap: string;
      /**
       * Version
       * @description The version id of the Zap you want to run.
       */
      version: string;
      /**
       * Payload
       * @description The trigger payload to be run.
       */
      payload: Record<string, never>;
      /**
       * Account
       * @description The account id the Zap is owned by.
       */
      account: number;
    };
    ZDLValidateRequest: {
      /**
       * Zdl
       * @description The ZDL to be validated.
       */
      zdl: Record<string, never>;
    };
    ZDLValidateResponseError: {
      /**
       * Errors
       * @description A dict of validation errors.
       */
      errors: {
        [key: string]: string | null;
      };
    };
    ZHTaskUsageAggregate: {
      /**
       * Billable
       * @description Count of billable tasks
       * @default 0
       */
      billable?: number;
      /**
       * Delayed
       * @description Count of delayed tasks
       * @default 0
       */
      delayed?: number;
      /**
       * Error
       * @description Count of errored tasks
       */
      error?: number;
      /**
       * Filtered
       * @description Count of filtered tasks
       * @default 0
       */
      filtered?: number;
      /**
       * Halted
       * @description Count of halted tasks
       * @default 0
       */
      halted?: number;
      /**
       * Held
       * @description Count of held tasks
       * @default 0
       */
      held?: number;
      /**
       * Pending
       * @description Count of pending tasks
       * @default 0
       */
      pending?: number;
      /**
       * Scheduled
       * @description Count of scheduled tasks
       * @default 0
       */
      scheduled?: number;
      /**
       * Skipped
       * @description Count of skipped tasks
       * @default 0
       */
      skipped?: number;
      /**
       * Success
       * @description Count of successful tasks
       * @default 0
       */
      success?: number;
      /**
       * Throttled
       * @description Count of throttled tasks
       * @default 0
       */
      throttled?: number;
    };
    ZHTaskUsageBucket: {
      /**
       * Date
       * Format: date
       */
      date: string;
      tasks: components["schemas"]["ZHTaskUsageAggregate"];
    };
    ZHTaskUsageResponse: {
      /**
       * Interval
       * @enum {string}
       */
      interval: "day" | "month";
      tasks_by_date: components["schemas"]["ZHTaskUsageBucket"][];
      tasks_by_status: components["schemas"]["ZHTaskUsageAggregate"];
      /** Total tasks count */
      total_tasks_count: number;
    };
    ZHTopZapsTasks: {
      /**
       * Billable
       * @description Count of billable tasks
       */
      billable: number;
      /**
       * Delayed
       * @description Count of delayed tasks
       */
      delayed?: number;
      /**
       * Error
       * @description Count of errored tasks
       */
      error?: number;
      /**
       * Filtered
       * @description Count of filtered tasks
       */
      filtered?: number;
      /**
       * Halted
       * @description Count of halted tasks
       */
      halted?: number;
      /**
       * Held
       * @description Count of held tasks
       */
      held?: number;
      /**
       * Pending
       * @description Count of pending tasks
       */
      pending?: number;
      /**
       * Scheduled
       * @description Count of scheduled tasks
       */
      scheduled?: number;
      /**
       * Skipped
       * @description Count of skipped tasks
       */
      skipped?: number;
      /**
       * Success
       * @description Count of successful tasks
       */
      success?: number;
      /**
       * Throttled
       * @description Count of throttled tasks
       */
      throttled?: number;
    };
    ZHTopZapsZaps: {
      /** Zap id */
      zap_id: string;
      tasks: components["schemas"]["ZHTopZapsTasks"];
      /**
       * Last run
       * Format: date-time
       */
      last_run: string;
    };
    ZHTopZaps: {
      /**
       * Count
       * @description Count of Zaps fitting the filter criteria which ran during the specified period
       */
      count: number;
      objects: components["schemas"]["ZHTopZapsZaps"][];
    };
    ErrorRateByZapDetails: ({
      /** Zap id */
      zap_id: string;
      /** Error rate */
      error_rate: number;
      /** Percent change */
      percent_change: number | null;
      /** Error total */
      error_total: number;
    }) | null;
    ErrorRateByZapTableResponse: {
      details: components["schemas"]["ErrorRateByZapDetails"][] | null;
    };
    TaskUsageByAppDetails: ({
      /** Task count */
      task_count: number;
      /** Percent change */
      percent_change: number | null;
      /** Percent of total */
      percent_of_total: number;
      /** App id */
      app_id: string;
    }) | null;
    ZapHistoryAnalyticsSummaryBase: {
      /** Task count */
      task_count: number;
      /** Remaining count */
      remaining_count: number;
      /** Percent of total */
      percent_of_total: number | null;
      /** Percent change */
      percent_change: number | null;
    };
    TaskUsageByAppTableResponse: {
      details: components["schemas"]["TaskUsageByAppDetails"][] | null;
      total: components["schemas"]["ZapHistoryAnalyticsSummaryBase"];
    };
    TaskUsageByOwnerDetails: ({
      /** Task count */
      task_count: number;
      /** Percent change */
      percent_change: number | null;
      /** Percent of total */
      percent_of_total: number;
      /** Customuser id */
      customuser_id: string;
    }) | null;
    TaskUsageByOwnerTableResponse: {
      details: components["schemas"]["TaskUsageByOwnerDetails"][] | null;
      total: components["schemas"]["ZapHistoryAnalyticsSummaryBase"];
    };
    TaskUsageByZapDetails: ({
      /** Task count */
      task_count: number;
      /** Percent change */
      percent_change: number | null;
      /** Percent of total */
      percent_of_total: number;
      /** Zap id */
      zap_id: string;
    }) | null;
    TaskUsageByZapTableResponse: {
      details: components["schemas"]["TaskUsageByZapDetails"][] | null;
      total: components["schemas"]["ZapHistoryAnalyticsSummaryBase"];
    };
    MetaObject: {
      /** Offset */
      offset?: number;
      /** Limit */
      limit?: number;
      /**
       * Count
       * @description The total number of Zap runs matching the filter parameters (up to the maximum number the service can retrieve)
       */
      count: number;
      /**
       * Total actionable
       * @description The number of Zap runs that can be used in mass actions
       */
      total_actionable: number;
    };
    StepErrorV2: ({
      /**
       * Id
       * Format: uuid
       */
      id?: string | null;
      /**
       * Error msg
       * @description Human-readable description of the error
       */
      error_msg?: string | null;
      /**
       * Title
       * @description Short text describing the step error
       */
      title?: string | null;
      /** Code */
      code?: string | null;
      /**
       * Status
       * @description HTTP status code returned by the step
       */
      status?: string | null;
      /** Version */
      version?: number | null;
    }) | null;
    /** @description Contains the execution details of each step: status, input, output, etc */
    StepExecutionV2: ({
      /**
       * Type
       * @enum {string}
       */
      type: "write" | "read" | "filter" | "search" | "search_or_write" | "search_and_write" | "run";
      /**
       * Zap run id
       * Format: uuid
       * @description Zap run id associated with this step. Steps with zap_run_id are usually part of paths or loops.
       */
      zap_run_id?: string;
      /** App */
      app: string | null;
      /** Action */
      action?: string | null;
      /** Authentication id */
      authentication_id?: string | null;
      /** Params */
      params?: ({
        [key: string]: string | null;
      }) | null;
      /** Title */
      title?: string | null;
      /** Comment */
      comment?: string | null;
      /** Meta */
      meta?: ({
        [key: string]: string | null;
      }) | null;
      /** Parent id */
      parent_id?: string | null;
      /** Step id */
      step_id: string;
      /**
       * Frame id
       * Format: uuid
       * @description UUID of the execution frame of this step. Steps with null frame_id are usually part of paths or loops.
       */
      frame_id?: string | null;
      /**
       * Status
       * @description Execution status of the step. It can be null if the step belongs to a child fork.
       * @enum {string|null}
       */
      status?: "delayed" | "scheduled" | "pending" | "error" | "error_handled" | "halted" | "throttled" | "held" | "filtered" | "skipped" | "success" | null;
      /** Input */
      input?: Record<string, unknown> | null;
      /** Invocation id */
      invocation_id?: string | null;
      /** Output */
      output?: Record<string, unknown> | null;
      /**
       * Start time
       * Format: date-time
       * @description Datetime when the step was executed
       */
      start_time?: string | null;
      /**
       * Order
       * @description Number representing the order of the Zap steps
       */
      order?: number;
      step_errors?: components["schemas"]["StepErrorV2"];
    }) | null;
    ZapRunV2: {
      /**
       * Id
       * Format: uuid
       * @description Zap Run ID
       */
      id: string;
      /**
       * Zap id
       * @description Zap id. Could be a node ID or a UUID in ZDL form
       */
      zap_id: string;
      /**
       * Status
       * @enum {string}
       */
      status: "delayed" | "scheduled" | "pending" | "error" | "error_handled" | "halted" | "throttled" | "held" | "filtered" | "skipped" | "success";
      /**
       * Zap title
       * @description The title of the Zap at the time it ran
       */
      zap_title: string | null;
      /** Stop reason */
      stop_reason: ({
        [key: string]: string | null;
      }) | null;
      /** Has paths */
      has_paths: boolean;
      /** Can replay */
      can_replay?: boolean;
      /**
       * Zdl version
       * @description Version of the ZDL document at the time of the run
       */
      zdl_version: string;
      /** Zap version id */
      zap_version_id?: string | null;
      /** Zap version name */
      zap_version_name?: string | null;
      /** Account id */
      account_id: number;
      /**
       * Billable count
       * @description Amount of billable tasks of the current run
       */
      billable_count: number;
      /**
       * Total billable count
       * @description Total amount of billable tasks of the current run and its children.
       */
      total_billable_count: number;
      /**
       * Customuser id
       * @description Owner of the Zap that ran
       */
      customuser_id?: number;
      /** Held plan limit */
      held_plan_limit: string | null;
      /** Held stale auth id */
      held_stale_auth_id?: number | null;
      /** Held reason */
      held_reason?: string | null;
      /** Held plan id */
      held_plan_id?: number | null;
      /** Held payment issue */
      held_payment_issue?: boolean | null;
      /**
       * Start time
       * Format: date-time
       */
      start_time?: string | null;
      /**
       * Rescheduled time
       * Format: date-time
       * @description Date time when the zap will run after being scheduled
       */
      rescheduled_time?: string | null;
      /** @description Contains the execution details of each step: status, input, output, etc */
      steps_executions: components["schemas"]["StepExecutionV2"][] | null;
      /** Timezone */
      timezone?: string | null;
    };
    ZapRunsV2Response: {
      meta: components["schemas"]["MetaObject"];
      results: components["schemas"]["ZapRunV2"][];
    };
    ErrorDetailsV2: {
      /** Status */
      status: string;
      /** Code */
      code: string;
      /** Title */
      title?: string;
      /** Detail */
      detail: string;
      /** source */
      _source?: string;
    };
    ZapHistoryErrorV2: {
      _errors: components["schemas"]["ErrorDetailsV2"][];
    };
    DeleteBody: {
      /** Offset */
      offset?: number;
      /** Limit */
      limit?: number;
      /** Account id */
      account_id: number;
      /**
       * From date
       * Format: date-time
       * @description Start datetime for query; ISO-8601
       */
      from_date?: string;
      /**
       * To date
       * Format: date-time
       * @description Start datetime for query; ISO-8601
       */
      to_date?: string;
      /** @description Comma-separated list of customuser_id values to filter by */
      customuser_ids?: number[];
      /** @description Comma-separated list of folder_id values to filter by */
      folder_ids?: number[];
      /** @description Comma-separated list of Zap kind values to filter by */
      kinds?: ("workflow" | "transfer")[];
      /** @description Comma-separated list of apps (selected APIs) values to filter by */
      selected_apis?: string[];
      /** @description Comma-separated list of Zap IDs (numeric or UUID) */
      zap_ids?: string[];
      /** Channel error */
      channel_error?: string;
      /** Held reason */
      held_reason?: string;
      /**
       * Query
       * @description Search query to be used for filtering Zap runs
       */
      query?: string;
      /** @description Comma-separated list of zap run statuses used for filtering */
      statuses?: ("delayed" | "scheduled" | "pending" | "error" | "error_handled" | "halted" | "throttled" | "held" | "filtered" | "skipped" | "success")[];
      /** @description Comma-separated list of task stream IDs */
      zap_run_ids?: string[];
      /**
       * Zap run limit
       * @description Maximum amount of task streams to be deleted
       */
      zap_run_limit?: number;
    };
    ZapRunsMassActionResponse: {
      /** Pendings */
      pendings?: number;
      /** Failures */
      failures: {
        [key: string]: number;
      };
      /** Channel */
      channel?: string | null;
    };
    ReplayBody: {
      /** Offset */
      offset?: number;
      /** Limit */
      limit?: number;
      /** Account id */
      account_id: number;
      /**
       * From date
       * Format: date-time
       * @description Start datetime for query; ISO-8601
       */
      from_date?: string;
      /**
       * To date
       * Format: date-time
       * @description Start datetime for query; ISO-8601
       */
      to_date?: string;
      /** @description Comma-separated list of customuser_id values to filter by */
      customuser_ids?: number[];
      /** @description Comma-separated list of folder_id values to filter by */
      folder_ids?: number[];
      /** @description Comma-separated list of Zap kind values to filter by */
      kinds?: ("workflow" | "transfer")[];
      /** @description Comma-separated list of apps (selected APIs) values to filter by */
      selected_apis?: string[];
      /** @description Comma-separated list of Zap IDs (numeric or UUID) */
      zap_ids?: string[];
      /** Channel error */
      channel_error?: string;
      /** Held reason */
      held_reason?: string;
      /**
       * Query
       * @description Search query to be used for filtering Zap runs
       */
      query?: string;
      /** @description Comma-separated list of zap run statuses used for filtering */
      statuses?: ("delayed" | "scheduled" | "pending" | "error" | "error_handled" | "halted" | "throttled" | "held" | "filtered" | "skipped" | "success")[];
      /** @description Comma-separated list of task stream IDs */
      zap_run_ids?: string[];
      /**
       * Zap run limit
       * @description Maximum amount of task streams to be replayed
       */
      zap_run_limit?: number;
    };
    ExportBody: {
      /** Account id */
      account_id: number;
      /**
       * From date
       * Format: date-time
       * @description Start datetime for query; ISO-8601
       */
      from_date?: string;
      /**
       * To date
       * Format: date-time
       * @description Start datetime for query; ISO-8601
       */
      to_date?: string;
      /** @description Comma-separated list of customuser_id values to filter by */
      customuser_ids?: number[];
      /** @description Comma-separated list of folder_id values to filter by */
      folder_ids?: number[];
      /** @description Comma-separated list of Zap kind values to filter by */
      kinds?: ("workflow" | "transfer")[];
      /** @description Comma-separated list of apps (selected APIs) values to filter by */
      selected_apis?: string[];
      /** @description Comma-separated list of Zap IDs (numeric or UUID) */
      zap_ids?: string[];
      /** Channel error */
      channel_error?: string;
      /** Held reason */
      held_reason?: string;
      /**
       * Query
       * @description Search query to be used for filtering Zap runs
       */
      query?: string;
      /** @description Comma-separated list of zap run statuses used for filtering */
      statuses?: ("delayed" | "scheduled" | "pending" | "error" | "error_handled" | "halted" | "throttled" | "held" | "filtered" | "skipped" | "success")[];
      /** @description Comma-separated list of task stream IDs */
      zap_run_ids?: string[];
      /** Channel id */
      channel_id?: string;
      /**
       * Export format
       * @default JSON
       */
      export_format?: string;
      /**
       * Callback url
       * Format: uri
       */
      callback_url?: string;
    };
    ExportResponse: {
      /** Message */
      message: string;
    };
    CountsByAuthV2: {
      /**
       * Id
       * @description Zap ID
       */
      id: string;
      /**
       * Total
       * @description The number of runs held for this Authentication.
       */
      total: number;
    };
    CountsByRestrictedAppV2: {
      /**
       * App
       * @description The selected_api value of a restricted App.
       */
      app: string;
      /**
       * Total
       * @description The number of runs that were held due to this restricted App.
       */
      total: number;
    };
    CountsByTaskLimitV2: {
      /**
       * Limit
       * @description Number representing the task limit of an account.
       */
      limit: string;
      /**
       * Total
       * @description The number of runs that were held due to this task limit.
       */
      total: number;
    };
    CountsByZapV2: {
      /**
       * Id
       * @description Authentication ID
       */
      id: string;
      /**
       * Total
       * @description The number of runs held for this Zap.
       */
      total: number;
    };
    /** @description A list of objects that represent the breakdown of held run counts by reason. */
    ReasonCountsV2: {
      /**
       * Payment issue held count
       * @description A count of how many held runs are due to payment issues.             This applies to the reasons of task_limit, step_limit and blacklisted_app.
       */
      payment_issue_held_count?: number;
      /**
       * Reason type
       * @description The type of reason the held counts represent.
       */
      reason_type: string | null;
      totals_by_auth_id?: components["schemas"]["CountsByAuthV2"][];
      totals_by_restricted_app?: components["schemas"]["CountsByRestrictedAppV2"][];
      totals_by_task_limit?: components["schemas"]["CountsByTaskLimitV2"][];
      totals_by_zap_id?: components["schemas"]["CountsByZapV2"][];
      /**
       * Total
       * @description The total count of runs that have been held for this reason type.
       * @default 0
       */
      total?: number;
    };
    /** @description A list of objects that represent the breakdown of held run counts for Zaps */
    ZapCountsV2: {
      /** Zap id */
      zap_id: string | null;
      /** @description A list of objects that represent the breakdown of held run counts for a Zap by reason. */
      reasons?: components["schemas"]["ReasonCountsV2"][];
      /**
       * Total
       * @description The total number of held run counts for a Zap.
       * @default 0
       */
      total?: number;
      /**
       * Starts expiring
       * Format: date-time
       * @description An estimate of when the held runs for this Zap will start to expire.
       */
      starts_expiring?: string | null;
    };
    HeldRunCountsV2Response: {
      /** @description A list of objects that represent the breakdown of held run counts by reason. */
      reasons?: components["schemas"]["ReasonCountsV2"][];
      /** @description A list of objects that represent the breakdown of held run counts for Zaps */
      zaps?: components["schemas"]["ZapCountsV2"][];
      /**
       * Total
       * @description The number of held run counts returned.
       * @default 0
       */
      total?: number;
      /**
       * Starts expiring
       * Format: date-time
       * @description An estimate of when the held runs for this response will start to expire.
       */
      starts_expiring?: string | null;
    };
    ZapHistoryRequestLogsResponse: {
      /** Account id */
      account_id: number;
      /** Customuser id */
      customuser_id: number;
      /**
       * Request data
       * @description String representation of the data sent as part of the HTTP request, potentially JSON-encoded
       */
      request_data: Record<string, unknown> | null;
      /**
       * Request duration ms
       * @description The duration of the HTTP request in milliseconds
       */
      request_duration_ms: number | null;
      /**
       * Request headers
       * @description Headers for the HTTP request
       */
      request_headers: string | null;
      /**
       * Request method
       * @description Method of the HTTP request
       */
      request_method: string;
      /**
       * Request params
       * @description Query parameters sent as part of the HTTP request
       */
      request_params: string | null;
      /**
       * Request url
       * @description The URL of the HTTP request
       */
      request_url: string;
      /**
       * Response content
       * @description String representation of the response content of the HTTP request, potentially JSON-encoded
       */
      response_content: Record<string, unknown> | null;
      /**
       * Response headers
       * @description String representation of the HTTP response headers. If null, there was probably an error with the HTTP request (timeout, for example)
       */
      response_headers: string | null;
      /**
       * Response status code
       * @description Numeric status code of the HTTP response. If null, there was an error with the HTTP request (timeout, for example)
       */
      response_status_code: number | null;
      /**
       * Selected api
       * @description Internal name of the integration related to the action that performed the HTTP request
       */
      selected_api: string;
    };
    TopZapsByRunsV2: {
      /**
       * Zap id
       * @description Zap id. Could be a node ID or a UUID in ZDL form
       */
      zap_id: string;
      /**
       * Count
       * @description The count of matching documents found
       */
      count: number;
    };
    TopZapsByRunsV2Response: {
      meta: components["schemas"]["MetaObject"];
      results: components["schemas"]["TopZapsByRunsV2"][];
    };
    GetZapRunsUsageResponse: {
      usage: ({
          [key: string]: string | null;
        })[];
    };
    Status: {
      /** Status */
      status: string;
      /** Count */
      count: number;
    };
    TopLevelZap: {
      /** Zap id */
      zap_id: string;
      /** Count */
      count: number;
      statuses?: components["schemas"]["Status"][];
    };
    ZapRunCountZapSerializer: {
      /** Zap id */
      zap_id: string;
      /** Count */
      count: number;
    };
    TopLevelStatus: {
      /** Status */
      status: string;
      /** Count */
      count: number;
      zaps?: components["schemas"]["ZapRunCountZapSerializer"][];
    };
    ZapRunCountsV2Response: {
      /** Total */
      total: number;
      zaps?: components["schemas"]["TopLevelZap"][];
      statuses?: components["schemas"]["TopLevelStatus"][];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: {
    scim_v2_Groups_createData: {
      content: {
        "application/scim+json": Record<string, never>;
        "application/json": Record<string, never>;
      };
    };
    Onboarding: {
      content: {
        "application/json": components["schemas"]["Onboarding"];
      };
    };
    BillingAccount: {
      content: {
        "application/json": components["schemas"]["BillingAccount"];
      };
    };
    api_v4_accounts_domains_members_export_membersData: {
      content: {
        "application/json": Record<string, never>;
      };
    };
    ServiceRequest: {
      content: {
        "application/json": components["schemas"]["ServiceRequest"];
      };
    };
    AccountProvision: {
      content: {
        "application/json": components["schemas"]["AccountProvision"];
      };
    };
    OAuthApplication: {
      content: {
        "application/json": components["schemas"]["OAuthApplication"];
      };
    };
    InvitationCode: {
      content: {
        "application/json": components["schemas"]["InvitationCode"];
      };
    };
    AccountFeatureEnrollment: {
      content: {
        "application/json": components["schemas"]["AccountFeatureEnrollment"];
      };
    };
    Feedback: {
      content: {
        "application/json": components["schemas"]["Feedback"];
      };
    };
    CampaignOffer: {
      content: {
        "application/json": components["schemas"]["CampaignOffer"];
      };
    };
    TeamRequestWrite: {
      content: {
        "application/json": components["schemas"]["TeamRequestWrite"];
      };
    };
    ShareAndUnshareRequest: {
      content: {
        "application/json": components["schemas"]["ShareAndUnshareRequest"];
      };
    };
    DomainVerificationRequest: {
      content: {
        "application/json": components["schemas"]["DomainVerificationRequest"];
      };
    };
    Folder: {
      content: {
        "application/json": components["schemas"]["Folder"];
      };
    };
    IdentityProvider: {
      content: {
        "application/json": components["schemas"]["IdentityProvider"];
      };
    };
    Invitation: {
      content: {
        "application/json": components["schemas"]["Invitation"];
      };
    };
    FullAccountMember: {
      content: {
        "application/json": components["schemas"]["FullAccountMember"];
      };
    };
    TeamWrite: {
      content: {
        "application/json": components["schemas"]["TeamWrite"];
      };
    };
    Authentication: {
      content: {
        "application/json": components["schemas"]["Authentication"];
      };
    };
    GivesRequest: {
      content: {
        "application/json": components["schemas"]["GivesRequest"];
      };
    };
    NeedsRequest: {
      content: {
        "application/json": components["schemas"]["NeedsRequest"];
      };
    };
    PersistedModal: {
      content: {
        "application/json": components["schemas"]["PersistedModal"];
      };
    };
    SampleRequest: {
      content: {
        "application/json": components["schemas"]["SampleRequest"];
      };
    };
    SharedZap: {
      content: {
        "application/json": components["schemas"]["SharedZap"];
      };
    };
    Zap: {
      content: {
        "application/json": components["schemas"]["Zap"];
      };
    };
  };
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * @description Get activity for actions performed on an account. Can be filtered
   * by a list of actors, and date range. For zap actions, also allows
   * filtering by app and by folders.
   * Please see the parameters above for a comprehensive filter list.
   */
  "api_audit-logs_v1_events_list": {
    parameters: {
      query: {
        offset?: number;
        limit?: number;
        account_id: number;
        /** @description Start datetime for query; ISO-8601 */
        from_date?: string;
        /** @description Start datetime for query; ISO-8601 */
        to_date?: string;
        /** @description Comma-separated list of customuser_id values to filter by */
        customuser_ids?: number[];
        /** @description Comma-separated list of folder_id values to filter by */
        folder_ids?: number[];
        /** @description Comma-separated list of Zap kind values to filter by */
        kinds?: ("workflow" | "transfer")[];
        /** @description Comma-separated list of apps (selected APIs) values to filter by */
        selected_apis?: string[];
        /** @description Search query to be used for filtering events. */
        query?: string;
        /** @description The object ids for which events are to be retrieved */
        object_ids?: string[];
        /** @description Comma-separated list of performed actions to filter events by */
        actions?: string[];
        /** @description Type of object for which to retrieve events data */
        object_type?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["EventsListResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
    };
  };
  /**
   * Endpoint for setting account level restrictions.
   * @description Allows setting publish approval flows on or off at the account level.
   * This data is stored in the `Relationship` model of the `identity`
   * database, via `identity.access` interfaces.
   */
  "api_checkpoint_v1_account-restrictions_list": {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * Endpoint for setting account level restrictions.
   * @description Allows setting publish approval flows on or off at the account level.
   * This data is stored in the `Relationship` model of the `identity`
   * database, via `identity.access` interfaces.
   */
  "api_checkpoint_v1_account-restrictions_update": {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * Checkpoint service proxy for Publish Approval requests.
   * @description For full API documentation, see the [Checkpoint service](https://checkpoint.k8s.zapier.com/api/schema/)
   */
  api_checkpoint_v1_approvals_list: {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * Checkpoint service proxy for Publish Approval requests.
   * @description For full API documentation, see the [Checkpoint service](https://checkpoint.k8s.zapier.com/api/schema/)
   */
  api_checkpoint_v1_approvals_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  /**
   * Checkpoint service proxy for Publish Approval requests.
   * @description For full API documentation, see the [Checkpoint service](https://checkpoint.k8s.zapier.com/api/schema/)
   */
  api_checkpoint_v1_approvals_read: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * Checkpoint service proxy for Publish Approval requests.
   * @description For full API documentation, see the [Checkpoint service](https://checkpoint.k8s.zapier.com/api/schema/)
   */
  api_checkpoint_v1_approvals_update: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * Checkpoint service proxy for Publish Approval requests.
   * @description For full API documentation, see the [Checkpoint service](https://checkpoint.k8s.zapier.com/api/schema/)
   */
  api_checkpoint_v1_approvals_partial_update: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  /** @description Sends an email using mailgun and returns the response. */
  api_nap_internal_emails_send_create: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SendEmailResponse"];
        };
      };
    };
  };
  /**
   * @description Sends an email using mailgun and returns the response.
   * This is a copy of the above logic, but also hydrates in user data
   * into the template_context's comment(s).
   *
   * This is meant to be a TEMPORARY WORKAROUND because the
   * /api/v4/accounts/:id/members/:member_id/ endpoint does not support S2S auth yet.
   * This was the path of least resistance to getting email notifications for
   * Canvas thread comments working and _shipped_.
   */
  api_nap_internal_emails_send_canvas_notification_email_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  api_v1_assets_list: {
    parameters: {
      query: {
        ids?: string;
        asset_type: "zap" | "canvas" | "interface" | "table" | "chatbot";
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AssetFetch"];
        };
      };
    };
  };
  "api_v1_controlled-apps-strategies_read": {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AppAccessControlStrategy"];
        };
      };
    };
  };
  "api_v1_controlled-apps-strategies_update": {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AppAccessControlStrategy"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AppAccessControlStrategy"];
        };
      };
      201: {
        content: {
          "application/json": components["schemas"]["AppAccessControlStrategy"];
        };
      };
    };
  };
  api_v1_projects_list: {
    parameters: {
      query?: {
        owner_id?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ProjectsList"];
        };
      };
    };
  };
  api_v1_projects_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["Projects"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["Projects"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["Projects"];
        };
      };
    };
  };
  api_v1_projects_read: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Projects"];
        };
      };
      /** @description Invalid project id */
      400: {
        content: never;
      };
      /** @description Permission denied */
      403: {
        content: never;
      };
      /** @description Project not found */
      404: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  api_v1_projects_delete: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
      /** @description Invalid project_id */
      400: {
        content: never;
      };
      /** @description Permission denied */
      403: {
        content: never;
      };
      /** @description Project not found */
      404: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  api_v1_projects_partial_update: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ProjectsUpdateRequest"];
      };
    };
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          "application/json": components["schemas"]["ProjectsList"];
        };
      };
      /** @description Invalid project id */
      400: {
        content: never;
      };
      /** @description Permission denied */
      403: {
        content: never;
      };
      /** @description Project not found */
      404: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  api_v1_projects_share: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: components["requestBodies"]["ShareAndUnshareRequest"];
    responses: {
      201: {
        content: never;
      };
      /** @description Invalid project id */
      400: {
        content: never;
      };
      /** @description Permission denied */
      403: {
        content: never;
      };
      /** @description Project not found */
      404: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  api_v1_projects_shares: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Invalid project id */
      400: {
        content: never;
      };
      /** @description Permission denied */
      403: {
        content: never;
      };
      /** @description Project not found */
      404: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  api_v1_projects_unshare: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: components["requestBodies"]["ShareAndUnshareRequest"];
    responses: {
      204: {
        content: never;
      };
      /** @description Invalid project id */
      400: {
        content: never;
      };
      /** @description Permission denied */
      403: {
        content: never;
      };
      /** @description Project not found */
      404: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  api_v1_projects_assets_list: {
    parameters: {
      path: {
        projects_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ProjectAsset"];
        };
      };
      /** @description Invalid project id */
      400: {
        content: never;
      };
      /** @description Permission denied */
      403: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  api_v1_projects_assets_create: {
    parameters: {
      path: {
        projects_pk: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ProjectAsset"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["ProjectAsset"];
        };
      };
      /** @description Invalid, project_id, asset type or asset id */
      400: {
        content: never;
      };
      /** @description Permission denied */
      403: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  api_v1_projects_assets_delete: {
    parameters: {
      path: {
        projects_pk: string;
        /** @description A composite id including the asset type and asset id using this format <asset_type>:<asset_id>. */
        asset_identifier: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
      /** @description Invalid, project_id, asset type or asset id */
      400: {
        content: never;
      };
      /** @description Permission denied */
      403: {
        content: never;
      };
      404: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  api_v1_search_zaps_list: {
    parameters: {
      query?: {
        /** @description Which field to use when ordering the results. */
        order_by?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["ZapSearch"][];
          };
        };
      };
    };
  };
  /**
   * @description This endpoint receives a POST request from the exporter when the userdata export is complete
   * for each of the user accounts.
   *
   * Example Request:
   * POST v3/data/export/completion
   * {
   *     "export_job_id": "customuser_id/action_id/account_id",
   *     "export_location": "https://s3.amazonaws.com/...",
   * }
   *
   * Example Responses:
   * - 200 OK { "message": "Completed."}
   * - 400 Bad Request { "errors": ["Param xxx is required.", "Malformed xxx."]}
   * - 404 Not Found { "errors": ["No action found."]}
   * - 409 Conflict {'message': 'Duplicate.'}
   */
  api_v3_data_export_completion_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  /**
   * /api/v4/abtesting/identity/<identity_id>/assign_experiment/
   * @description An endpoint to assign an experiment to an identity.
   * Pass in the experiment_collection_slug as the payload.
   * Returns the assigned variant.
   */
  api_v4_abtesting_identity_assign_experiment: {
    parameters: {
      path: {
        identity: string;
      };
    };
    responses: {
      201: {
        content: never;
      };
    };
  };
  /**
   * Deduce the best account for sign in for this user
   * @description We need to figure out if the user can sign in with credentials
   * or with SAML, as well as the best account ID to sign in given
   * an email address and an optional account_id
   */
  "api_v4_account-discovery_list": {
    responses: {
      200: {
        content: never;
      };
    };
  };
  api_v4_accounts_list: {
    parameters: {
      query?: {
        /** @description Filters joinable accounts by access level. Currently only supports `auto_join`. */
        level?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["BillingAccount"][];
          };
        };
      };
    };
  };
  api_v4_accounts_access: {
    parameters: {
      query?: {
        /** @description Filters joinable accounts by access level. Currently only supports `auto_join`. */
        level?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["BillingAccount"][];
          };
        };
      };
    };
  };
  /** @description Returns list of offer data associated with campaigns */
  api_v4_accounts_campaignoffers_read: {
    parameters: {
      path: {
        account_id: string;
        campaign_slug: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  "api_v4_accounts_invoice-items_create": {
    parameters: {
      path: {
        account_id: string;
      };
    };
    responses: {
      201: {
        content: never;
      };
    };
  };
  /**
   * Endpoint for denied and allowed apps
   * @description The app access control allows a team administrator
   * to deny certain apps.
   */
  "api_v4_accounts_controlled-apps_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["AppAccessControl"][];
          };
        };
      };
    };
  };
  /**
   * @description Overwrite create method so that we can ensure schema generation
   * with the appropriate serializer.
   */
  "api_v4_accounts_controlled-apps_create": {
    parameters: {
      path: {
        account_pk: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The slug of the app that is restricted */
          slug?: string;
        };
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["AppAccessControl"];
        };
      };
    };
  };
  /** @description Search the users that use the given app */
  "api_v4_accounts_controlled-apps_get_app_users": {
    parameters: {
      path: {
        account_pk: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The slug of the app to use for searching users */
          slug: string;
        };
      };
    };
    responses: {
      201: {
        content: {
          "application/json": {
            /** @description The slug of the app to use for searching users */
            slug: string;
          };
        };
      };
    };
  };
  "api_v4_accounts_controlled-apps_members_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
        app_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["AppAccessControlMembership"][];
          };
        };
      };
    };
  };
  /** @description Add the given user to this controlled app */
  "api_v4_accounts_controlled-apps_members_create": {
    parameters: {
      path: {
        account_pk: string;
        app_pk: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AppAccessControlMembership"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["AppAccessControlMembership"];
        };
      };
    };
  };
  "api_v4_accounts_controlled-apps_members_read": {
    parameters: {
      path: {
        account_pk: string;
        app_pk: string;
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AppAccessControlMembership"];
        };
      };
    };
  };
  /** @description Remove the member from the given controlled app */
  "api_v4_accounts_controlled-apps_members_delete": {
    parameters: {
      path: {
        account_pk: string;
        app_pk: string;
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  "api_v4_accounts_controlled-apps_teams_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
        app_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["AppAccessControlTeamMembership"][];
          };
        };
      };
    };
  };
  /**
   * Control the underlying app with a team ID or with all team members
   * @description This API expects a `team_id` parameter sent as a payload, in the form
   * `{team_id: id|`all`}`
   *
   * If it is sent as an `id`, it needs to be the ID of an already existing team.
   * That team will be added to the underlying controlled app, either as a permitted
   * or as a restricted operation.
   */
  "api_v4_accounts_controlled-apps_teams_create": {
    parameters: {
      path: {
        account_pk: string;
        app_pk: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AppAccessControlTeamMembership"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["AppAccessControlTeamMembership"];
        };
      };
    };
  };
  "api_v4_accounts_controlled-apps_teams_read": {
    parameters: {
      path: {
        account_pk: string;
        app_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AppAccessControlTeamMembership"];
        };
      };
    };
  };
  /**
   * Remove the given team from the underlying controlled app
   * @description The app can be restricted or permitted for a team if the URL has a
   * team ID, or can be controlled from everyone in the account,
   * if the URL uses the special `all` ID.
   *
   * `all` represents all users in a team account, which is separate
   * than all the members in a team workspace.
   */
  "api_v4_accounts_controlled-apps_teams_delete": {
    parameters: {
      path: {
        account_pk: string;
        app_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  /**
   * Endpoint for denied and allowed apps
   * @description The app access control allows a team administrator
   * to deny certain apps.
   */
  "api_v4_accounts_controlled-apps_read": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this Access Control App. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AppAccessControl"];
        };
      };
    };
  };
  /**
   * Endpoint for denied and allowed apps
   * @description The app access control allows a team administrator
   * to deny certain apps.
   */
  "api_v4_accounts_controlled-apps_delete": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this Access Control App. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  "api_v4_accounts_domain-requests_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["DomainVerificationRequest"][];
          };
        };
      };
    };
  };
  /** @description Custom POST method handler to track verification request creation. */
  "api_v4_accounts_domain-requests_create": {
    parameters: {
      path: {
        account_pk: string;
      };
    };
    requestBody: components["requestBodies"]["DomainVerificationRequest"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["DomainVerificationRequest"];
        };
      };
    };
  };
  "api_v4_accounts_domain-requests_read": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this Domain Verification Request. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["DomainVerificationRequest"];
        };
      };
    };
  };
  /**
   * @description Custom PUT method handler to refresh the expiry period for the
   * verification request object.
   */
  "api_v4_accounts_domain-requests_update": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this Domain Verification Request. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["DomainVerificationRequest"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["DomainVerificationRequest"];
        };
      };
    };
  };
  "api_v4_accounts_domain-requests_delete": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this Domain Verification Request. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  /** @description Custom PATCH method handler to check domain */
  "api_v4_accounts_domain-requests_partial_update": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this Domain Verification Request. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["DomainVerificationRequest"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["DomainVerificationRequest"];
        };
      };
    };
  };
  api_v4_accounts_domains_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["OrganizationDomain"][];
          };
        };
      };
    };
  };
  api_v4_accounts_domains_members_list: {
    parameters: {
      query?: {
        /** @description Filter by membership to the company */
        is_company_member?: boolean;
        /** @description Filter by the email of members */
        email?: string;
        /** @description Filter by confirmed or not confirmed emails */
        email_confirmed?: boolean;
        /** @description Filter by multifactor authentication enablement */
        is_mfa_enabled?: boolean;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
        domain_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: Record<string, never>[];
          };
        };
      };
    };
  };
  api_v4_accounts_domains_members_export_members: {
    parameters: {
      path: {
        account_pk: string;
        domain_pk: string;
      };
    };
    requestBody: components["requestBodies"]["api_v4_accounts_domains_members_export_membersData"];
    responses: {
      201: {
        content: {
          "application/json": Record<string, never>;
        };
      };
    };
  };
  api_v4_accounts_domains_read: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this organization domain. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["OrganizationDomain"];
        };
      };
    };
  };
  /** @description This endpoint is used to retrieve all experts associated with the context account */
  api_v4_accounts_experts_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["ExpertClientRelationship"][];
          };
        };
      };
    };
  };
  api_v4_accounts_experts_create: {
    parameters: {
      path: {
        account_pk: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExpertClientRelationship"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["ExpertClientRelationship"];
        };
      };
    };
  };
  "api_v4_accounts_feature-enrollment_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["AccountFeatureEnrollment"][];
          };
        };
      };
    };
  };
  "api_v4_accounts_feature-enrollment_read": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this account feature enrollment. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountFeatureEnrollment"];
        };
      };
    };
  };
  "api_v4_accounts_feature-enrollment_update": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this account feature enrollment. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["AccountFeatureEnrollment"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountFeatureEnrollment"];
        };
      };
    };
  };
  "api_v4_accounts_feature-enrollment_partial_update": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this account feature enrollment. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["AccountFeatureEnrollment"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountFeatureEnrollment"];
        };
      };
    };
  };
  api_v4_accounts_folders_list: {
    parameters: {
      query?: {
        /** @description Filters folders by the saved title. */
        title?: string;
        /** @description Filters folder with a customuser with a first_name, last_name or username matching the provided term. */
        owner?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Folder"][];
          };
        };
      };
    };
  };
  api_v4_accounts_folders_create: {
    parameters: {
      path: {
        account_pk: string;
      };
    };
    requestBody: components["requestBodies"]["Folder"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["Folder"];
        };
      };
    };
  };
  api_v4_accounts_folders_read: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this folder. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Folder"];
        };
      };
    };
  };
  api_v4_accounts_folders_update: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this folder. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Folder"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Folder"];
        };
      };
    };
  };
  api_v4_accounts_folders_delete: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this folder. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  api_v4_accounts_folders_partial_update: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this folder. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Folder"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Folder"];
        };
      };
    };
  };
  "api_v4_accounts_identity-providers_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["IdentityProvider"][];
          };
        };
      };
    };
  };
  /** @description Custom POST method handler to track identity provider creation. */
  "api_v4_accounts_identity-providers_create": {
    parameters: {
      path: {
        account_pk: string;
      };
    };
    requestBody: components["requestBodies"]["IdentityProvider"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["IdentityProvider"];
        };
      };
    };
  };
  "api_v4_accounts_identity-providers_read": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this identity provider. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["IdentityProvider"];
        };
      };
    };
  };
  "api_v4_accounts_identity-providers_update": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this identity provider. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["IdentityProvider"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["IdentityProvider"];
        };
      };
    };
  };
  "api_v4_accounts_identity-providers_delete": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this identity provider. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  "api_v4_accounts_identity-providers_partial_update": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this identity provider. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["IdentityProvider"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["IdentityProvider"];
        };
      };
    };
  };
  "api_v4_accounts_identity-providers_notify_members": {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this identity provider. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["IdentityProvider"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["IdentityProvider"];
        };
      };
    };
  };
  /** @description Separate ViewSet for managing requests from internal approved services */
  api_v4_accounts_internal_offers_campaigns_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
        campaign_id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["CampaignOffer"][];
          };
        };
      };
    };
  };
  /**
   * @description Creating an Offer can only be performed by an approve-listed Service
   * (A call that comes from within Zapier's owned services)
   */
  api_v4_accounts_internal_offers_campaigns_create: {
    parameters: {
      path: {
        account_pk: string;
        campaign_id: string;
      };
    };
    requestBody: components["requestBodies"]["CampaignOffer"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["CampaignOffer"];
        };
      };
    };
  };
  /** @description Separate ViewSet for managing requests from internal approved services */
  api_v4_accounts_internal_offers_campaigns_read: {
    parameters: {
      path: {
        account_pk: string;
        campaign_id: string;
        /** @description A unique integer value identifying this campaign offer. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CampaignOffer"];
        };
      };
    };
  };
  /** @description Separate ViewSet for managing requests from internal approved services */
  api_v4_accounts_internal_offers_campaigns_update: {
    parameters: {
      path: {
        account_pk: string;
        campaign_id: string;
        /** @description A unique integer value identifying this campaign offer. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["CampaignOffer"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CampaignOffer"];
        };
      };
    };
  };
  /** @description Separate ViewSet for managing requests from internal approved services */
  api_v4_accounts_internal_offers_campaigns_delete: {
    parameters: {
      path: {
        account_pk: string;
        campaign_id: string;
        /** @description A unique integer value identifying this campaign offer. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  /** @description Separate ViewSet for managing requests from internal approved services */
  api_v4_accounts_internal_offers_campaigns_partial_update: {
    parameters: {
      path: {
        account_pk: string;
        campaign_id: string;
        /** @description A unique integer value identifying this campaign offer. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["CampaignOffer"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CampaignOffer"];
        };
      };
    };
  };
  api_v4_accounts_invitations_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Invitation"][];
          };
        };
      };
    };
  };
  api_v4_accounts_invitations_create: {
    parameters: {
      path: {
        account_pk: string;
      };
    };
    requestBody: components["requestBodies"]["Invitation"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["Invitation"];
        };
      };
    };
  };
  api_v4_accounts_invitations_read: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this invitation. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Invitation"];
        };
      };
    };
  };
  /** @description Revoke the given invitation */
  api_v4_accounts_invitations_delete: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this invitation. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  /**
   * Resend the given invitation
   * @description If the invitation is visible to the user doing the action,
   * then it will be resent, otherwise a 404 will be returned.
   *
   * If the user is not a admin or owner then a 403 is returned
   *
   * If the user's name is spam then a 400 is returned.
   */
  api_v4_accounts_invitations_resend: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this invitation. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Invitation"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["Invitation"];
        };
      };
    };
  };
  api_v4_accounts_members_list: {
    parameters: {
      query?: {
        /** @description Filters members whose first_name, last_name or username matches the provided term. (will not filter if ids is passed) */
        search?: string;
        /** @description Get members by their ids */
        ids?: string;
        /** @description Filters members by role */
        role?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["FullAccountMember"][];
          };
        };
      };
    };
  };
  api_v4_accounts_members_read: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["FullAccountMember"];
        };
      };
    };
  };
  api_v4_accounts_members_update: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["FullAccountMember"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["FullAccountMember"];
        };
      };
    };
  };
  /** @description Remove the given user from this account */
  api_v4_accounts_members_delete: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  api_v4_accounts_members_partial_update: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["FullAccountMember"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["FullAccountMember"];
        };
      };
    };
  };
  api_v4_accounts_memberships_list: {
    parameters: {
      query?: {
        /** @description Filters teams whose name matches the provided term. */
        search?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["SlimTeamRead"][];
          };
        };
      };
    };
  };
  api_v4_accounts_memberships_read: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SlimTeamRead"];
        };
      };
    };
  };
  api_v4_accounts_offers_create: {
    parameters: {
      path: {
        account_pk: string;
      };
    };
    requestBody: components["requestBodies"]["CampaignOffer"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["CampaignOffer"];
        };
      };
    };
  };
  api_v4_accounts_offers_read: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this campaign offer. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CampaignOffer"];
        };
      };
    };
  };
  api_v4_accounts_offers_update: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this campaign offer. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["CampaignOffer"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CampaignOffer"];
        };
      };
    };
  };
  api_v4_accounts_offers_partial_update: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this campaign offer. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["CampaignOffer"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CampaignOffer"];
        };
      };
    };
  };
  /** @description API for configuring user provisioning */
  api_v4_accounts_provision_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["AccountProvision"][];
          };
        };
      };
    };
  };
  /** @description Custom POST method handler to track account provision creation. */
  api_v4_accounts_provision_create: {
    parameters: {
      path: {
        account_pk: string;
      };
    };
    requestBody: components["requestBodies"]["AccountProvision"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["AccountProvision"];
        };
      };
    };
  };
  /** @description API for configuring user provisioning */
  api_v4_accounts_provision_read: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this account provision. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountProvision"];
        };
      };
    };
  };
  /** @description API for configuring user provisioning */
  api_v4_accounts_provision_update: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this account provision. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["AccountProvision"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountProvision"];
        };
      };
    };
  };
  /** @description API for configuring user provisioning */
  api_v4_accounts_provision_delete: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this account provision. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  /** @description API for configuring user provisioning */
  api_v4_accounts_provision_partial_update: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this account provision. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["AccountProvision"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountProvision"];
        };
      };
    };
  };
  /** @description Refresh the token of the underlying provision instance */
  api_v4_accounts_provision_refresh_token: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this account provision. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["AccountProvision"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["AccountProvision"];
        };
      };
    };
  };
  api_v4_accounts_teams_list: {
    parameters: {
      query?: {
        /** @description Filters teams whose name matches the provided term. */
        search?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["TeamRead"][];
          };
        };
      };
    };
  };
  /**
   * @description Overwrite create method so that we can ensure schema generation
   * with the appropriate serializer.
   */
  api_v4_accounts_teams_create: {
    parameters: {
      path: {
        account_pk: string;
      };
    };
    requestBody: components["requestBodies"]["TeamWrite"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["TeamRead"];
        };
      };
    };
  };
  api_v4_accounts_teams_read: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TeamRead"];
        };
      };
    };
  };
  /**
   * @description Overwrite update method so that we can ensure schema generation
   * with the appropriate serializer.
   */
  api_v4_accounts_teams_update: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["TeamWrite"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TeamRead"];
        };
      };
    };
  };
  api_v4_accounts_teams_delete: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  /**
   * @description Overwrite partial_update method so that we can ensure schema generation
   * with the appropriate serializer.
   */
  api_v4_accounts_teams_partial_update: {
    parameters: {
      path: {
        account_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["TeamWrite"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TeamRead"];
        };
      };
    };
  };
  api_v4_accounts_teams_members_list: {
    parameters: {
      query?: {
        /** @description Filters team members whose first_name, last_name or username matches the provided term. */
        search?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
        team_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["TeamMemberRead"][];
          };
        };
      };
    };
  };
  /**
   * @description Overwrite create method so that we can ensure schema generation
   * with the appropriate serializer.
   */
  api_v4_accounts_teams_members_create: {
    parameters: {
      path: {
        account_pk: string;
        team_pk: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TeamMemberWrite"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["TeamMemberRead"];
        };
      };
    };
  };
  api_v4_accounts_teams_members_read: {
    parameters: {
      path: {
        account_pk: string;
        team_pk: string;
        /** @description A unique integer value identifying this team member. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TeamMemberRead"];
        };
      };
    };
  };
  /**
   * Remove the authenticated user from this team
   * @description You can remove yourself from a team as long as you
   * are not the team owner. If you are the team owner,
   * transfer the team to someone else before leaving.
   */
  api_v4_accounts_teams_members_delete: {
    parameters: {
      path: {
        account_pk: string;
        team_pk: string;
        /** @description A unique integer value identifying this team member. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  api_v4_accounts_teams_requests_list: {
    parameters: {
      query?: {
        /** @description Filters team member requests where the requestor's first_name, last_name or username matches the provided term. */
        search?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        account_pk: string;
        team_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["TeamRequest"][];
          };
        };
      };
    };
  };
  api_v4_accounts_teams_requests_create: {
    parameters: {
      path: {
        account_pk: string;
        team_pk: string;
      };
    };
    requestBody: components["requestBodies"]["TeamRequestWrite"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["TeamRequest"];
        };
      };
    };
  };
  api_v4_accounts_teams_requests_read: {
    parameters: {
      path: {
        account_pk: string;
        team_pk: string;
        /** @description A unique integer value identifying this team request. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TeamRequest"];
        };
      };
    };
  };
  api_v4_accounts_teams_requests_update: {
    parameters: {
      path: {
        account_pk: string;
        team_pk: string;
        /** @description A unique integer value identifying this team request. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["TeamRequestWrite"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TeamRequest"];
        };
      };
    };
  };
  api_v4_accounts_teams_requests_partial_update: {
    parameters: {
      path: {
        account_pk: string;
        team_pk: string;
        /** @description A unique integer value identifying this team request. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["TeamRequestWrite"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TeamRequest"];
        };
      };
    };
  };
  /** @description Return a list of virtual folders. */
  "api_v4_accounts_virtual-folders_list": {
    parameters: {
      path: {
        account_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["VirtualFolder"];
        };
      };
    };
  };
  "api_v4_accounts_virtual-folders_read": {
    parameters: {
      path: {
        account_pk: string;
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["VirtualFolder"];
        };
      };
    };
  };
  api_v4_accounts_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["BillingAccount"];
        };
      };
    };
  };
  api_v4_accounts_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["BillingAccount"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["BillingAccount"];
        };
      };
    };
  };
  api_v4_accounts_partial_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["BillingAccount"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["BillingAccount"];
        };
      };
    };
  };
  api_v4_accounts_get_app_stats: {
    parameters: {
      query: {
        /** @description Return stats for specific selected_apis (comma-separated list) */
        selected_apis: string;
      };
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountAppStatsResponse"][];
        };
      };
    };
  };
  /**
   * @description Return a list of serialized discounts that have been applied
   * to an account.
   */
  api_v4_accounts_discounts: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Discount"][];
        };
      };
    };
  };
  /** @description Return a list of entitlements for the account. */
  api_v4_accounts_entitlements: {
    parameters: {
      query?: {
        /** @description A comma-separated list of fields to retrieve in the response. Defaults to all fields. */
        fields?: string;
      };
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountEntitlements"];
        };
      };
    };
  };
  /**
   * @description Implements join functionality for domain members who meet the
   * criteria for joining their organization's company account.
   */
  api_v4_accounts_join: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["BillingAccount"];
        };
      };
    };
  };
  /** @description Opt-in to metered pricing for the account. */
  api_v4_accounts_metered_pricing_opt_in: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["BillingAccount"];
        };
      };
    };
  };
  api_v4_accounts_set_policy: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AccountAccessPolicy"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["BillingAccount"];
        };
      };
    };
  };
  /**
   * @description Opt-in to faster polling interval for the account, after it has been
   * migrated to a higher plan.
   */
  api_v4_accounts_polling_interval_opt_in: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["BillingAccount"];
        };
      };
    };
  };
  /** @description Get private apps in use by an account and data about them. */
  api_v4_accounts_get_private_apps: {
    parameters: {
      query?: {
        /** @description Return apps whose title matches the provided string */
        title?: string;
        /** @description Return apps with specific selected_apis (comma-separated list) */
        selected_apis?: string;
        /** @description The number of results to include in the response */
        limit?: number;
        /** @description The number of results to offset the response by */
        offset?: number;
      };
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountPrivateAppsResponse"][];
        };
      };
    };
  };
  /** @description Get public apps in use by an account and data about them. */
  api_v4_accounts_get_public_apps: {
    parameters: {
      query?: {
        /** @description Return apps in use by a particular customuser id; currently limited to the requesting user */
        owner?: number;
        /** @description Return only apps whose auths have been shared with the requesting user */
        is_shared?: boolean;
        /** @description Return apps whose title matches the provided string */
        title?: string;
        /** @description The number of results to include in the response */
        limit?: number;
        /** @description The number of results to offset the response by */
        offset?: number;
      };
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountAppsResponse"][];
        };
      };
    };
  };
  /** @description Recommend a plan based on the role/industry of the account owner */
  api_v4_accounts_recommend_plan: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountPlanRecommendation"];
        };
      };
    };
  };
  api_v4_accounts_recommended_services: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ThinService"];
        };
      };
    };
  };
  api_v4_accounts_recommended_zap_templates: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ThinGuidedRecipe"];
        };
      };
    };
  };
  api_v4_accounts_modify_subscription: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AccountModifySubscription"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountModifySubscription"];
        };
      };
    };
  };
  /**
   * Get the task usage for the current account and specified facets
   * @description The facets can be specified via query params. Multiple facets can
   * be used in tandem, and they will all be taken in account when generating
   * the aggregation. That is, passing both `folder_id` and `app` means that
   * the aggregation will be done on the tasks belonging to Zaps that are
   * in the given folder and use the said app.
   *
   * The following facets are supported:
   *
   * * `customuser_id`
   *    Generate the task usage for the given customuser. The current user needs
   *    to be an account member to be able to view the tasks of a different
   *    member.
   *
   * * `folder_id`
   *    Generate the task usage for the Zaps found in the given folder ID
   *
   * * `app`
   *    Generate the task usage for the Zaps using this app
   *
   * * `customuser_ids`
   *    Like `customuser_id`, but looks for Zaps owned by any of the
   *    specified customusers.
   *
   * * `folder_ids`
   *    Like `folder_id`, but looks for Zaps in any of the specified folders
   *
   * * `kinds`
   *   Look for Zaps of any of the specified kinds (workflow, transfer, etc.)
   *
   * * `root_ids`
   *    Only looks for Zaps with these ids
   *
   * * `selected_apis`
   *    Like `app`, but looks for Zaps with any of the specified
   *    apps/selected_api values.
   *
   * * `period_start` and `period_end`
   *
   *   Generate the task usage between the specified period.
   *   These dates should be in ISO-8601 format, e.g .` YYYY-MM-DDTHH:MM:SS.mmmmmm`, but we also
   *   support the following variation `YYYY-MM-DD`.
   *   The dates will be converted to the timezone of the user doing the action.
   *
   *   If the difference between `period_start` and `period_end` is large enough, the aggregations
   *   will be done for each individual month between the start and the end. Otherwise daily
   *   aggregations will be computed.
   *
   * The endpoint will return a dictionary of stats, having the following structure:
   *
   * * `interval`: Whether the aggregation buckets in `tasks_breakdown` are `daily`
   *    or `monthly`
   * * `total_tasks_count`: The total number of tasks in the given period
   * * `billable_tasks_count`: The total number of billable tasks in the given period
   * * `tasks_breakdown`
   *    A per date breakdown for the tasks. Each entry will be a dictionary mapping
   *    from a date to a list of status counts for that day / month.
   *    The task breakdown is either per day or per month, depending how big the
   *    gap between `period_start` and `period_end` is.
   * * `status_aggregation`: A dictionary of task statuses to counts
   *
   *         {
   *             "total_tasks_count": <int>
   *             "status_aggregation": {
   *                 "status": <int>,
   *                 ...
   *             },
   *             "tasks_breakdown": {
   *                 "<day>": {
   *                     "status":  <int>
   *                 },
   *                 ...
   *             }
   *         }
   */
  api_v4_accounts_get_task_usage: {
    parameters: {
      query?: {
        folder_id?: number;
        customuser_id?: number;
        app?: string;
        period_start?: string;
        period_end?: string;
        /** @description Comma-separated list of customuser_id values */
        customuser_ids?: number[];
        /** @description Comma-separated list of folder_id values */
        folder_ids?: number[];
        /** @description Comma-separated list of Zap kind values */
        kinds?: ("workflow" | "transfer")[];
        /** @description Comma-separated list of Zap node id values */
        root_ids?: number[];
        /** @description Comma-separated list of selected_api values */
        selected_apis?: string[];
      };
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TaskUsageResponse"];
        };
      };
    };
  };
  api_v4_accounts_top_users: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountTopUser"];
        };
      };
    };
  };
  /**
   * Get the top Zaps for the current account and specified facets
   * @description This view powers up parts of the usage dashboard.
   * The facets can be specified via query params. Multiple facets can
   * be used in tandem, and they will all be taken in account when generating
   * the top Zaps. That is, passing both `folder_id` and `app` means that
   * the aggregation will be done on the tasks belonging of Zaps that are
   * in the given folder and use the said app.
   *
   * The following facets are supported:
   *
   * * `customuser_id`
   *
   *    Find the top Zaps for the given customuser. The current user needs
   *    to be an account member to be able to view the tasks of a different
   *    member.
   *
   * * `folder_id`
   *
   *    Order the Zaps found in `folder_id` by their usage.
   *
   * * `app`
   *
   *    Find the top Zaps that use this app
   *
   * * `period_start` and `period_end`
   *
   *    Find the top Zaps between the specified period.
   *    These dates should be in ISO-8601 format, e.g .` YYYY-MM-DDTHH:MM:SS.mmmmmm`, but we also
   *    support the following variation `YYYY-MM-DD`.
   *    The dates will be converted to the timezone of the user doing the action.
   *
   * * `customuser_ids`
   *
   *    Like `customuser_id`, but looks for Zaps owned by any of the
   *    specified customusers.
   *
   * * `folder_ids`
   *
   *    Like `folder_id`, but looks for Zaps in any of the specified
   *    folders.
   *
   * * `kinds`
   *
   *    Look for Zaps of any of the specified kinds (workflow, transfer, etc.)
   *
   * * `root_ids`
   *
   *    Only looks for Zaps with these ids
   *
   * * `selected_apis`
   *
   *    Like `app`, but looks for Zaps with any of the specified
   *    apps/selected_api values.
   */
  api_v4_accounts_get_top_zaps: {
    parameters: {
      query?: {
        folder_id?: number;
        customuser_id?: number;
        app?: string;
        period_start?: string;
        period_end?: string;
        /** @description Comma-separated list of customuser_id values */
        customuser_ids?: number[];
        /** @description Comma-separated list of folder_id values */
        folder_ids?: number[];
        /** @description Comma-separated list of Zap kind values */
        kinds?: ("workflow" | "transfer")[];
        /** @description Comma-separated list of Zap node id values */
        root_ids?: number[];
        /** @description Comma-separated list of selected_api values */
        selected_apis?: string[];
      };
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TopZaps"];
        };
      };
    };
  };
  /** @description Get trial statistics report for the current account */
  api_v4_accounts_trial_report: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountTrialReport"];
        };
      };
    };
  };
  /** @description Get the zap usage for the current account */
  api_v4_accounts_usage: {
    parameters: {
      query?: {
        timeframe?: "day" | "month" | "quarter" | "year";
      };
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountUsage"];
        };
      };
    };
  };
  /** @description The endpoint for updating action controls. */
  api_v4_actions_controls: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ActionControlsRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ActionControlsResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ActionBaseResponse"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
    };
  };
  api_v4_actions_read: {
    parameters: {
      path: {
        var: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ImplementationMeta"];
        };
      };
    };
  };
  "api_v4_app-directory_categories_list": {
    parameters: {
      query?: {
        slug?: string;
        /** @description A comma separated list of slugs to filter the list of Category objects by. */
        slugs?: string;
        /** @description A comma separated list of ids to filter the list of Category objects by. */
        ids?: string;
        /** @description Specifies what role the categories should be. Defaults to "parent". */
        role?: "parent" | "child" | "all";
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["service_category"][];
          };
        };
      };
    };
  };
  "api_v4_app-directory_categories_read": {
    parameters: {
      path: {
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["service_category"];
        };
      };
    };
  };
  /** @description Returns all of the apps associated with this child apps of this category. */
  "api_v4_app-directory_categories_apps": {
    parameters: {
      query?: {
        /** @description The canonical ID(s). Multiple canonical IDs can be provided by including multiple `canonical_id` query parameters. */
        canonical_id?: string;
        /** @description Specify whether to exclude upcoming apps. */
        exclude_upcoming?: string;
        /** @description A search query against the title. */
        title_search?: string;
        /** @description Find services whose title starts with the search string */
        title_starts_with?: string;
        /** @description The slug of the related category to filter against. */
        category?: string;
        /** @description The slug of the featured category to return apps for. */
        featured_category_slug?: string;
        /** @description Specifies if a service is built-in. */
        is_built_in?: string;
        /** @description A comma separated list of app slugs to exclude. */
        exclude_slugs?: string;
        /** @description The slug of the paired category to return apps for. */
        paired_category_slug?: string;
        /** @description Comma separated list of selected APIs to filter for. */
        selected_apis?: string;
        /** @description Toggles the inclusion of services where the authenticated user is associated with an app as an admin */
        including_is_app_admin?: boolean;
        /** @description Toggles the inclusion of services where the authenticated user is associated with an app as a collaborator */
        including_is_app_collaborator?: boolean;
        /** @description The slug of the related noun to filter against. */
        noun?: string;
        /** @description A service slug that restricts results to other apps that are in Zap Templates with it. */
        is_in_zap_template_with?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PaginatedAppList"][];
        };
      };
    };
  };
  "api_v4_app-directory_categories_children": {
    parameters: {
      path: {
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["service_category"];
        };
      };
    };
  };
  api_v4_appextensions_proxy_read: {
    parameters: {
      path: {
        which_endpoint: string;
        entry_id: string;
        subpath: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  api_v4_appextensions_proxy_update: {
    parameters: {
      path: {
        which_endpoint: string;
        entry_id: string;
        subpath: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  api_v4_appextensions_proxy_create: {
    parameters: {
      path: {
        which_endpoint: string;
        entry_id: string;
        subpath: string;
      };
    };
    responses: {
      201: {
        content: never;
      };
    };
  };
  api_v4_appextensions_proxy_delete: {
    parameters: {
      path: {
        which_endpoint: string;
        entry_id: string;
        subpath: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  api_v4_appextensions_proxy_partial_update: {
    parameters: {
      path: {
        which_endpoint: string;
        entry_id: string;
        subpath: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  api_v4_apps_list: {
    parameters: {
      query?: {
        /** @description The canonical ID(s). Multiple canonical IDs can be provided by including multiple `canonical_id` query parameters. */
        canonical_id?: string;
        /** @description Specify whether to exclude upcoming apps. */
        exclude_upcoming?: string;
        /** @description A search query against the title. */
        title_search?: string;
        /** @description Find services whose title starts with the search string */
        title_starts_with?: string;
        /** @description The slug of the related category to filter against. */
        category?: string;
        /** @description The slug of the featured category to return apps for. */
        featured_category_slug?: string;
        /** @description Specifies if a service is built-in. */
        is_built_in?: string;
        /** @description A comma separated list of app slugs to exclude. */
        exclude_slugs?: string;
        /** @description The slug of the paired category to return apps for. */
        paired_category_slug?: string;
        /** @description Comma separated list of selected APIs to filter for. */
        selected_apis?: string;
        /** @description Toggles the inclusion of services where the authenticated user is associated with an app as an admin */
        including_is_app_admin?: boolean;
        /** @description Toggles the inclusion of services where the authenticated user is associated with an app as a collaborator */
        including_is_app_collaborator?: boolean;
        /** @description The slug of the related noun to filter against. */
        noun?: string;
        /** @description A service slug that restricts results to other apps that are in Zap Templates with it. */
        is_in_zap_template_with?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["App"][];
          };
        };
      };
    };
  };
  "api_v4_apps_discover-zap-templates_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        app_slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["DiscoverZapTemplates"][];
          };
        };
      };
    };
  };
  "api_v4_apps_discover-zap-templates_read": {
    parameters: {
      path: {
        app_slug: string;
        /** @description A unique integer value identifying this discovery page. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["DiscoverZapTemplates"];
        };
      };
    };
  };
  api_v4_apps_read: {
    parameters: {
      path: {
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["App"];
        };
      };
    };
  };
  /**
   * @description Check if a service exists, return 404 if it doesn't
   * If an app exists, return simple service data without querying category
   */
  api_v4_apps_exist: {
    parameters: {
      path: {
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["App"];
        };
      };
    };
  };
  /**
   * List Authentications
   * @description List all authentications visible to the user.
   */
  api_v4_authentications_list: {
    parameters: {
      query?: {
        /** @description Filter authentications by the given account id. */
        account_id?: string;
        /** @description Filter authentications by the given owner. A predefined `me` filter is also supported, which will filter the Authentications owned by the current logged in user. */
        owner?: string;
        /** @description Filter authentications by the given Service. */
        service_slug?: string;
        /** @description Filter authentications by the given selected_api. */
        selected_api?: string;
        /** @description Get authentications by their ids. */
        ids?: string;
        /** @description Include authentications with destination_selected_api (Consumer Gmail secondary authentication). Default is true. */
        include_destination_selected_api?: boolean;
        /** @description Exclude authentications that are not usable by the current logged in user. By default, all authentications are returned if requested by an admin/owner user, so set this to true if you want auths that they can use. Default is false. */
        exclude_unusable?: boolean;
        /** @description Retrieve all accessable auths across all versions that match the provided versionless selected api. */
        versionless_selected_api?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Authentication"][];
          };
        };
      };
    };
  };
  /**
   * Create Authentication
   * @description Allows the creation of Authentication objects directly; only feasibly
   * used by the Public API as partners are the ones who hold their users'
   * access tokens.
   */
  api_v4_authentications_create_auth: {
    requestBody: components["requestBodies"]["Authentication"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["Authentication"];
        };
      };
    };
  };
  /**
   * Counts of Authentications API
   * @description When provided a list of customuser_ids, returns a list of objects showing how many
   * authentication records each user has.
   *
   * POST a list of customuser_ids in a JSON body to fetch the list of counts for those users.
   * Any user not found will be returned in the response with an auth count of 0
   *
   * To limit the scope of the lookup to a single account, it must be passed in using the
   * `account_id` in the query string
   */
  "api_v4_authentications_user-count_list": {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AuthCustomUserCountRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AuthCustomUserCountResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["AuthCustomUserCountResponse"];
        };
      };
    };
  };
  /**
   * List visible authentication ids and how many Zaps use them
   * @description Lists the authentications visible to the calling user and how many Zaps
   * use each of them.
   */
  "api_v4_authentications_zap-count_list": {
    parameters: {
      query?: {
        /** @description A selected_api to filter the list of Authentications to. */
        selected_api?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AuthZapCountResponse"][];
        };
      };
    };
  };
  /** @description API for accessing the members with which auths have been shared */
  api_v4_authentications_members_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        authentication_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["SharedAuthenticationMember"][];
          };
        };
      };
    };
  };
  /**
   * @description Share the authentication with the given customuser.
   *
   *             The authentication can be shared with the given customuser
   *             only if the user that does the action is the authentication's owner.
   */
  api_v4_authentications_members_create: {
    parameters: {
      path: {
        authentication_pk: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SharedAuthenticationMember"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["SharedAuthenticationMember"];
        };
      };
    };
  };
  /** @description API for accessing the members with which auths have been shared */
  api_v4_authentications_members_read: {
    parameters: {
      path: {
        authentication_pk: string;
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SharedAuthenticationMember"];
        };
      };
    };
  };
  /**
   * Unshare the authentication from the given customuser
   * @description The authentication can be unshared with the given customuser
   * only if the user that does the action can see the authentication.
   * The current owner of the authentication cannot be removed.
   */
  api_v4_authentications_members_delete: {
    parameters: {
      path: {
        authentication_pk: string;
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  /** @description API for accessing the teams with which auths have been shared */
  api_v4_authentications_teams_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        authentication_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["TeamAuthenticationMember"][];
          };
        };
      };
    };
  };
  /**
   * Share the authentication with a team ID or with all team members
   * @description Only the authentication's owner can share an authentication.
   *
   * This API expects a `team_id` parameter sent as a payload, in the form
   * `{team_id: id|`all`}`
   *
   * If it is sent as an `id`, it needs to be the ID of an already existing team.
   * That team will be able to see this authentication.
   * If it is sent as `all`, then the authentication will be shared with all
   * team account members. A fake payload will be returned in that case, as
   * there is no team that encompasses all the team members other than the magic
   * `all` variable.
   */
  api_v4_authentications_teams_create: {
    parameters: {
      path: {
        authentication_pk: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TeamAuthenticationMember"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["TeamAuthenticationMember"];
        };
      };
    };
  };
  /** @description API for accessing the teams with which auths have been shared */
  api_v4_authentications_teams_read: {
    parameters: {
      path: {
        authentication_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TeamAuthenticationMember"];
        };
      };
    };
  };
  /**
   * Unshare the given authentication from the given team
   * @description The authentication can be unshared from a team, if the URL has a
   * team ID, or can be unshared from everyone in the team account,
   * if the URL uses the special `all` ID.
   *
   * `all` represents all users in a team account, which is separate
   * than all the members in a team workspace. When doing the operation
   * against `all`, `shared_with_all` flag is set to `False`. We will still
   * keep memberships for members and teams around, those won't be destroyed
   * unless manually removed or if the authentication is completely unshared.
   * When passing `all`, the user that did the action will be added to the list
   * of members that can access the authentication.
   *
   * If `all` is not used, but instead a proper team ID is used, that team will
   * no longer have access to access this authentication.
   */
  api_v4_authentications_teams_delete: {
    parameters: {
      path: {
        authentication_pk: string;
        /** @description A unique integer value identifying this team. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  /**
   * Retrieve Authentication
   * @description Retrieve a specific authentication if visible to the user.
   */
  api_v4_authentications_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this authentication. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Authentication"];
        };
      };
    };
  };
  api_v4_authentications_delete: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this authentication. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  api_v4_authentications_partial_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this authentication. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Authentication"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Authentication"];
        };
      };
    };
  };
  /**
   * Call Authentication's API
   * @deprecated
   * @description Call the API behind the authentications, if visible to the user.
   *
   * This endpoint is deprecated. You should use the new Conjurer service https://docs.k8s.zapier.com/conjurer/
   */
  api_v4_authentications_call: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this authentication. */
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AuthCallRequest"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["AuthCallRequest"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["AuthCallResponse"];
        };
      };
    };
  };
  api_v4_authentications_data: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this authentication. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Authentication"];
        };
      };
    };
  };
  /**
   * Mildly dangerous endpoint! Authentication is only via JWT, issued by the Notary service.
   * @description Returns Authentication IDs based on the passed in Trigger Susbcription ID or combination of
   * customuser id, account id, and selected api.
   */
  api_v4_authentications_search: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this authentication. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Authentication"];
        };
      };
    };
  };
  /**
   * Test the Authentication against it's API to make sure it has been set up correctly and is
   * still valid.
   * @description If the test fails due to a `StaleAuthentication` error then the authentication is marked stale
   * without alerting (no email is sent).
   */
  api_v4_authentications_test: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this authentication. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Authentication"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["Authentication"];
        };
      };
    };
  };
  "api_v4_blog-posts_list": {
    parameters: {
      query?: {
        /** @description A comma separated list of category slugs to filter the list of blog posts by */
        category_slugs?: string;
        /** @description Filters by the related services slug. */
        service_slug?: string;
        /** @description Filters by the blog model's slug */
        blog_slug?: string;
        /** @description The slug of the related category to filter against. */
        category_slug?: string;
        /** @description If `true`, only featured blog posts will be returned. */
        is_featured?: string;
        /** @description The slug of the canonical category to filter against. */
        canonical_category_slug?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["BlogPost"][];
          };
        };
      };
    };
  };
  "api_v4_blog-posts_read": {
    parameters: {
      path: {
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["BlogPost"];
        };
      };
    };
  };
  api_v4_blogs_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Blog"][];
          };
        };
      };
    };
  };
  api_v4_blogs_read: {
    parameters: {
      path: {
        /** @description This will be the URL for the blog. Ex.: `engineering` will be accessible at zapier.com/engineering/ */
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Blog"];
        };
      };
    };
  };
  api_v4_categories_list: {
    parameters: {
      query?: {
        slug?: string;
        /** @description A comma separated list of slugs to filter the list of Category objects by. */
        slugs?: string;
        /** @description A comma separated list of ids to filter the list of Category objects by. */
        ids?: string;
        /** @description Specifies what role the categories should be. Defaults to "parent". */
        role?: "parent" | "child" | "all";
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["service_category"][];
          };
        };
      };
    };
  };
  api_v4_categories_read: {
    parameters: {
      path: {
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["service_category"];
        };
      };
    };
  };
  api_v4_categories_children: {
    parameters: {
      path: {
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["service_category"];
        };
      };
    };
  };
  api_v4_communicate_ingest_looker_enqueue_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  api_v4_communicate_subscriptions_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  api_v4_communicate_sync_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  api_v4_communicate_sync_delete: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  api_v4_communicate_unsubscribe_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  api_v4_communicate_unsubscriptions_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  /** @description Retrieve User's blog subscription */
  api_v4_communicate_users_subscribedtoblog_read: {
    parameters: {
      path: {
        identity: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * Start an authentication confirm flow
   * @description This flow asks the user to authenticate in order to confirm them
   * before getting access to a particular feature or action of the product.
   *
   * For instance transfer membership or deleting an account would be the
   * focus of this confirmation flow, in which the user can use either
   * normal username / password combo, Google SSO or any other form of SSO,
   * SAML SSO etc.
   */
  "api_v4_confirm-authentication_create": {
    responses: {
      201: {
        content: never;
      };
    };
  };
  /** @description Confirm whether the current session is a masquerade session. */
  "api_v4_confirm-masquerade_list": {
    responses: {
      200: {
        content: never;
      };
    };
  };
  api_v4_currencies_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: Record<string, never>[];
          };
        };
      };
    };
  };
  api_v4_currencies_rates: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: Record<string, never>[];
          };
        };
      };
    };
  };
  /**
   * @description Instantiates `selected_api` and calls its `revalidate_data_flow()`
   * method on every item inside `destination_selected_apis`.
   *
   * Will also check if every `destination_selected_api` points to an existing
   * implementation.
   */
  "api_v4_data-flow_data_flow_check": {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["DataFlowCheckResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["DataFlowCheckResponse"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["DataFlowCheckResponse"];
        };
      };
      422: {
        content: {
          "application/json": components["schemas"]["DataFlowCheckResponse"];
        };
      };
    };
  };
  /** @description These endpoints help us trigger errors and test alerting in API clients. */
  api_v4_debug_list: {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /** @description These endpoints help us trigger errors and test alerting in API clients. */
  api_v4_debug_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  /** @description These endpoints help us trigger errors and test alerting in API clients. */
  api_v4_debug_read: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  /** @description These endpoints help us trigger errors and test alerting in API clients. */
  api_v4_debug_update: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  /** @description These endpoints help us trigger errors and test alerting in API clients. */
  api_v4_debug_delete: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  /** @description These endpoints help us trigger errors and test alerting in API clients. */
  api_v4_debug_partial_update: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * @description Check if an email's domain is associated with a Company account that is eligible for domain capture.
   * Accepted parameters: email (string), code (string) - optional
   *
   * Returns an object with the account details if an account with that verified domain is found
   * and the customuser_id if a user with that email exists.
   */
  "api_v4_domain-discovery_list": {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /** @description Send the error alert email to the user based on the user context provided within a Service JWT. */
  "api_v4_error-notifications_send_alert_email": {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TriggerAlertEmailBody"];
      };
    };
    responses: {
      202: {
        content: {
          "application/json": components["schemas"]["TriggerAlertEmailResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ErrorNotificationsError"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ErrorNotificationsError"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["ErrorNotificationsError"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ErrorNotificationsError"];
        };
      };
    };
  };
  /** @description Checks if a user has vibility to Zap */
  "api_v4_error-notifications_get_zap_visibility": {
    parameters: {
      path: {
        zap_id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ZapVisibilityCheckResponse"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ErrorNotificationsError"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["ErrorNotificationsError"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ErrorNotificationsError"];
        };
      };
    };
  };
  /**
   * Discover the account a folder is in if the user has access to that folder
   * @description Returns the `account_id` where the folder can be found.
   */
  "api_v4_folder-discovery_read": {
    parameters: {
      path: {
        /** @description A unique integer value identifying this folder. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
    };
  };
  "api_v4_followed-apps_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["FollowedApp"][];
          };
        };
      };
    };
  };
  /** @description Creates a random (for now) account */
  api_v4_generator_create: {
    requestBody?: {
      content: {
        "application/json": {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      201: {
        content: never;
      };
    };
  };
  "api_v4_guided-recipes_list": {
    parameters: {
      query?: {
        /** @description The canonical ID(s). Multiple canonical IDs can be provided by including multiple `canonical_id` query parameters. */
        canonical_id?: string;
        /** @description The id of the user who authored the content. */
        added_by_id?: string;
        /** @description A comma separated list of categories slugs to filter by. It accepts a `-` prefix to denote a category exclusion (e.g., "communication, -email"). */
        categories?: string;
        /** @description Filters Guided Recipes by minimum number of services */
        min_service_count?: string;
        /** @description A comma separated list of service slugs to filter by. */
        service_slugs?: string;
        /** @description A comma separated list of service selected APIs to filter by. */
        service_keys?: string;
        /** @description Indicates if you want to match services specified by `service_keys` or `service_slugs`, or both. */
        must_match_all_services?: string;
        /** @description Specifies the status of a GuidedRecipe. Choices are: rejected, draft, community, shared, published, invalid, for-review */
        status?: string;
        /** @description A comma separated list of ids to filter the list of GuidedRecipe objects by. */
        ids?: string;
        /** @description Specifies if unpublished GuidedRecipes should be included. Only works for authed users. */
        include_unpublished?: string;
        /**
         * @description The ranking schema to order results by. The name is preceded by `algorithm-` e.g. `order_by=algorithm-for-beginners` uses the `for-beginners` schema. Can be paired with `personalized=true` to filter down to results ranked by specified ranking schema but sort them for particular authenticated user. Available algorithms are: `anonymous-sorting`, `default`, `for-beginners`, `no-auth`, `role-20`, `role-21`, `role-22`, `role-23`, `role-24`, `role-25`, `role-26`, `role-27`, `role-28`, `role-29`, `role-30`, `role-31`, `role-32`, `role-33`, `role-34`, `role-35`, `role-36`, `role-37`, `role-38`.
         *
         * It is also possible to order the results by `lastchanged` field. This is a protected param and requires an API key to be passed in the header.
         */
        order_by?: string;
        /** @description Boolean value used in conjunction with order_by=algorithm-*, to allow ranking schema to filter and sort the apps followed by the user to the front, followed by those not followed, within each group (followed and not), results are ordered by the ranking schema. */
        personalized?: string;
        /** @description Boolean value used in conjunction with order_by=algorithm-*. Specifies whether to filter results to show only the ranked results (exclude_unranked=True) or to show both unranked results in the responseas well (exclude_unranked=False). Unranked results will rank after any ranked results. */
        exclude_unranked?: string;
        /** @description The selected_api of the guided recipe's head service */
        head_service_selected_api?: string;
        /** @description The selected_api of the guided recipe's tail service */
        tail_service_selected_api?: string;
        /** @description The action of the head service. */
        head_action?: string;
        /** @description The action of the tail service. */
        tail_action?: string;
        /** @description Filters by GuidedRecipes changed after a given date. Year should be given in iso-8601 format, example 2023-06-03 10:15:30Z. (requires authorization) */
        lastchanged_after?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["GuidedRecipe"][];
          };
        };
      };
    };
  };
  "api_v4_guided-recipes_read": {
    parameters: {
      path: {
        /** @description A unique integer value identifying this Guided Zap. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GuidedRecipe"];
        };
      };
    };
  };
  /** @description Return a list of app_action values for a given Service ID. */
  api_v4_helpdocs_autocomplete_list: {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * @description View that provides all matching ``helpdocs.models.Generic`` based
   * on the context passed into the query parameters, order by relevancy.
   *
   * These params are supported:
   *
   * * app:           an app's selected_api
   * * app_action:    the key of a particular action (e.g. new_card)
   * * action_type:   trigger, action, or search
   * * related_codes: a CSV with codes to get docs for and order them by
   * * limit          maximum number of tutorials to return
   */
  "api_v4_helpdocs_best-troubleshooting_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Generic"][];
          };
        };
      };
    };
  };
  /**
   * @description View that provides all matching ``helpdocs.models.Tutorial`` based
   * on the context passed into the query parameters, order by relevancy.
   *
   * The following are all the valid query parameters it can pass in.
   *
   * * app - The currently selected Service (slug).
   * * app_action - The selected action for the app.
   * * action_type - Is this a trigger, action, or search?
   * * location - What part of the Zap setup this is in (one of
   *     ``helpdocs.constants.EditorLocation``).
   * * limit - Maximum number of tutorials to return.
   */
  "api_v4_helpdocs_best-tutorials_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Tutorial"][];
          };
        };
      };
    };
  };
  /** @description Return the best matching tutorial based on the passed state. */
  api_v4_helpdocs_best_list: {
    responses: {
      200: {
        content: never;
      };
    };
  };
  api_v4_helpdocs_categories_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["help_category"][];
          };
        };
      };
    };
  };
  api_v4_helpdocs_categories_tree: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["help_category"][];
          };
        };
      };
    };
  };
  api_v4_helpdocs_categories_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this category. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["help_category"];
        };
      };
    };
  };
  api_v4_helpdocs_categories_content: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this category. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["help_category"];
        };
      };
    };
  };
  /** @description This view handles requests that used to go to web-ssr to serve pre-Zendesk */
  api_v4_helpdocs_category_redirect_read: {
    parameters: {
      path: {
        category: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * @description View intended to capture traffic that used to go to web-ssr to serve pre-Zendesk
   * helpdocs. Usually the redirect url results in yet another redirect defined in an AWS
   * lambda function. We didn't want to disconnect this traffic to lose thousands of requests
   * per day
   *
   * * slug - The slug of the content to redirect to.
   */
  api_v4_helpdocs_content_redirect_read: {
    parameters: {
      path: {
        slug: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  /** @description Return the first content with matching slug. */
  api_v4_helpdocs_content_read: {
    parameters: {
      path: {
        slug: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  api_v4_helpdocs_faqs_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["FAQ"][];
          };
        };
      };
    };
  };
  api_v4_helpdocs_faqs_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this faq. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["FAQ"];
        };
      };
    };
  };
  api_v4_helpdocs_faqs_suggested: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this faq. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["FAQ"];
        };
      };
    };
  };
  /**
   * @description Create only view for creating feedback on a doc. Must be a logged
   * in user.
   */
  api_v4_helpdocs_feedback_create: {
    requestBody: components["requestBodies"]["Feedback"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["Feedback"];
        };
      };
    };
  };
  /**
   * @description Create only view for creating feedback on a doc. Must be a logged
   * in user.
   */
  api_v4_helpdocs_feedback_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this feedback. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Feedback"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Feedback"];
        };
      };
    };
  };
  /**
   * @description Create only view for creating feedback on a doc. Must be a logged
   * in user.
   */
  api_v4_helpdocs_feedback_partial_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this feedback. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Feedback"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Feedback"];
        };
      };
    };
  };
  api_v4_helpdocs_generics_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Generic"][];
          };
        };
      };
    };
  };
  api_v4_helpdocs_generics_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this generic. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Generic"];
        };
      };
    };
  };
  api_v4_helpdocs_generics_suggested: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this generic. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Generic"];
        };
      };
    };
  };
  /**
   * @description Create only view for creating feedback on a doc. Must be a logged
   * in user.
   */
  api_v4_helpdocs_ratings_create: {
    requestBody: components["requestBodies"]["Feedback"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["Feedback"];
        };
      };
    };
  };
  /**
   * @description Create only view for creating feedback on a doc. Must be a logged
   * in user.
   */
  api_v4_helpdocs_ratings_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this feedback. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Feedback"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Feedback"];
        };
      };
    };
  };
  /**
   * @description Create only view for creating feedback on a doc. Must be a logged
   * in user.
   */
  api_v4_helpdocs_ratings_partial_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this feedback. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Feedback"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Feedback"];
        };
      };
    };
  };
  api_v4_helpdocs_references_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Reference"][];
          };
        };
      };
    };
  };
  api_v4_helpdocs_references_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this reference. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Reference"];
        };
      };
    };
  };
  api_v4_helpdocs_references_suggested: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this reference. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Reference"];
        };
      };
    };
  };
  /**
   * @description Exists solely to provide the suggested action for hyperlinking
   * in the StepSerializer
   */
  api_v4_helpdocs_steps_suggested: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this step. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /** @description View to debug https://zapierorg.atlassian.net/browse/SXP-1229 */
  "api_v4_helpdocs_sxp-1229_list": {
    responses: {
      200: {
        content: never;
      };
    };
  };
  api_v4_helpdocs_troubleshooting_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Troubleshooting"][];
          };
        };
      };
    };
  };
  api_v4_helpdocs_troubleshooting_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this troubleshooting. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Troubleshooting"];
        };
      };
    };
  };
  api_v4_helpdocs_troubleshooting_suggested: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this troubleshooting. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Troubleshooting"];
        };
      };
    };
  };
  api_v4_helpdocs_tutorials_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Tutorial"][];
          };
        };
      };
    };
  };
  api_v4_helpdocs_tutorials_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this tutorial. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Tutorial"];
        };
      };
    };
  };
  api_v4_helpdocs_tutorials_suggested: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this tutorial. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Tutorial"];
        };
      };
    };
  };
  api_v4_helpdocs_videos_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Video"][];
          };
        };
      };
    };
  };
  api_v4_helpdocs_videos_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this video. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Video"];
        };
      };
    };
  };
  "api_v4_i-was-here_list": {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /** @description Displays the identity and authentication status of a user. */
  api_v4_identity_list: {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /** @description Displays the identity and authentication status of a user. */
  api_v4_identity_read: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * Find the proper IDP for a provided email address
   * @description If the email has a domain that we know of, we return the URLs
   * that the user should hit to start the SAML flow.
   */
  "api_v4_idp-discovery_list": {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * It's perferred to use /api/v4/implementations for a list of implementations.
   * @description If you want a list of ONLY public implementations, then you'll want to use
   * /implementations-meta
   */
  "api_v4_implementations-meta_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["ImplementationMeta"][];
          };
        };
      };
    };
  };
  /**
   * Implementation Search
   * @description Provides performant querying for public/private Implementations that the caller
   * has access to. This endpoint returns limited details about the Implementation;
   * additional details can be retrieved from other implementations(-meta) endpoints.
   */
  "api_v4_implementations-meta_get": {
    parameters: {
      query: {
        /** @description The term used when executing search queries. */
        term: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ImplementationMetaSearchResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ImplementationMetaSearchError"];
        };
      };
    };
  };
  /**
   * List Implementation Meta Info for Private Apps
   * @description Retrieve the meta info about private implementations a user has access to. If one of the implementations they own
   * is publicly available, it will appear in this list as well as the public endpoint. This endpoint excludes details
   * about the actions supported; use the implementations endpoint if you need that.
   * Service Tier: 1
   */
  "api_v4_implementations-meta_private": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
        /** @description A comma separated list of selected_apis to filter the list of implementations by */
        selected_apis?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ImplementationMeta"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ImplementationMeta"];
        };
      };
    };
  };
  /**
   * List Implementation Meta Info for Public Apps
   * @description Retrieve the meta info about public implementations. This excludes details about the actions supported; use
   * the implementations endpoint if you need that.
   * By default, returns all records using an efficient query.
   */
  "api_v4_implementations-meta_public": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
        /** @description A comma separated list of selected_apis to filter the list of implementations by */
        selected_apis?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ImplementationMeta"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ImplementationMeta"];
        };
      };
    };
  };
  /**
   * List Implementations
   * @description Retrieve implementations that are visible to the user. There are a few possible usecases:
   *
   *     1. Public and Private Apps - Use `global=true&public_only=false`
   *     2. Only Public Apps - Use `global=true&public_only=true`
   *     3. Only Private Apps - Use `global=false&public_only=false`
   *     4. A subset of Apps - Use the `selected_apis` filter. The global and public_only flags still apply.
   *
   * An empty list is possible if public apps are excluded and the user has no private apps.
   */
  api_v4_implementations_list: {
    parameters: {
      query?: {
        /** @description A comma separated list of selected_apis to filter the list of implementations by. Supports latest implementation lookup by replacing the selected_api version with `@latest` */
        selected_apis?: string;
        /** @description If `true`, include global implementations in addition to private ones. If `false`, show onlyprivate implementations */
        global?: boolean;
        /** @description If `true`, fetch only public (global) implementations. If `false`, follows default behavior the `global` query param. */
        public_only?: boolean;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Implementation"][];
          };
        };
      };
    };
  };
  /**
   * Get the choices for a dynamic dropdown need.
   * @description Either (`action_id` AND `input_field_id`) OR `prefill` must be provided. If all three
   * are provided, prefill lookup via `action_id` and `input_field_id` will take precedence,
   * and the provided `prefill` value in the request will be used as a fallback.
   *
   * E.g. Google sheets has a "new row in spreadsheet" trigger (new_row_notify_hook).
   * One of the pieces of information it **needs** to know to listen for that trigger
   * is the specific spreadsheet. Because the number of spreadsheets a user has for
   * Google sheets is not static it's called a dynamic need. This view will provide
   * the possible choices for that dynamic need by calling out to the partner api
   * for the information. How to populate the choices is determined by the `prefill`
   * string. It'll look something like `"spreadsheet.id.title"` which is split on
   * `"."` to give the action, id key, and label key.
   */
  api_v4_implementations_need_choices: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["NeedChoicesRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["NeedChoicesResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["NeedChoicesResponse"];
        };
      };
    };
  };
  /**
   * Check Implementation Visibility
   * @description Check if the requesting customuser has access to the implementation. Response status codes are used to
   * indicate the result of the check:
   *
   * - `204`: requesting customuser has access to the implementation
   * - `400`: invalid request (missing selected_api)
   * - `403`: requesting customuser does not have access to the implementation
   * - `404`: implementation does not exist
   */
  api_v4_implementations_details_read: {
    parameters: {
      query: {
        /** @description A single selected_api to retrieve details for (does not support `@latest` syntax) */
        selected_api: string;
      };
    };
    responses: {
      /** @description requesting customuser has access to the implementation */
      204: {
        content: never;
      };
      /** @description invalid request (missing selected_api) */
      400: {
        content: never;
      };
      /** @description requesting customuser does not have access to the implementation */
      403: {
        content: never;
      };
      /** @description implementation does not exist */
      404: {
        content: never;
      };
    };
  };
  api_v4_implementations_gives: {
    requestBody: components["requestBodies"]["GivesRequest"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GivesResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["GivesResponse"];
        };
      };
    };
  };
  api_v4_implementations_gives_gives: {
    requestBody: components["requestBodies"]["GivesRequest"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GivesResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["GivesResponse"];
        };
      };
    };
  };
  /**
   * Invoke
   * @description Invokes any action on any app visible to the authenticated user
   *
   * ## Asynchronous Invocation
   *
   * When making an asynchronous invocation, the endpoint will return a
   * `invocation_id` value. This value is a unique identifier that can
   * be used to poll for the results of the invocation.
   *
   * ```python
   * response = requests.post(
   *     url="https://zapier.com/api/v4/implementations/invoke/",
   *     headers={"X-Api-Key": "secret"},
   *     json={
   *         "action": "recipe",
   *         "sync": False,
   *         "type_of": "read",
   *         "selected_api": "App110413CLIAPI@1.0.0",
   *     },
   * )
   *
   * invocation_id = response.json()['invocation_id']
   *
   * response = requests.get(
   *     url=f"https://zapier.com/api/v4/implementations/invoke/{invocation_id}/",
   *     headers={"X-Api-Key": "secret"},
   * )
   * ```
   *
   * Internally, an asynchronous call to this endpoint spawns a celery task. This task handles
   * the actual invocation of the appropriate lambda function for the app, and then stores the
   * response payload, along with some meta data, into S3. Polling for results using the `invocation_id`
   * simply checks if the results exist in S3, and returns them to the caller if they do.
   *
   *
   * ## Synchronous Invocation
   *
   * You can no longer call this endpoint synchronously (unless DEBUG=True), it will respond with a 403 if you try.
   * Please use the Conjurer backed endpoint `/api/v4/implementations/invoke-sync` and see
   * Conjurer docs for more information: https://docs.k8s.zapier.com/conjurer/
   *
   * ## A note about dynamic dropdowns
   * If you are trying to use `/invoke` to fetch options for a dynamic dropdown, you will need to pass along `page=0` in the request body (then `page=1`, `page=2`, etc until you get nothing back or the same set of results as the previous page). Passing along this field will set the `prefill=True` option in meta when we call `read_poll` on the app. This is important to include because many apps change their behavior if they are populating a drop down vs doing a regular poll.
   */
  api_v4_implementations_invoke: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["InvokeRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["InvokeAsyncResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["InvokeAsyncResponse"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["InvokeAsyncResponse"];
        };
      };
      429: {
        content: {
          "application/json": components["schemas"]["InvokeAsyncResponse"];
        };
      };
    };
  };
  api_v4_implementations_invoke_read: {
    parameters: {
      path: {
        invocation_id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["InvokeResponse"];
        };
      };
      202: {
        content: {
          "application/json": components["schemas"]["InvokeAsyncResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["InvokeAsyncResponse"];
        };
      };
      401: {
        content: {
          "application/json": components["schemas"]["InvokeAsyncResponse"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["InvokeAsyncResponse"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["InvokeAsyncResponse"];
        };
      };
    };
  };
  /**
   * Needs for Implementation
   * @description Get the needs for any action on any app visible to the authenticated user.
   *
   * A few specific conditions to keep in mind for authenticated and unauthenticated api:
   *     - if an auth id is passed in and available to the user, all needs will be returned,
   *       including custom needs if the api does not encounter an error
   *     - if an auth id is not passed in, but a legacy_node_id is passed in, an error will be
   *       returned. auth_id is required if the selected api requires authentication
   *     - if neither an auth or a legacy_node_id is passed in, we'll return as much information
   *       as possible (static needs)
   *     - if the endpoint is unauthenticated, we'll return all the needs including custom needs
   *
   * Call repeatedly with extended `params` matching `needs` keys as there could be custom
   * needs in future results.
   *
   * For example, you might have a `needs` with a single `{key: formId, required: true}`
   * need. Subsequent calls to the needs endpoint with `params` of `{formId: 1234}` will
   * likely result in many more needs.
   */
  api_v4_implementations_needs: {
    requestBody: components["requestBodies"]["NeedsRequest"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["NeedsResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["NeedsResponse"];
        };
      };
    };
  };
  /** @description An endpoint to return the public only needs for an API */
  api_v4_implementations_needs_needs: {
    requestBody: components["requestBodies"]["NeedsRequest"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["NeedsResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["NeedsResponse"];
        };
      };
    };
  };
  /** @description This endpoint is used by shopify external app store to initiate the OAuth flow */
  api_v4_integrations_shopify_partner_list: {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * @description We handle the OAuth response from shopify.
   * We do security checks but we currently do not store or do anything with token from this flow
   * Reason - this is implemented to meet the App review requirments only.
   */
  api_v4_integrations_shopify_partner_auth_list: {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /** @description Requested when actions from shopify */
  api_v4_integrations_shopify_partner_gdpr_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  api_v4_internal_accounts_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["InternalAccount"];
        };
      };
    };
  };
  api_v4_internal_accounts_entitlements: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["InternalAccount"];
        };
      };
    };
  };
  api_v4_internal_accounts_usage: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this account. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["InternalAccount"];
        };
      };
    };
  };
  api_v4_internal_recommendations_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  api_v4_internal_users_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["CustomUser"][];
          };
        };
      };
    };
  };
  api_v4_internal_users_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CustomUser"];
        };
      };
    };
  };
  api_v4_internal_users_ab_tests: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CustomUser"];
        };
      };
    };
  };
  api_v4_internal_users_aliases: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CustomUser"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["CustomUser"];
        };
      };
    };
  };
  api_v4_internal_users_implementations: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CustomUser"];
        };
      };
    };
  };
  api_v4_internal_users_is_hellbanned: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CustomUser"];
        };
      };
    };
  };
  api_v4_internal_users_is_high_value: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CustomUser"];
        };
      };
    };
  };
  api_v4_internal_users_mailgun: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CustomUser"];
        };
      };
    };
  };
  api_v4_internal_users_notes: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CustomUser"];
        };
      };
    };
  };
  api_v4_internal_users_zaps: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this custom user. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CustomUser"];
        };
      };
    };
  };
  /** @description Set is_billing_exempt for a zap */
  api_v4_internal_zaps_exempt: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this node. */
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["BillingExemptZapsRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["BillingExemptZapsResponse"];
        };
      };
    };
  };
  /**
   * Endpoint for retrieving an invitation given a valid invitation code
   * @description This is accessible by anonymous users.
   */
  api_v4_invitations_read: {
    parameters: {
      path: {
        invitation_code: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["InvitationCode"];
        };
      };
    };
  };
  /**
   * Accept the given invitation
   * @description The user needs to be authenticated to access this endpoint.
   * The invitation must be addressed to the authenticated user for the operation
   * to succeed.
   *
   * If the invitation was successfully accepted, a 200 status code
   * response will be returned with no payload.
   *
   * If the invitation acceptance failed, a 400 status code will be returned.
   * A `reason` field might be present, which indicates one of the following possible
   * reasons to fail:
   *
   *   * revoked - The invitation was already revoked
   *   * expired - The invitation expired
   *   * used - The invitation was already used
   *   * mismatched-email - The email of the invitation is not the same as the email of the authenticated user
   *   * member-count-exceeded - Cannot join the invitation's account as it has too many members
   *
   * The invitation may also be associated with a team, in which case the
   * user accepting the invitation will also be added to the team.
   */
  api_v4_invitations_partial_update: {
    parameters: {
      path: {
        invitation_code: string;
      };
    };
    requestBody: components["requestBodies"]["InvitationCode"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["InvitationCode"];
        };
      };
    };
  };
  /**
   * This endpoint is used for exposing invitations by code
   * @description The actual invitations endpoint is scoped under an account ID
   */
  api_v4_invitations_decline: {
    parameters: {
      path: {
        invitation_code: string;
      };
    };
    requestBody: components["requestBodies"]["InvitationCode"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["InvitationCode"];
        };
      };
    };
  };
  /**
   * @description
   * [DEPRECATED] - The pattern of exchanging a service JWT for a user JWT is deprecated.
   *
   * Exchange a Service JWT for a User JWT. JWTs in the `Authorization` header
   * must have their `aud` claim set to `"identity:token-exchange"` and be
   * from an allowed issuer (see `identity.jwt.constants.JWT_EXCHANGE_ISSUER_ALLOWLIST`).
   */
  "api_v4_jwt_token-exchange_create": {
    requestBody: {
      content: {
        "application/json": components["schemas"]["JWTTokenExchangeRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["JWTTokenExchangeResponse"];
        };
      };
    };
  };
  /**
   * @description
   * Retrieves the acceptance date for the given term
   */
  "api_v4_legal_terms-acceptance_read": {
    parameters: {
      path: {
        term_name: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            /** @description string */
            name?: string;
            /** @description date */
            date?: string;
          };
        };
      };
      400: {
        content: {
          "application/json": {
            /** @description string */
            message?: string;
          };
        };
      };
    };
  };
  /**
   * @description
   * Sets the date for the given term (if it hasn't already been set)
   */
  "api_v4_legal_terms-acceptance_create": {
    parameters: {
      path: {
        term_name: string;
      };
    };
    responses: {
      /** @description Success */
      204: {
        content: never;
      };
      400: {
        content: {
          "application/json": {
            /** @description string */
            message?: string;
          };
        };
      };
      409: {
        content: {
          "application/json": {
            /** @description string */
            message?: string;
          };
        };
      };
      500: {
        content: {
          "application/json": {
            /** @description string */
            message?: string;
          };
        };
      };
    };
  };
  api_v4_masquerade_urls_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["MasqueradeLinkRequest"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["MasqueradeLinkResponse"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["MasqueradeLinkResponse"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["MasqueradeLinkResponse"];
        };
      };
    };
  };
  /**
   * List Noun Step Connections
   * @description These map between actions and nouns, in one or the other direction.
   */
  "api_v4_noun-steps_list": {
    parameters: {
      query?: {
        /** @description The slug of the related noun to filter against, comma separated values supported. */
        noun_slug?: string;
        /** @description The selected_api of the step to filter against, comma separated values supported. */
        selected_api?: string;
        /** @description The type_of of the step to filter against, comma separated values supported. */
        type_of?: string;
        /** @description The action of the step to filter against, comma separated values supported. */
        action?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["NounStepConnection"][];
          };
        };
      };
    };
  };
  /**
   * Retrieve Noun Step Connection
   * @description Get a specific noun step connection by id.
   */
  "api_v4_noun-steps_read": {
    parameters: {
      path: {
        /** @description A unique integer value identifying this noun step connection. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["NounStepConnection"];
        };
      };
    };
  };
  /**
   * List Nouns
   * @description Nouns define a set of fields that represent some schema.
   */
  api_v4_nouns_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Noun"][];
          };
        };
      };
    };
  };
  /**
   * Retrieve Noun
   * @description Get a specific noun according to it's slug.
   */
  api_v4_nouns_read: {
    parameters: {
      path: {
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Noun"];
        };
      };
    };
  };
  /** @description Lists OAuth applications for a given integration */
  api_v4_oauth_applications_list: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["OAuthApplication"][];
        };
      };
    };
  };
  /** @description Update a OAuth application. */
  api_v4_oauth_applications_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this application. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["OAuthApplication"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["OAuthApplication"];
        };
      };
    };
  };
  api_v4_oauth_applications_partial_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this application. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["OAuthApplication"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["OAuthApplication"];
        };
      };
    };
  };
  /** @description regenerate client secret of an OAuth application. */
  api_v4_oauth_applications_regenerate_client_secret: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this application. */
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["OAuthApplicationExtended"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["OAuthApplication"];
        };
      };
    };
  };
  "api_v4_oauth_token-exchange_create": {
    requestBody: {
      content: {
        "application/json": components["schemas"]["OauthTokenExchangeRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["OauthTokenExchangeResponse"];
        };
      };
    };
  };
  api_v4_onboardings_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Onboarding"][];
          };
        };
      };
    };
  };
  api_v4_onboardings_create: {
    requestBody: components["requestBodies"]["Onboarding"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["Onboarding"];
        };
      };
    };
  };
  api_v4_onboardings_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this onboarding. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Onboarding"];
        };
      };
    };
  };
  api_v4_onboardings_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this onboarding. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Onboarding"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Onboarding"];
        };
      };
    };
  };
  api_v4_onboardings_delete: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this onboarding. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  api_v4_onboardings_partial_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this onboarding. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Onboarding"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Onboarding"];
        };
      };
    };
  };
  "api_v4_persisted-modals_list": {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PersistedModal"][];
        };
      };
    };
  };
  "api_v4_persisted-modals_dismiss": {
    requestBody: components["requestBodies"]["PersistedModal"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["PersistedModal"];
        };
      };
    };
  };
  "api_v4_persisted-modals_persist": {
    requestBody: components["requestBodies"]["PersistedModal"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["PersistedModal"];
        };
      };
    };
  };
  api_v4_poc_enable_poc: {
    requestBody: components["requestBodies"]["api_v4_accounts_domains_members_export_membersData"];
    responses: {
      201: {
        content: {
          "application/json": Record<string, never>;
        };
      };
    };
  };
  api_v4_policies_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Policy"][];
          };
        };
      };
    };
  };
  api_v4_policies_agreements_pending_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["PendingPolicy"][];
          };
        };
      };
    };
  };
  api_v4_policies_agreements_create: {
    parameters: {
      path: {
        policy_slug: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Agreement"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["Agreement"];
        };
      };
    };
  };
  api_v4_policies_read: {
    parameters: {
      path: {
        /** @description A unique slug for the policy. If blank, autogenerated from the title of the policy. */
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PolicyContent"];
        };
      };
    };
  };
  "api_v4_press-pages_list": {
    parameters: {
      query?: {
        is_public?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["PressPageArticle"][];
          };
        };
      };
    };
  };
  "api_v4_press-pages_read": {
    parameters: {
      path: {
        /** @description A unique integer value identifying this press page article. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PressPageArticle"];
        };
      };
    };
  };
  /** @description Retrieve the current profile */
  api_v4_profile_read: {
    responses: {
    };
  };
  /**
   * @description Delete the currently logged in user
   *
   *         The `auth_token` query parameter is required as it is needed
   *         for verifying that the user confirmed their action.
   */
  api_v4_profile_delete: {
    requestBody: {
      content: {
        "application/json": {
          /** @description The confirm authentication token */
          auth_token?: string;
        };
      };
    };
    responses: {
    };
  };
  api_v4_recommendations_company_sizes_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["CompanySize"][];
          };
        };
      };
    };
  };
  api_v4_recommendations_company_sizes_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this company size. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CompanySize"];
        };
      };
    };
  };
  api_v4_recommendations_roles_list: {
    parameters: {
      query?: {
        /** @description A slug to filter results by. */
        slug?: string;
        /** @description The canonical ID(s). Multiple canonical IDs can be provided by including multiple `canonical_id` query parameters. */
        canonical_id?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Role"][];
          };
        };
      };
    };
  };
  api_v4_recommendations_roles_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this role. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Role"];
        };
      };
    };
  };
  /** @description A viewset that provides CRUD operations for the Action model. */
  api_v4_registry_actions_list: {
    parameters: {
      query?: {
        selected_api?: string;
        /** @description The paginated offset when fetching actions. */
        offset?: number;
        /** @description The limit of how many actions are returned in a query */
        limit?: number;
        is_public?: boolean;
        owner_id?: number;
        account_ids?: number[];
        customuser_ids?: number[];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ActionListResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
      401: {
        content: {
          "application/json": components["schemas"]["ActionBaseResponse"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ActionBaseResponse"];
        };
      };
    };
  };
  /** @description A viewset that provides CRUD operations for the Action model. */
  api_v4_registry_actions_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ActionCreate"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["ActionCreateOrUpdateResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
      401: {
        content: {
          "application/json": components["schemas"]["ActionBaseResponse"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ActionBaseResponse"];
        };
      };
      409: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
    };
  };
  /** @description A viewset that provides CRUD operations for the Action model. */
  api_v4_registry_actions_read: {
    parameters: {
      path: {
        action_id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ActionCreateOrUpdateResponse"];
        };
      };
      401: {
        content: {
          "application/json": components["schemas"]["ActionBaseResponse"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ActionBaseResponse"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
    };
  };
  /** @description A viewset that provides CRUD operations for the Action model. */
  api_v4_registry_actions_update: {
    parameters: {
      path: {
        action_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ActionDetail"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ActionCreateOrUpdateResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
      401: {
        content: {
          "application/json": components["schemas"]["ActionBaseResponse"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ActionBaseResponse"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
      409: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
    };
  };
  /** @description A viewset that provides CRUD operations for the Action model. */
  api_v4_registry_actions_delete: {
    parameters: {
      path: {
        action_id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ActionBaseResponse"];
        };
      };
      401: {
        content: {
          "application/json": components["schemas"]["ActionBaseResponse"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ActionBaseResponse"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
    };
  };
  /**
   * @description A specific endpoint for changing an action's status to `public`.
   * It is only available to staff users, for now.
   */
  api_v4_registry_actions_publish: {
    parameters: {
      path: {
        action_id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ActionDetailResponse"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
      409: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
    };
  };
  /** @description The endpoint used for sharing an action with customusers and accounts. */
  api_v4_registry_actions_share: {
    parameters: {
      path: {
        action_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ActionShareRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ActionCreateOrUpdateResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["ActionErrorResponse"];
        };
      };
    };
  };
  "api_v4_review-pages_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["ReviewPage"][];
          };
        };
      };
    };
  };
  "api_v4_review-pages_read": {
    parameters: {
      path: {
        /** @description A unique integer value identifying this review page. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ReviewPage"];
        };
      };
    };
  };
  /**
   * Initiate a sample for a action.
   * @description > Note: Requires that the user making the request is an admin.
   *
   * ---
   *
   * On success, the request will return JSON containing a `session_id` and `metadata`.
   *
   * ---
   *
   * The consumer will have two choices in receiving results:
   *
   * Option 1: the caller may want to listen for:
   *  - [SampleSuccessEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/platform.sampling.SampleSuccessEvent)
   *  - [SampleFailureEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/platform.sampling.SampleFailureEvent)
   *
   * Option 2: the caller can use the related `v4/samples/<session_id>/` endpoint to
   * retrieve results.
   */
  api_v4_samples_sample_action: {
    requestBody: components["requestBodies"]["SampleRequest"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["SampleResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["SampleErrorResponse"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["SampleErrorResponse"];
        };
      };
    };
  };
  /**
   * Initiate a sample for a trigger.
   * @description > Note: Requires that the user making the request is an admin.
   *
   * ---
   *
   * On success, the request will return JSON containing a `session_id` and `metadata`.
   *
   * The `session_id` represents either an attempt or a trigger subscription claim:
   *  - An id prepended with `a.<uuid>` is an attempt id.
   *  - An id prepended with `c.<uuid>` is a trigger subscription claim id.
   *
   * ---
   *
   * The consumer will have two choices in receiving results:
   *
   * Option 1: the caller may want to listen for:
   *  - [SampleSuccessEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/platform.sampling.SampleSuccessEvent)
   *  - [SampleFailureEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/platform.sampling.SampleFailureEvent)
   *
   * Option 2: the caller can use the related `v4/samples/<session_id>/` endpoint to
   * retrieve results.
   */
  api_v4_samples_sample_trigger: {
    requestBody: components["requestBodies"]["SampleRequest"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["SampleResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["SampleErrorResponse"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["SampleErrorResponse"];
        };
      };
    };
  };
  /**
   * @description Retrieve the samples for a trigger or action, that has been put into sampling mode via the
   * `/api/v4/samples/(trigger|action)` API.
   *
   * > Note: Requires that the user making the request is an admin.
   *
   * ---
   *
   * On success, the request will return JSON containing a `results` key which is a list of the
   * data from the sample
   *
   * On failure will return JSON containing `error_message` and `error_type` keys, which describe
   * the failure.
   *
   * ---
   *
   * For polling triggers and hooks using a polling fallback, after results are returned once,
   * subsequent calls to this endpoint with the same id will 404. This will be the way for
   * clients to know they need to call /samples/trigger again to start another poll.
   *
   * For hook triggers and actions, the endpoint should continue to return the available results until
   * the session expires. Once expired, the endpoint will 404.
   */
  api_v4_samples_read: {
    parameters: {
      path: {
        session_id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SampleResultsResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["SampleResultsErrorResponse"];
        };
      };
      401: {
        content: {
          "application/json": components["schemas"]["SampleResultsErrorResponse"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["SampleResultsErrorResponse"];
        };
      };
      404: {
        content: {
          "application/json": components["schemas"]["SampleResultsErrorResponse"];
        };
      };
    };
  };
  api_v4_security_domain_headers_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  "api_v4_seo-data_list": {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SEOData"][];
        };
      };
    };
  };
  "api_v4_seo-data_read": {
    parameters: {
      path: {
        /** @description A unique integer value identifying this seo data. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SEOData"];
        };
      };
    };
  };
  api_v4_services_list: {
    parameters: {
      query?: {
        /** @description Specifies if a service is upcoming. */
        is_upcoming?: string;
        /** @description The slug of the related category to filter against. */
        category?: string;
        /** @description Specifies if a service is premium. */
        is_premium?: string;
        /** @description A comma separated list of slugs to filter the list of Service objects by. */
        slugs?: string;
        /** @description A comma separated list of selected_apis to filter the list of Service objects by. */
        selected_apis?: string;
        /** @description A comma separated list of ids to filter the list of Service objects by. */
        ids?: string;
        /** @description A search query against the title. */
        title_search?: string;
        /** @description Specifies if a service is built-in. */
        is_built_in?: string;
        /** @description Specifies if an object is published, that is, publicly visible on Zapier. */
        is_published?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Service"][];
          };
        };
      };
    };
  };
  api_v4_services_alternatives_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        service_slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["AppAlternative"][];
          };
        };
      };
    };
  };
  api_v4_services_alternatives_read: {
    parameters: {
      path: {
        service_slug: string;
        /** @description A unique integer value identifying this app alternative. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AppAlternative"];
        };
      };
    };
  };
  api_v4_services_media_list: {
    parameters: {
      path: {
        service_slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AppMedia"][];
        };
      };
    };
  };
  api_v4_services_media_read: {
    parameters: {
      path: {
        service_slug: string;
        /** @description A unique integer value identifying this app media. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AppMedia"];
        };
      };
    };
  };
  "api_v4_services_meta-updates_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        service_slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: Record<string, never>[];
          };
        };
      };
    };
  };
  api_v4_services_pairs_list: {
    parameters: {
      query?: {
        /** @description Specifies if a service is built-in. */
        is_built_in?: string;
        /** @description A comma separated list of categories slugs to filter by. It accepts a `-` prefix to denote a category exclusion (e.g., "communication, -email"). */
        categories?: string;
        /** @description A comma separated list of app slugs to exclude. */
        exclude_slugs?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        service_slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["ServicePairSerializerV2"][];
          };
        };
      };
    };
  };
  api_v4_services_pairs_read: {
    parameters: {
      path: {
        service_slug: string;
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ServicePairSerializerV2"];
        };
      };
    };
  };
  "api_v4_services_pricing-plans_list": {
    parameters: {
      path: {
        service_slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ServicePricingPlan"][];
        };
      };
    };
  };
  "api_v4_services_pricing-plans_read": {
    parameters: {
      path: {
        service_slug: string;
        /** @description A unique integer value identifying this Service Pricing Plan. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ServicePricingPlan"];
        };
      };
    };
  };
  api_v4_services_requests_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        service_slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["ServiceRequest"][];
          };
        };
      };
    };
  };
  api_v4_services_requests_create: {
    parameters: {
      path: {
        service_slug: string;
      };
    };
    requestBody: components["requestBodies"]["ServiceRequest"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["ServiceRequest"];
        };
      };
    };
  };
  api_v4_services_requests_read: {
    parameters: {
      path: {
        service_slug: string;
        /** @description A unique integer value identifying this service request. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ServiceRequest"];
        };
      };
    };
  };
  api_v4_services_requests_update: {
    parameters: {
      path: {
        service_slug: string;
        /** @description A unique integer value identifying this service request. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["ServiceRequest"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ServiceRequest"];
        };
      };
    };
  };
  api_v4_services_requests_partial_update: {
    parameters: {
      path: {
        service_slug: string;
        /** @description A unique integer value identifying this service request. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["ServiceRequest"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ServiceRequest"];
        };
      };
    };
  };
  /** @description Make the service request 'awesome', 'passable', or 'rejected' */
  api_v4_services_requests_notes: {
    parameters: {
      path: {
        service_slug: string;
        /** @description A unique integer value identifying this service request. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["ServiceRequest"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["ServiceRequest"];
        };
      };
    };
  };
  api_v4_services_read: {
    parameters: {
      path: {
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Service"];
        };
      };
    };
  };
  api_v4_services_can_provide_profile: {
    parameters: {
      path: {
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Service"];
        };
      };
    };
  };
  api_v4_services_service_pairs: {
    parameters: {
      path: {
        /** @description You should **not** change this after it is public! */
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Service"];
        };
      };
    };
  };
  /**
   * @description The URL structure here is of the list-format, but that's because
   * the primary key is implied by the session. There are several ways
   * to handle this conversion in DRF, but this is, IMO, the simplest.
   */
  api_v4_session_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  "api_v4_session_token-exchange_create": {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SessionTokenExchangeRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SessionTokenExchangeResponse"];
        };
      };
    };
  };
  api_v4_shared_zaps_list: {
    parameters: {
      query?: {
        /** @description Find shared zaps by their root node id. */
        node_id?: string;
        /** @description Find shared zaps that have a specific state. */
        state?: string;
        /** @description A comma separated list of service slugs that are all used by the shared Zap. */
        service_slugs?: string;
        /** @description The service slug of the shared Zap's head service. */
        head_service_slug?: string;
        /** @description The service slug of the shared Zap's tail service. */
        tail_service_slug?: string;
        /** @description A flag to indicate whether to include or exclude Shared Zaps that have a customized title or description. */
        customized?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["SharedZap"][];
          };
        };
      };
    };
  };
  api_v4_shared_zaps_create: {
    requestBody: components["requestBodies"]["SharedZap"];
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["SharedZap"];
        };
      };
    };
  };
  api_v4_shared_zaps_read: {
    parameters: {
      path: {
        link_hash: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SharedZap"];
        };
      };
    };
  };
  api_v4_shared_zaps_update: {
    parameters: {
      path: {
        link_hash: string;
      };
    };
    requestBody: components["requestBodies"]["SharedZap"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SharedZap"];
        };
      };
    };
  };
  /** @description Unshare a Zap with the given link hash */
  api_v4_shared_zaps_delete: {
    parameters: {
      path: {
        link_hash: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  api_v4_shared_zaps_partial_update: {
    parameters: {
      path: {
        link_hash: string;
      };
    };
    requestBody: components["requestBodies"]["SharedZap"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SharedZap"];
        };
      };
    };
  };
  api_v4_sharing_stats_by_creator_id: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        creator_id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["SharingStats"][];
          };
        };
      };
    };
  };
  api_v4_sharing_stats_by_selected_api: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        selected_api: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["SharingStats"][];
          };
        };
      };
    };
  };
  api_v4_sharing_stats_by_shared_zap: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        zuid: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["SharingStats"][];
          };
        };
      };
    };
  };
  /** @description Determine if a user is eligible for various types of support. */
  "api_v4_support-eligibility_list": {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /** @description Returns a set of notes associated with a hierarchy. */
  "api_v4_support-notes_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["SupportNote"][];
          };
        };
      };
    };
  };
  /** @description Returns a set of notes associated with a hierarchy. */
  "api_v4_support-notes_read": {
    parameters: {
      path: {
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SupportNote"];
        };
      };
    };
  };
  /**
   * @description Create a ticket in Zendesk via their API.
   * Falls back to create a ticket by direct email if API creation fails.
   */
  api_v4_support_ticket_zendesk_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  api_v4_testimonials_list: {
    parameters: {
      query?: {
        /** @description Specifies if an object is featured. */
        featured?: string;
        /** @description A string value which, when set to "random", provides a random sampling of results. */
        values?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Testimonial"][];
          };
        };
      };
    };
  };
  api_v4_testimonials_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this testimonial. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Testimonial"];
        };
      };
    };
  };
  /**
   * @description For folks that need to emit Avro events outside of our AWS environment,
   * they can make use of the v4 Events API. Events that originate from a
   * frontend application or an external Zapier system should use this API.
   * Events that are emitted by systems within our AWS environment should
   * not use the events API. Those systems should use the events toolkit
   * directly to emit events.  This API is also not currently suitable for
   * emitting actionable events. (e.g. events that would drive transactional
   * processing by systems/services like the engine.)
   *
   * To make use of this API, you'll need to make sure the Avro schema(s) for
   * your event types include `"events_api": true` as a top-level key/value pair.
   * This schema meta information informs the Events API that an event type
   * should be allowed to be emitted.
   *
   * Please reference the Events API emitting section of the Events Toolkit
   * Manual for more background information:
   */
  api_v4_tracking_event_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  /**
   * @description For folks that need to emit Avro events outside of our AWS environment,
   * they can make use of the v4 Events API. Events that originate from a
   * frontend application or an external Zapier system should use this API.
   * Events that are emitted by systems within our AWS environment should
   * not use the events API. Those systems should use the events toolkit
   * directly to emit events.  This API is also not currently suitable for
   * emitting actionable events. (e.g. events that would drive transactional
   * processing by systems/services like the engine.)
   *
   * To make use of this API, you'll need to make sure the Avro schema(s) for
   * your event types include `"events_api": true` as a top-level key/value pair.
   * This schema meta information informs the Events API that an event type
   * should be allowed to be emitted.
   *
   * Please reference the Events API emitting section of the Events Toolkit
   * Manual for more background information:
   */
  api_v4_tracking_event_test_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  /**
   * Return all active claims for trigger subscriptions.
   * @description If the caller is service-to-service (or admin), they can provide a customuser_id
   * along with account_id (which remains subject to permissions). If you get a 403,
   * the membership of customuser_id to account_id likely why.
   */
  api_v4_triggers_list: {
    parameters: {
      query?: {
        /** @description Comma separated Claim ID UUIDs. */
        claim_ids?: string[];
        /** @description The ID of the CustomUser if Admin or Service-to-Service authorization. Ignored otherwise, which defaults to the logged in user. */
        customuser_id?: number;
        /** @description The ID of the Account related to referenced CustomUser. */
        account_id?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TriggerSubscriptionClaimDetailResponse"];
        };
      };
    };
  };
  /**
   * Create a claim on a trigger subscription.
   * @description Side effects:
   * - On success the avro event [event.zapier.app_platform.trigger.InitializationSuccessEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/event.zapier.app_platform.trigger.InitializationSuccessEvent) will be emitted.
   * - On failure the avro event [event.zapier.app_platform.trigger.InitializationFailureEvent](https://docs.k8s.zapier.com/avro-schemas/#/schema/event.zapier.app_platform.trigger.InitializationFailureEvent) will be emitted.
   *
   * If this endpoint returns a failure, we may not emit an error event. An error response from this endpoint could be because auth doesn’t match the selected_api, or user doesn’t have permission to that auth, or selected_api doesn’t exist.
   */
  api_v4_triggers_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TriggerSubscriptionRequest"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["TriggerSubscriptionClaimResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["TriggerSubscriptionError"];
        };
      };
      401: {
        content: {
          "application/json": components["schemas"]["TriggerSubscriptionError"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["TriggerSubscriptionError"];
        };
      };
    };
  };
  /**
   * Release a claim to a trigger subscription.
   * @description Requires the user making the request to be an admin or be the claim's owner.
   */
  api_v4_release_claim: {
    parameters: {
      path: {
        claim_id: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  api_v4_updates_list: {
    parameters: {
      query?: {
        /** @description Filters by the related service slug. */
        service_slug?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Update"][];
          };
        };
      };
    };
  };
  api_v4_updates_read: {
    parameters: {
      path: {
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Update"];
        };
      };
    };
  };
  "api_v4_use-cases_list": {
    parameters: {
      query?: {
        /** @description Specifies sort to apply to Use Cases. Currently only supports "random", which is also default. If an "offset" param is supplied, random sorting is not applied because the random order will not persist across pagination, and the user could experience duplicates between pages as a result. */
        order_by?: string;
        /** @description The canonical ID(s). Multiple canonical IDs can be provided by including multiple `canonical_id` query parameters. */
        canonical_id?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["UseCase"][];
          };
        };
      };
    };
  };
  "api_v4_use-cases_read": {
    parameters: {
      path: {
        slug: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["UseCase"];
        };
      };
    };
  };
  "api_v4_use-cases_step_step_action_ranking_search": {
    parameters: {
      query?: {
        /** @description Query value to search app names by. Case-insensitive. Supports partial matches. */
        app_name_contains?: string;
        /** @description ID of previous use case step. Used together with previous_app_implementation_id and previous_key for getting conditionally ranked apps for the requested step, based on the user's previous app selection. */
        previous_step_id?: string;
        /** @description selected_api from previous step. Used together with previous_step_id and previous_key for getting conditionally ranked apps for the requested step, based on the user's previous app selection. */
        previous_app_implementation_id?: string;
        /** @description Action key from previous step. Used together with previous_step_id and previous_app_implementation_id for getting conditionally ranked apps for the requested step, based on the user's previous app selection. */
        previous_key?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        use_case_slug: string;
        step_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["UseCaseStepAction"][];
          };
        };
      };
    };
  };
  "api_v4_use-cases_step_step_action_rankings": {
    parameters: {
      query?: {
        /** @description ID of previous use case step. Used together with previous_app_implementation_id and previous_key for getting conditionally ranked apps for the requested step, based on the user's previous app selection. */
        previous_step_id?: string;
        /** @description selected_api from previous step. Used together with previous_step_id and previous_key for getting conditionally ranked apps for the requested step, based on the user's previous app selection. */
        previous_app_implementation_id?: string;
        /** @description Action key from previous step. Used together with previous_step_id and previous_app_implementation_id for getting conditionally ranked apps for the requested step, based on the user's previous app selection. */
        previous_key?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        use_case_slug: string;
        step_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["UseCaseStepAction"][];
          };
        };
      };
    };
  };
  "api_v4_user-photo-upload_create": {
    responses: {
      201: {
        content: never;
      };
    };
  };
  "api_v4_user-skill-levels_list": {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SkillLevelAction"][];
        };
      };
    };
  };
  "api_v4_user-skill-levels_complete_action": {
    parameters: {
      path: {
        action_key: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SkillLevelAction"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["SkillLevelAction"];
        };
      };
    };
  };
  /**
   * @description The URL structure here is of the list-format, but that's because
   * the primary key is implied by the session. There are several ways
   * to handle this conversion in DRF, but this is, IMO, the simplest.
   */
  api_v4_whoami_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * List all the Zaps that the current user has access to in this account context
   * @description The account context needs to be passed by `account_id` query param, otherwise
   * all Zaps that the user has access to across all the user's accounts will be included.
   */
  api_v4_zaps_list: {
    parameters: {
      query?: {
        /** @description Filter Zaps by the given owner. A predefined `me` filter is also supported, which will filter the Zaps owned by the current logged in user. */
        owner?: string;
        /** @description Filter Zaps by the given folder_id. Use `0` for the "home folder". */
        folder_id?: number;
        /** @description Search for Zaps by title and Service title */
        search?: string;
        /** @description A comma-separated list of versioned or versionless selected_apis; Zaps returned will use any of the provided selected_api values. */
        selected_apis?: string;
        /** @description A comma-separated list of versioned or versionless selected_apis; Zaps returned will use all of the provided selected_api values. */
        all_selected_apis?: string;
        /** @description A comma-separated list of Zap IDs to filter Zaps by. */
        ids?: string;
        /** @description A comma-separated list of auth_ids; Zaps returned will use any of the provided auth ID values. */
        auth_ids?: string;
        /** @description Filter Zaps that use a given Service. */
        service_slug?: string;
        /** @description Return Zaps whose title contains the provided string. */
        title?: string;
        /** @description Return Zaps which are in the provided state (on, off, or draft). */
        state?: string;
        /** @description Return Zaps which have activity after the provided date/time. Formatted in an ISO-8601 date/time string including timezone. */
        activity_start_date?: string;
        /** @description Return Zaps which have activity before the provided date/time.Formatted in an ISO-8601 date/time string including timezone. */
        activity_end_date?: string;
        /** @description Return Zaps belonging only to this specific kind value.Available kinds: workflow, transfer */
        kind?: string;
        /** @description Return Zaps that have a specific key/value set in the params field of the Zap. Only works in conjunction with selected_api filtering. */
        "params__{key}={value}"?: string;
        /** @description Which field to use when ordering the results. */
        ordering?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Zap"][];
          };
        };
      };
    };
  };
  /** @description Bulk delete a list of Zaps */
  api_v4_zaps_bulk_delete: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteZapsRequest"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["DeleteZapsRequest"];
        };
      };
    };
  };
  /** @description Bulk transfer a list of Zaps to a new owner */
  api_v4_zaps_bulk_transfer: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TransferZapsRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TransferZapsResponse"];
        };
      };
    };
  };
  /**
   * Export a list of zaps
   * @description There are two ways to export the zaps. One is to pass a list of zap IDs
   * with `zap_ids` POST field. The other one is to export all the zaps
   * from the account passed via `account_id` POST field.
   *
   * A list of serialized zaps will be returned.
   */
  api_v4_zaps_export_zaps: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExportZapsRequest"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["ExportZapsRequest"];
        };
      };
    };
  };
  /**
   * Import zaps from a given zapfile
   * @description The import needs a `zapfile` sent as a multipart file. Additionally
   * you can send `destination_folder_id`, which should specify
   * a folder where the zaps need to be imported, and `account_id`, which scopes
   * the account in which the zaps need to be imported, as long as the user
   * doing the action is a member of the said account.
   */
  api_v4_zaps_import_zaps: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ImportZapsRequest"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["ImportZapsRequest"];
        };
      };
    };
  };
  /** @description Move a list of zaps to a different target account */
  api_v4_zaps_move_zaps: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["MoveZapsRequest"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["MoveZapsRequest"];
        };
      };
    };
  };
  /** @description Get the list of trashed zaps */
  api_v4_zaps_get_trash: {
    parameters: {
      query?: {
        /** @description Filter Zaps by the given owner. A predefined `me` filter is also supported, which will filter the Zaps owned by the current logged in user. */
        owner?: string;
        /** @description Filter Zaps by the given folder_id. Use `0` for the "home folder". */
        folder_id?: number;
        /** @description Search for Zaps by title and Service title */
        search?: string;
        /** @description A comma-separated list of versioned or versionless selected_apis; Zaps returned will use any of the provided selected_api values. */
        selected_apis?: string;
        /** @description A comma-separated list of versioned or versionless selected_apis; Zaps returned will use all of the provided selected_api values. */
        all_selected_apis?: string;
        /** @description A comma-separated list of Zap IDs to filter Zaps by. */
        ids?: string;
        /** @description A comma-separated list of auth_ids; Zaps returned will use any of the provided auth ID values. */
        auth_ids?: string;
        /** @description Filter Zaps that use a given Service. */
        service_slug?: string;
        /** @description Return Zaps whose title contains the provided string. */
        title?: string;
        /** @description Return Zaps which are in the provided state (on, off, or draft). */
        state?: string;
        /** @description Return Zaps which have activity after the provided date/time. Formatted in an ISO-8601 date/time string including timezone. */
        activity_start_date?: string;
        /** @description Return Zaps which have activity before the provided date/time.Formatted in an ISO-8601 date/time string including timezone. */
        activity_end_date?: string;
        /** @description Return Zaps belonging only to this specific kind value.Available kinds: workflow, transfer */
        kind?: string;
        /** @description Return Zaps that have a specific key/value set in the params field of the Zap. Only works in conjunction with selected_api filtering. */
        "params__{key}={value}"?: string;
        /** @description Which field to use when ordering the results. */
        ordering?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Zap"][];
          };
        };
      };
    };
  };
  /**
   * A simple resource which returns the number of off, on, and draft Zaps
   * a user has, broken down by account ID.
   * @description Introduced to make it easier (read: possible) to decide whether the "move
   * zaps" button should be shown or not (as this depends on whether the user
   * has any Zaps in any of their accounts). In future, when we remove the
   * scoping for all endpoints, this will be more consistent!
   */
  api_v4_zaps_get_zap_usage: {
    parameters: {
      query?: {
        /** @description Filter Zaps by the given owner. A predefined `me` filter is also supported, which will filter the Zaps owned by the current logged in user. */
        owner?: string;
        /** @description Filter Zaps by the given folder_id. Use `0` for the "home folder". */
        folder_id?: number;
        /** @description Search for Zaps by title and Service title */
        search?: string;
        /** @description A comma-separated list of versioned or versionless selected_apis; Zaps returned will use any of the provided selected_api values. */
        selected_apis?: string;
        /** @description A comma-separated list of versioned or versionless selected_apis; Zaps returned will use all of the provided selected_api values. */
        all_selected_apis?: string;
        /** @description A comma-separated list of Zap IDs to filter Zaps by. */
        ids?: string;
        /** @description A comma-separated list of auth_ids; Zaps returned will use any of the provided auth ID values. */
        auth_ids?: string;
        /** @description Filter Zaps that use a given Service. */
        service_slug?: string;
        /** @description Return Zaps whose title contains the provided string. */
        title?: string;
        /** @description Return Zaps which are in the provided state (on, off, or draft). */
        state?: string;
        /** @description Return Zaps which have activity after the provided date/time. Formatted in an ISO-8601 date/time string including timezone. */
        activity_start_date?: string;
        /** @description Return Zaps which have activity before the provided date/time.Formatted in an ISO-8601 date/time string including timezone. */
        activity_end_date?: string;
        /** @description Return Zaps belonging only to this specific kind value.Available kinds: workflow, transfer */
        kind?: string;
        /** @description Return Zaps that have a specific key/value set in the params field of the Zap. Only works in conjunction with selected_api filtering. */
        "params__{key}={value}"?: string;
        /** @description Which field to use when ordering the results. */
        ordering?: string;
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["Zap"][];
          };
        };
      };
    };
  };
  api_v4_zaps_read: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this node. */
        id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Zap"];
        };
      };
    };
  };
  /**
   * Update a Zap
   * @description Only three fields can be updated; `title`, `folder_id` and `customuser_id`.
   */
  api_v4_zaps_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this node. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Zap"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Zap"];
        };
      };
    };
  };
  /** @description Remove the given Zap */
  api_v4_zaps_delete: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this node. */
        id: number;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  api_v4_zaps_partial_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this node. */
        id: number;
      };
    };
    requestBody: components["requestBodies"]["Zap"];
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Zap"];
        };
      };
    };
  };
  api_v4_zaps_choices_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
      path: {
        node_pk: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: components["schemas"]["ChoiceResponse"][];
          };
        };
      };
    };
  };
  api_v4_zaps_choices_read: {
    parameters: {
      path: {
        node_pk: string;
        action: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ChoiceResponse"];
        };
      };
    };
  };
  /**
   * @description Convert the provided ZDL document to the equivalent Zap of Nodes,
   * optionally unpausing the Zap.
   */
  "api_v4_zdl_convert-to-nodes_create": {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConvertZDLToNodes"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ConvertZDLToNodesResponseSuccess"];
        };
      };
      201: {
        content: {
          "application/json": components["schemas"]["ConvertZDLToNodesResponseSuccess"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ConvertZDLToNodesResponseFailure"];
        };
      };
      401: {
        content: {
          "application/json": components["schemas"]["ConvertZDLToNodesResponseFailure"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ConvertZDLToNodesResponseFailure"];
        };
      };
      426: {
        content: {
          "application/json": components["schemas"]["ConvertZDLToNodesResponseFailure"];
        };
      };
    };
  };
  api_v4_zdl_run_published_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ZDLRunPublished"];
      };
    };
    responses: {
      /** @description The ZDL was succesfully scheduled for execution. */
      200: {
        content: never;
      };
      /** @description A validation error occurred. */
      400: {
        content: never;
      };
      /** @description This endpoint requires authentication. */
      401: {
        content: never;
      };
      /** @description Too many requests. */
      429: {
        content: never;
      };
    };
  };
  /** @description Validate the provided ZDL. */
  api_v4_zdl_validate_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ZDLValidateRequest"];
      };
    };
    responses: {
      /** @description The supplied ZDL is valid. */
      200: {
        content: never;
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZDLValidateResponseError"];
        };
      };
      /** @description This endpoint requires authentication. */
      401: {
        content: never;
      };
    };
  };
  /** @description Retrieves a list of Zap runs, optionally using various filtering facets. */
  "api_zap-history_public_v1_zap-runs_list": {
    responses: {
      200: {
        content: never;
      };
    };
  };
  /**
   * @description **Team Monitor is currently iterating on this endpoint as a replacement for `v4/accounts/{account_id}/task-usage`
   * and it may not be ready for full-time adoption.** Please reach out over in #team-monitor!
   * We want to hear feedback about how your team uses the pre-existing endpoints and what you
   * would want to see out of new ones.
   */
  "api_zap-history_v1_task-usage_list": {
    parameters: {
      query: {
        account_id: number;
        /** @description Start datetime for query; ISO-8601 */
        from_date?: string;
        /** @description Start datetime for query; ISO-8601 */
        to_date?: string;
        /** @description Comma-separated list of customuser_id values to filter by */
        customuser_ids?: number[];
        /** @description Comma-separated list of folder_id values to filter by */
        folder_ids?: number[];
        /** @description Comma-separated list of Zap kind values to filter by */
        kinds?: ("workflow" | "transfer")[];
        /** @description Comma-separated list of apps (selected APIs) values to filter by */
        selected_apis?: string[];
        /** @description Comma-separated list of Zap IDs (numeric or UUID) */
        zap_ids?: string[];
        /** @description Interval size for task usage aggregation; from/to date ranges larger than 60 days will force the use of month-sized aggregation intervals */
        interval?: "day" | "month";
        /** @description IANA timezone name to use for aggregation and output */
        timezone?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ZHTaskUsageResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      502: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
    };
  };
  /**
   * @description **Team Monitor is currently iterating on this endpoint as a replacement for `v4/accounts/{account_id}/top-zaps`
   * and it may not be ready for full-time adoption.** Please reach out over in #team-monitor!
   * We want to hear feedback about how your team uses the pre-existing endpoints and what you
   * would want to see out of new ones.
   *
   * Retrieve the top Zaps for a given account based on the provided filters.
   */
  "api_zap-history_v1_top-zaps_list": {
    parameters: {
      query: {
        offset?: number;
        limit?: number;
        account_id: number;
        /** @description Start datetime for query; ISO-8601 */
        from_date?: string;
        /** @description Start datetime for query; ISO-8601 */
        to_date?: string;
        /** @description Comma-separated list of customuser_id values to filter by */
        customuser_ids?: number[];
        /** @description Comma-separated list of folder_id values to filter by */
        folder_ids?: number[];
        /** @description Comma-separated list of Zap kind values to filter by */
        kinds?: ("workflow" | "transfer")[];
        /** @description Comma-separated list of apps (selected APIs) values to filter by */
        selected_apis?: string[];
        /** @description Comma-separated list of Zap IDs (numeric or UUID) */
        zap_ids?: string[];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ZHTopZaps"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      502: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
    };
  };
  /**
   * @description Retrieve task usage broken down by Owner, in a format suitable
   * to populate the Top X table in the Analytics Dashboard.
   */
  "api_zap-history_v2_analytics_error-rate-by-zap-table_list": {
    parameters: {
      query: {
        /** @description Start datetime for query; ISO-8601 */
        from_date: string;
        /** @description End datetime for query; ISO-8601 */
        to_date: string;
        limit?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ErrorRateByZapTableResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
    };
  };
  /**
   * @description Retrieve task usage broken down by App, in a format suitable
   * to populate the Top X table in the Analytics Dashboard.
   */
  "api_zap-history_v2_analytics_task-usage-by-app-table_list": {
    parameters: {
      query: {
        /** @description Start datetime for query; ISO-8601 */
        from_date: string;
        /** @description End datetime for query; ISO-8601 */
        to_date: string;
        limit?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TaskUsageByAppTableResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
    };
  };
  /**
   * @description Retrieve task usage broken down by Owner, in a format suitable
   * to populate the Top X table in the Analytics Dashboard.
   */
  "api_zap-history_v2_analytics_task-usage-by-owner-table_list": {
    parameters: {
      query: {
        /** @description Start datetime for query; ISO-8601 */
        from_date: string;
        /** @description End datetime for query; ISO-8601 */
        to_date: string;
        limit?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TaskUsageByOwnerTableResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
    };
  };
  /**
   * @description Retrieve task usage broken down by Zap, in a format suitable
   * to populate the Top X table in the Analytics Dashboard.
   */
  "api_zap-history_v2_analytics_task-usage-by-zap-table_list": {
    parameters: {
      query: {
        /** @description Start datetime for query; ISO-8601 */
        from_date: string;
        /** @description End datetime for query; ISO-8601 */
        to_date: string;
        limit?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TaskUsageByZapTableResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
    };
  };
  /** @description Retrieves a list of Zap runs, optionally using various filtering facets. */
  "api_zap-history_v2_runs_list": {
    parameters: {
      query: {
        offset?: number;
        limit?: number;
        account_id: number;
        /** @description Start datetime for query; ISO-8601 */
        from_date?: string;
        /** @description Start datetime for query; ISO-8601 */
        to_date?: string;
        /** @description Comma-separated list of customuser_id values to filter by */
        customuser_ids?: number[];
        /** @description Comma-separated list of folder_id values to filter by */
        folder_ids?: number[];
        /** @description Comma-separated list of Zap kind values to filter by */
        kinds?: ("workflow" | "transfer")[];
        /** @description Comma-separated list of apps (selected APIs) values to filter by */
        selected_apis?: string[];
        /** @description Comma-separated list of Zap IDs (numeric or UUID) */
        zap_ids?: string[];
        /** @description Search query to be used for filtering Zap runs. */
        query?: string;
        /** @description Comma-separated list of Zap run statuses used for filtering */
        statuses?: ("delayed" | "scheduled" | "pending" | "error" | "error_handled" | "halted" | "throttled" | "held" | "filtered" | "skipped" | "success")[];
        order_by?: "start_time" | "status" | "customuser_id" | "-customuser_id" | "-start_time" | "-status";
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ZapRunsV2Response"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
    };
  };
  "api_zap-history_v2_runs_bulk-delete_create": {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteBody"];
      };
    };
    responses: {
      202: {
        content: {
          "application/json": components["schemas"]["ZapRunsMassActionResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
    };
  };
  "api_zap-history_v2_runs_bulk-replay_create": {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReplayBody"];
      };
    };
    responses: {
      202: {
        content: {
          "application/json": components["schemas"]["ZapRunsMassActionResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      403: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
      503: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
    };
  };
  "api_zap-history_v2_runs_export_create": {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExportBody"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["ExportResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryError"];
        };
      };
    };
  };
  /**
   * This is a brand new endpoint that is still being proved and not yet
   * ready for use.
   * @description Returns counts of held runs based on filters provided via query
   * parameters.
   */
  "api_zap-history_v2_runs_held-count_list": {
    parameters: {
      query: {
        account_id: number;
        /** @description Sets whether counts should include Zaps that are shared with the current user. */
        include_shared?: boolean;
        /** @description Specifies if counts should be grouped by the reason for being held or by Zap ID. */
        group_by?: "reason" | "zap";
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["HeldRunCountsV2Response"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
      503: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
    };
  };
  /** @description Retrieve request/response logs for a provided invocation ID. */
  "api_zap-history_v2_runs_request-logs_read": {
    parameters: {
      query: {
        /** @description Correlates request logs to a specific step from a Zap run */
        invocation_id: string;
        /** @description Required to validate that the request log belongs to a run that the user can view */
        run_id: string;
      };
      path: {
        invocation_id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ZapHistoryRequestLogsResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
    };
  };
  /** @description List top zaps for given search parameters. */
  "api_zap-history_v2_runs_top-runs_list": {
    parameters: {
      query: {
        account_id: number;
        /** @description Start datetime for query; ISO-8601 */
        from_date?: string;
        /** @description Start datetime for query; ISO-8601 */
        to_date?: string;
        /** @description Comma-separated list of customuser_id values to filter by */
        customuser_ids?: number[];
        /** @description Comma-separated list of folder_id values to filter by */
        folder_ids?: number[];
        /** @description Comma-separated list of Zap kind values to filter by */
        kinds?: ("workflow" | "transfer")[];
        /** @description Comma-separated list of apps (selected APIs) values to filter by */
        selected_apis?: string[];
        /** @description Comma-separated list of Zap IDs (numeric or UUID) */
        zap_ids?: string[];
        /** @description Comma-separated list of Zap run statuses used for filtering */
        statuses?: ("delayed" | "scheduled" | "pending" | "error" | "error_handled" | "halted" | "throttled" | "held" | "filtered" | "skipped" | "success")[];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TopZapsByRunsV2Response"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
    };
  };
  /** @description Gets graph data of zap usage in per-day buckets. */
  "api_zap-history_v2_runs_usage_list": {
    parameters: {
      query: {
        account_id: number;
        /** @description Start datetime for query; ISO-8601 */
        from_date?: string;
        /** @description Start datetime for query; ISO-8601 */
        to_date?: string;
        /** @description Comma-separated list of customuser_id values to filter by */
        customuser_ids?: number[];
        /** @description Comma-separated list of folder_id values to filter by */
        folder_ids?: number[];
        /** @description Comma-separated list of Zap kind values to filter by */
        kinds?: ("workflow" | "transfer")[];
        /** @description Comma-separated list of apps (selected APIs) values to filter by */
        selected_apis?: string[];
        /** @description Comma-separated list of Zap IDs (numeric or UUID) */
        zap_ids?: string[];
        /** @description Search query to be used for filtering */
        query?: string;
        /** @description Comma-separated list of Zap run statuses used for filtering */
        statuses?: ("delayed" | "scheduled" | "pending" | "error" | "error_handled" | "halted" | "throttled" | "held" | "filtered" | "skipped" | "success")[];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GetZapRunsUsageResponse"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
    };
  };
  "api_zap-history_v2_runs_zap-run-counts_list": {
    parameters: {
      query: {
        account_id: number;
        /** @description Sets whether counts should include Zaps that are shared with the current user. */
        include_shared?: boolean;
        /** @description Comma-separated list specifying what status of runs to return counts for */
        status?: string;
        /** @description Comma-separated list of 'zap' and/or 'status' specifying how you want the results grouped */
        group_by?: string;
        from_date?: string;
        to_date?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ZapRunCountsV2Response"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
      503: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
    };
  };
  /**
   * This is a brand new endpoint that is still being proved and not yet ready for use.
   * @description Retrieves the full details of a Zap run.
   */
  "api_zap-history_v2_runs_read": {
    parameters: {
      query: {
        account_id: number;
        run_id: string;
      };
      path: {
        run_id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ZapRunV2"];
        };
      };
      400: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
      500: {
        content: {
          "application/json": components["schemas"]["ZapHistoryErrorV2"];
        };
      };
    };
  };
  /**
   * Pause a running Zap
   * @description Attempt to pause the Zap that corresponds to node `node_id`.
   * A Zap can only be paused if it is owned by the current user and the access token contains the scope `zap:pause`.
   */
  api_public_beta_zap_pause_update: {
    parameters: {
      path: {
        /** @description A unique integer value identifying this node. */
        node_id: number;
      };
    };
    responses: {
      200: {
        content: never;
      };
    };
  };
  player_list: {
    responses: {
      200: {
        content: never;
      };
    };
  };
  player_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  player_confirmation_list: {
    responses: {
      200: {
        content: never;
      };
    };
  };
  player_confirmation_create: {
    responses: {
      201: {
        content: never;
      };
    };
  };
  "scim_v2_.search_list": {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/scim+json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: Record<string, never>[];
          };
        };
      };
    };
  };
  scim_v2_Bulk_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/scim+json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: Record<string, never>[];
          };
        };
      };
    };
  };
  scim_v2_Groups_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/scim+json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: Record<string, never>[];
          };
        };
      };
    };
  };
  /** @description Create a new team from the given SCIM blob */
  scim_v2_Groups_create: {
    requestBody: components["requestBodies"]["scim_v2_Groups_createData"];
    responses: {
      201: {
        content: {
          "application/scim+json": Record<string, never>;
        };
      };
    };
  };
  scim_v2_Groups_search: {
    requestBody: components["requestBodies"]["scim_v2_Groups_createData"];
    responses: {
      201: {
        content: {
          "application/scim+json": Record<string, never>;
        };
      };
    };
  };
  /** @description Retrieve the underlying object */
  scim_v2_Groups_read: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/scim+json": Record<string, never>;
        };
      };
    };
  };
  /** @description Update the underlying object with the values received from the IdP */
  scim_v2_Groups_update: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: components["requestBodies"]["scim_v2_Groups_createData"];
    responses: {
      200: {
        content: {
          "application/scim+json": Record<string, never>;
        };
      };
    };
  };
  /** @description Implement PATCH support for the underlying resource */
  scim_v2_Groups_partial_update: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: components["requestBodies"]["scim_v2_Groups_createData"];
    responses: {
      200: {
        content: {
          "application/scim+json": Record<string, never>;
        };
      };
    };
  };
  /**
   * Resource that points to the user represented by the underlying token
   * @description The endpoint will return the exact location of the user represented
   * by the token.
   */
  scim_v2_Me_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/scim+json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: Record<string, never>[];
          };
        };
      };
    };
  };
  /** @description Generate the resource types exposed by this endpoint */
  scim_v2_ResourceTypes_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/scim+json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: Record<string, never>[];
          };
        };
      };
    };
  };
  /** @description Generate the resource types exposed by this endpoint */
  scim_v2_ResourceTypes_read: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/scim+json": Record<string, never>;
        };
      };
    };
  };
  /** @description The schemas endpoint that returns to the IdP the schemas we know about */
  scim_v2_Schemas_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/scim+json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: Record<string, never>[];
          };
        };
      };
    };
  };
  /** @description The schemas endpoint that returns to the IdP the schemas we know about */
  scim_v2_Schemas_read: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/scim+json": Record<string, never>;
        };
      };
    };
  };
  /**
   * Generate the Service Provider configuration
   * @description This endpoint is called by the IdP for figuring out how our
   * API is going to behave.
   */
  scim_v2_ServiceProviderConfig_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/scim+json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: Record<string, never>[];
          };
        };
      };
    };
  };
  scim_v2_Users_list: {
    parameters: {
      query?: {
        /** @description Number of results to return per page. */
        limit?: number;
        /** @description The initial index from which to return the results. */
        offset?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/scim+json": {
            count: number;
            /** Format: uri */
            next?: string | null;
            /** Format: uri */
            previous?: string | null;
            results: Record<string, never>[];
          };
        };
      };
    };
  };
  /** @description Create a new user from the given SCIM blob. */
  scim_v2_Users_create: {
    requestBody: components["requestBodies"]["scim_v2_Groups_createData"];
    responses: {
      201: {
        content: {
          "application/scim+json": Record<string, never>;
        };
      };
    };
  };
  scim_v2_Users_search: {
    requestBody: components["requestBodies"]["scim_v2_Groups_createData"];
    responses: {
      201: {
        content: {
          "application/scim+json": Record<string, never>;
        };
      };
    };
  };
  /** @description Retrieve the underlying object */
  scim_v2_Users_read: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/scim+json": Record<string, never>;
        };
      };
    };
  };
  /** @description Update the underlying object with the values received from the IdP */
  scim_v2_Users_update: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: components["requestBodies"]["scim_v2_Groups_createData"];
    responses: {
      200: {
        content: {
          "application/scim+json": Record<string, never>;
        };
      };
    };
  };
  /** @description Implement PATCH support for the underlying resource */
  scim_v2_Users_partial_update: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: components["requestBodies"]["scim_v2_Groups_createData"];
    responses: {
      200: {
        content: {
          "application/scim+json": Record<string, never>;
        };
      };
    };
  };
}
