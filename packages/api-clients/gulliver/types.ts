/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/metadata/v1/zaps/{zap_id}": {
    /**
     * Get Zap Metadata
     * @description Retrieve metadata for a specific Zap
     */
    get: operations["get_zap_metadata_view"];
  };
  "/steptesting/v1/zaps/{zap_id}/draft": {
    /**
     * Delete Zap Draft & Samples
     * @description Deletes a Zap's Samples alongside its Draft
     */
    delete: operations["delete_draft_zdl_and_draft_zaps"];
  };
  "/steptesting/v1/zaps/{zap_id}/duplicate": {
    /**
     * Duplicate Zap
     * @description Duplicates a Zap along with its Samples.
     */
    post: operations["duplicate_zap_and_samples"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/duplicate/samples": {
    /**
     * Duplicate Step Samples
     * @description Takes a list of 'from' and 'to' Step IDs and copies the samples between these steps.
     */
    post: operations["duplicate_samples_for_steps"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/needs": {
    /**
     * Get Step Needs
     * @description Grab the needs for a step.
     */
    post: operations["get_needs"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/gives": {
    /**
     * Get Step Gives
     * @description Grab the gives (including custom gives) for a step, defaults to storage as long as the validation hash is still good. Stores them in the selected sample.
     */
    get: operations["get_gives"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/published/gives": {
    /**
     * Get All Published Zap Step Gives
     * @description Returns all published gives for the provided Zap Step.
     */
    get: operations["get_published_gives"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/published/samples": {
    /**
     * Get All Published Zap Step Samples
     * @description Returns all published samples for the provided Zap Step.
     */
    get: operations["get_published_samples"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/samples/modified": {
    /**
     * Get All Modified Zap Step Samples
     * @description Returns all modified samples for the provided Zap Step.
     */
    get: operations["get_modified_samples"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/samples/modified/{sample_id}": {
    /**
     * Deletes a modified sample
     * @description Deletes a modified sample
     */
    delete: operations["delete_modified_sample"];
    /**
     * Update a Modified Zap Step Sample
     * @description Replaces the output and gives of the selected Modified Sample with the provided payload.
     */
    patch: operations["update_modified_sample"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/samples": {
    /**
     * Get All Stored Zap Steps Samples
     * @description Returns all valid samples for the provided Zap Step.
     */
    get: operations["get_samples"];
  };
  "/steptesting/v2/zaps/{zap_id}/steps/{step_id}/output/samples": {
    /**
     * Get All Stored Zap Steps Samples including Modified Samples
     * @description Returns all valid samples (including Modified samples) for the provided Zap Step.
     */
    get: operations["get_all_samples"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/samples/selected": {
    /**
     * Get Stored Zap Steps' Selected Sample
     * @description This would return a single sample that has been selected, or 404 not found.
     */
    get: operations["get_selected_sample"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/samples/skip": {
    /**
     * Create a Skipped Sample
     * @description This will create a skipped sample with our best guess of what the user will be able to map in following steps.
     */
    post: operations["skip_and_create_sample"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/samples/{sample_id}/create_modified": {
    /**
     * Creates a modified sample from an existing draft sample
     * @description Creates a modified sample from an existing draft sample
     */
    post: operations["create_modified"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/samples/zap_run/{zap_run_id}/create_modified": {
    /**
     * Creates a modified sample from the trigger output of the given Zap run
     * @description Creates a modified sample from the trigger output of the given Zap run
     */
    post: operations["create_modified_from_zap_run"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/samples/modified/{sample_id}/rename": {
    /**
     * Renames a modified sample
     * @description Renames a modified sample
     */
    post: operations["rename_modified_sample"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/samples/modified/{sample_id}/duplicate": {
    /**
     * Duplicates a modified sample
     * @description Duplicates a modified sample
     */
    post: operations["duplicate_modified_sample"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/samples/{sample_id}/select": {
    /**
     * Set Sample as Selected
     * @description Sets a stored sample as the selected sample for the provided Zap Step.
     */
    post: operations["mark_sample_as_selected"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/samples/modified/{sample_id}/reset": {
    /**
     * Reset a modified sample to it's original content
     * @description Overwrites the current output and gives of a modified sample with the original content.
     * Any changes made to the sample will be lost and the sample will be returned to it's original state.
     */
    post: operations["reset_modified_sample"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/test/prepare": {
    /**
     * Prepare Step Testing
     * @description Prepares for and enables collection of data for triggers (e.g. data coming
     * in via hooks etc.).
     *
     * More specifically a call to this endpoint (for a trigger step) will request
     * session details from App Platform and in doing so set things in motion so
     * that data coming in for the trigger step is collected and stored (prior to
     * this any incoming data would be ignored).
     *
     * **Notes:**
     *   - Is safe to call for an action step, it is not needed though so suggest it is skipped unless it’s a trigger step.
     *   - `expires_at` will be None for polling triggers.
     *   - This endpoint will return any cached metadata (i.e. from previous
     *     `prepare` calls), it will not overwrite the metadata unless the step
     *     has changed enough since the last call that the validation_hash has
     *     changed.
     *   - It is suggested to call `prepare` again after any step configuration
     *     changes. If the step has changed enough then any cached session for the
     *     step will be considered invalid. Calling the `run` endpoint without a
     *     valid cached session will result in a 400 error.
     */
    get: operations["prepare_for_sampling"];
  };
  "/steptesting/v1/zaps/{zap_id}/steps/{step_id}/output/test/run": {
    /**
     * Test Zap Step & Stores Samples
     * @description Run (and in the process test) the provided Zap Step. Returns any
     * resulting new deduplicated samples.
     *
     * This endpoint is called the same regardless if it’s an action or trigger.
     * It will either return 0-MAX samples or error, it will never return metadata
     * details.
     *
     * **When calling this endpoint for a trigger/read step there are some details
     * to keep in mind:**
     *
     * A `200` response indicates that a step was tested successfully but no new
     * samples resulted (e.g. the response was a duplicate or no data returned) a
     * `201` response will contain samples.
     *
     * Receiving a `410`` status code indicates that the caller should call the
     * /prepare endpoint before then calling this endpoint again.
     *
     * A trigger step may return a 410 error on the following occasions:
     *
     * - **Session has expired for this trigger. Call prepare.**:
     *   Returned when a prepared session has expired. This is likely to happen
     *   (but not limited to) when there is a session_id in cache but App Platform
     *   considers it expired.
     *
     * - **No valid session found for trigger.**: Returned if there is no
     *   session in cache at all for this step. This could happen (but not limited
     *   to) when enough changes are made to a step and the `prepare` endpoint is
     *   not called before the `run` endpoint.
     *
     * The status code `202` is returned when the trigger steps execution has not
     * yet finished.
     * The suggested reaction to a `202` status response is to call (or poll)
     * again in the very near future and to continue to do so until a non-`202`
     * response is returned.
     *
     * **Note:** To test a trigger step one _must_ call
     * `/zaps/{zap_id}/steps/{step_id}/output/test/prepare` prior to calling this
     * endpoint.
     *
     * **Note:**
     *  (implementation detail) The successful collection of data for a
     *  polling trigger will result in the session ID being invalidated (by App
     *  Platform, no invalidation happens for other trigger types).
     *  The `run` endpoint glosses over this by ‘re-preparing’ for this step if
     *  this happens. (It’s possible that the session_id in a previously returned
     *  call to prepare may now differ if prepare is called again. This shouldn’t
     *  be an issue as session_id should only be used by the BE service).
     *
     * The status codes `202` and `410` will _only_ ever be returned for a trigger
     * step and not for action steps.
     */
    post: operations["run_test_sample"];
  };
  "/steptesting/v1/zaps/{zap_id}/subscriptions": {
    /**
     * Get Zap Subscription & Claims
     * @description Returns the Zap's subscriptions, if any. Retrieve the information around the claim ids associated with steps for an enabled version of a Zap, this is done by munging up data from ZDL Storage (per Zap claim ids) with the data from the App Platform (claim id details). This includes webhook static hook URLs which may help the user send data.
     */
    get: operations["get_subscriptions"];
  };
  "/storage/v1/zaps": {
    /**
     * Get Zaps
     * @description Get Zaps for this exact user and account, or, in a folder they can see.
     *
     * Note:
     *     `folder_id` can be `0` which will be “Home Folder”, no other virtual
     *     folders are supported. Pagination is locked to 25 Zaps, with Zaps
     *     in reverse chronological order. If pagination cursor is `null`,
     *     there are no more Zaps to paginate through.
     *
     * When your Zap is enabled, you’ll have a `current_version: {zdl: {...}}`,
     * and when it is disabled, you’ll have a `draft: {zdl: {...}}`. For now,
     * you can **only have one or the other**, but once we move away from Nodes
     * you’ll be able to have both a live version and a draft!
     */
    get: operations["get_zaps"];
    /**
     * Create Zap
     * @description Create a new Zap for a customuser in an account accessible by that customuser.
     *
     * Since behind the scenes we still need to use auto-increment integer IDs,
     * you’ll be required to **initially** provide step IDs in the format of
     * `{”id”: “_GEN_{\d\w+}”}` and we’ll automatically generate / replace the
     * step ID and any dependent curlies with the new integer ID.
     * **You’ll then need to use the new IDs we generated in all your subsequent
     * ZDL calls, like update.** In the future, this requirement will go away and
     * you can manage the step IDs however you see fit.
     */
    post: operations["create_zap"];
  };
  "/storage/v1/zaps/{zap_id}": {
    /**
     * Get Zap
     * @description Retrieve a Zap for a customuser.
     *
     * The Zap must be owned by the customuser or in a folder to which the
     * customuser has access.
     */
    get: operations["get_zap"];
    /**
     * Delete Zap
     * @description Delete a Zap.
     *
     * Performs a soft delete by simply marking the `deleted_at` timestamp
     * on the Zap It is NOT removed from the database.
     *
     * This should effectively put the Zap into the trash.
     */
    delete: operations["delete_zap"];
    /**
     * Update Zap
     * @description Update a Zap.
     *
     * The following updates are permitted:
     *     * Draft ZDL is updated when the `zdl` field is supplied.
     *       If no draft exists, one is created
     *     * A Zap can be enabled or disabled by toggling the `is_enabled` field
     *
     * If you need to transfer the Zap to a different folder, account, or owner use
     * the respective transfer endpoint.
     */
    patch: operations["update_zap"];
  };
  "/storage/v1/zaps/template": {
    /**
     * Update Template Zap
     * @description Update a Template Zap (using ZDL).
     *
     * The following updates are permitted:
     *     * ZDL document is required - only updating the Zap details is available
     *     * No title or other attributes are currently supported
     *     * No validation checks on "no auths allowed" and the like are
     *       currently supported
     */
    patch: operations["update_template_zap"];
  };
  "/storage/v1/zaps/{zap_id}/check": {
    /**
     * Check Zap
     * @description Run checks on a Zap without enabling it.
     */
    post: operations["zap_check"];
  };
  "/storage/v1/zaps/{zap_id}/draft": {
    /** Delete the draft of the specified zap */
    delete: operations["zap_draft_delete"];
  };
  "/storage/v1/zaps/{zap_id}/draft/publish-version": {
    /**
     * Publishes a new version from a draft
     * @description Publishes a new version from a draft and enables the Zap. Note that as we straddle Node/ZDL the resulting Zap will be Node based and the created Version will contain all metadata except the ZDL (this will come later).
     */
    post: operations["publish_zap_version"];
  };
  "/storage/v1/zaps/{zap_id}/disable": {
    /**
     * Disables the zap
     * @description Disables the Zap
     */
    post: operations["disable_zap"];
  };
  "/storage/v1/zaps/{zap_id}/publish": {
    /**
     * Publish Version
     * @description Publishes the latest version of a Zap
     */
    post: operations["publish_version"];
  };
  "/storage/v1/zaps/{zap_id}/run": {
    /** Get Run Status */
    get: operations["get_run_status"];
    /** Run Zap */
    post: operations["run_zap"];
  };
  "/storage/v1/zaps/{zap_id}/versions": {
    /**
     * List versions for this zap
     * @description Lists versions for the zap in a paginated fashion
     */
    get: operations["list_zap_versions"];
  };
  "/storage/v1/zaps/{zap_id}/versions/entitlement": {
    /**
     * Get the users entitlement details for this zap
     * @description Lists entitlement values for this zap
     */
    get: operations["list_zap_versions_entitlement"];
  };
  "/storage/v1/zaps/{zap_id}/versions/{version_id}": {
    /** Retrieves a specified version */
    get: operations["zap_version_get"];
  };
  "/storage/v1/zaps/{zap_id}/versions/{zap_version_id}": {
    /**
     * Get Version
     * @description Retrieve a Zap version identified by ID.
     *
     * In order tp retrieve a Zap version, the requesting customuser must have
     * access to the underlying Zap .
     */
    get: operations["get_version"];
    /**
     * Update Version
     * @description Record a new updated description for the given version record
     */
    patch: operations["update_version"];
  };
  "/storage/v1/zaps/{zap_id}/versions/{version_id}/enable": {
    /** Enables a specific zap version */
    post: operations["enable_zap_version"];
  };
  "/storage/v1/zaps/transfer/folder": {
    /** Transfer a list of zaps to a specified folder */
    post: operations["zap_transfer_folder"];
  };
  "/storage/v1/zaps/transfer/owner": {
    /** Transfer a list of zaps to a specified owner */
    post: operations["zap_transfer_owner"];
  };
  "/storage/v1/zaps/transfer/account": {
    /** Transfer a list of zaps to a specified account */
    post: operations["zap_transfer_account"];
  };
  "/storage/v1/zdl/duplicate": {
    /**
     * Duplicate Zdl
     * @description Duplicate ZDL returning the ZDL ready to be submitted to Create Zap endpoint.
     *
     * This includes changes to the step ids to conform with the endpoint's
     * requirements (changing step ids to correct _GEN_{i}).
     */
    post: operations["duplicate_zdl"];
  };
  "/zapsettings/v1/zaps/{zap_id}/settings": {
    /**
     * Get Zap Settings
     * @description Returns an array of Zap level settings
     */
    get: operations["get_settings"];
  };
  "/zapsettings/v1/zaps/{zap_id}/settings/{setting_id}": {
    /**
     * Update Zap Setting
     * @description Updates a Zap Setting by ID
     */
    put: operations["update_setting"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** About */
    About: {
      /**
       * Href
       * @description A string containing the links URL
       */
      href?: string;
    };
    /** BadRequestError */
    BadRequestError: {
      /**
       * Id
       * @description A unique identifier for this particular occurrence of the problem.
       */
      id?: string;
      links?: components["schemas"]["Links"];
      /** Status */
      status: number;
      /**
       * Code
       * @description An application-specific error code
       */
      code?: string;
      /**
       * Title
       * @description A short, human-readable summary of the problem.
       */
      title?: string;
      /**
       * Detail
       * @description A human-readable explanation specific to this occurrence of the problem.
       */
      detail?: string;
      source?: components["schemas"]["Source"];
      /**
       * Meta
       * @description An object containing non-standard meta-information about the error.
       */
      meta?: Record<string, never>;
    };
    /**
     * Choice
     * @example {
     *   "key": "no",
     *   "label": "No",
     *   "value": "False"
     * }
     */
    Choice: {
      /** Key */
      key: string;
      /** Label */
      label?: string;
      /** Value */
      value?: string;
    };
    /** DuplicateSamplesForStepsRequest */
    DuplicateSamplesForStepsRequest: {
      /** StepIDs */
      step_ids: components["schemas"]["SampleDuplicationPair"][];
    };
    /** DuplicateSamplesForStepsResponse */
    DuplicateSamplesForStepsResponse: {
      /** Results */
      results: components["schemas"]["DuplicateSamplesForStepsResult"][];
    };
    /**
     * DuplicateSamplesForStepsResult
     * @description Contains the results of a Sample duplication action
     */
    DuplicateSamplesForStepsResult: {
      /** @description Sample ID of the copied step */
      sample_id: components["schemas"]["SampleID"];
      /**
       * Status
       * @description Output status of the duplication
       * @enum {string}
       */
      status: "SUCCESS" | "FAILURE";
      /**
       * SourceStepID
       * @description Source Step ID to duplicate from
       */
      source_step_id: components["schemas"]["StepID"];
      /**
       * DestinationStepID
       * @description Destination Step ID to duplicate to
       */
      destination_step_id: components["schemas"]["StepID"];
      /**
       * Message
       * @description Failure message if unsuccessful
       */
      message: string;
    };
    /** DuplicateZapResponse */
    DuplicateZapResponse: {
      zdl: components["schemas"]["ZapSchema"];
    };
    /** ErrorResponse */
    ErrorResponse: {
      /** Errors */
      errors: (components["schemas"]["BadRequestError"] | components["schemas"]["NotFoundError"])[];
    };
    /**
     * FieldDefinition
     * @example {
     *   "key": "channel",
     *   "type": "string",
     *   "label": "Channel",
     *   "help_text": "If you use a custom value, you can also use the channel ID.",
     *   "required": true,
     *   "prefill": "channels.id.name",
     *   "searchfill": null,
     *   "placeholder": "Pick a channel...",
     *   "choices": [
     *     {
     *       "key": "C123456",
     *       "label": "General",
     *       "value": "general"
     *     },
     *     {
     *       "key": "C789012",
     *       "label": "Random",
     *       "value": "random"
     *     }
     *   ],
     *   "custom_field": false,
     *   "important": false,
     *   "default": null,
     *   "parent_key": null,
     *   "zap_meta_sample": null,
     *   "score": 0.8,
     *   "subscore": 0.5
     * }
     */
    FieldDefinition: {
      /** Key */
      key: string;
      /** Type */
      type?: string;
      /** Label */
      label?: string;
      /** Help Text */
      help_text?: string;
      /** Required */
      required?: boolean;
      /** Prefill */
      prefill?: string;
      /** Searchfill */
      searchfill?: string;
      /** Placeholder */
      placeholder?: string;
      /** Choices */
      choices?: components["schemas"]["Choice"][];
      /** Custom Field */
      custom_field?: boolean;
      /** Important */
      important?: boolean;
      /** Default */
      default?: unknown;
      /** Parent Key */
      parent_key?: string;
      /** Zap Meta Sample */
      zap_meta_sample?: unknown;
      /** Score */
      score?: number;
      /** Subscore */
      subscore?: number;
    };
    /** GetAllSamplesResponse */
    GetAllSamplesResponse: {
      /** Samples */
      samples?: components["schemas"]["RichSample"][];
    };
    /** GetAllSamplesInclModifiedResponse */
    GetAllSamplesInclModifiedResponse: {
      /** Samples */
      samples?: components["schemas"]["RichSample"][];
    };
    /** GetModifiedSamplesResponse */
    GetModifiedSamplesResponse: {
      /** Samples */
      samples?: components["schemas"]["RichSample"][];
    };
    /**
     * @example {
     *   "selected_api": "SlackCLIAPI@1.2.15",
     *   "action": "channel_message",
     *   "type_of": "write",
     *   "authentication_id": 1234567,
     *   "params": {
     *     "as_bot": "yes",
     *     "add_edit_link": "yes",
     *     "unfurl": "yes",
     *     "link_names": true,
     *     "reply_broadcast": "no",
     *     "text": "My Text",
     *     "channel": "C05DKB8Q877",
     *     "username": "Editor GitLab Bot",
     *     "icon": "https://about.gitlab.com/images/press/logo/png/gitlab-logo-500.png"
     *   },
     *   "invalidate_cache": false
     * }
     */
    GetNeedsRequest: {
      /** @description Something like `SlackAPI` (for Python apps) or `SplitwiseCLIAPI@1.0.0` or `SplitwiseCLIAPI@latest` (for CLI apps). Non-public apps are fine as long as the authed user can access them. */
      selected_api?: string;
      /** @description Action of the Step. */
      action?: string;
      /** @description Type of the Step. */
      type_of?: string;
      /** @description If the app needs auth, provide an `authentication_id` that has the `selected_api` of the app you want to run. Can be any auth visible to the user (including shared). */
      authentication_id?: number | null;
      /** @description Object that matches the input the node would normally get. Has all the same keys/types as the `needs` of the action. */
      params?: Record<string, unknown> | null;
      /**
       * @description Needs can be cached; provide this flag to disable it at a potential performance hit.
       *
       * @default false
       */
      invalidate_cache?: boolean;
    };
    GetNeedsResponse: {
      /** @description Check this first to see the success state. If true, there will be `needs` (which still could be empty). If false, then custom needs failed to fetch.`. */
      success?: boolean;
      /** @description An array of Needs objects. Could be empty even if `success` is true. */
      needs?: components["schemas"]["FieldDefinition"][];
    };
    /** GetPublishedSamplesResponse */
    GetPublishedSamplesResponse: {
      /** Samples */
      samples?: components["schemas"]["RichSample"][];
    };
    /** GetZapStepsSelectedResponse */
    GetZapSettingsResponse: {
      /** Results */
      results?: components["schemas"]["ZapSetting"][];
    };
    /** GetZapStepsSelectedResponse */
    GetZapStepsSelectedResponse: {
      sample?: components["schemas"]["RichSample"];
    };
    /** GetZapSubscriptionsResponse */
    GetZapSubscriptionsResponse: {
      /** Subscriptions */
      subscriptions: components["schemas"]["ZapSubscription"][];
    };
    /** GetGivesResponse */
    GetGivesResponse: {
      /** Gives */
      gives: components["schemas"]["FieldDefinition"][];
    };
    /** GetPublishedGivesResponse */
    GetPublishedGivesResponse: {
      /** Gives */
      gives: components["schemas"]["FieldDefinition"][];
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components["schemas"]["ValidationError"][];
    };
    /** Links */
    Links: {
      /**
       * About
       * @description A link that leads to further details about this particular occurrence of the problem.
       */
      about?: components["schemas"]["About"];
    };
    /** NotFoundError */
    NotFoundError: {
      /**
       * Id
       * @description A unique identifier for this particular occurrence of the problem.
       */
      id?: string;
      links?: components["schemas"]["Links"];
      /** Status */
      status: number;
      /**
       * Code
       * @description An application-specific error code
       */
      code?: string;
      /**
       * Title
       * @description A short, human-readable summary of the problem.
       */
      title?: string;
      /**
       * Detail
       * @description A human-readable explanation specific to this occurrence of the problem.
       */
      detail?: string;
      source?: components["schemas"]["Source"];
      /**
       * Meta
       * @description An object containing non-standard meta-information about the error.
       */
      meta?: Record<string, never>;
    };
    /** PublishVersionResponse */
    PublishVersionResponse: components["schemas"]["ZapVersionSchema"];
    /** PreparedMetadataResponse */
    PreparedMetadataResponse: {
      metadata?: components["schemas"]["ExtendedMetaData"];
    };
    /** PreparedTestResponse */
    PreparedTestResponse: {
      /** Samples */
      samples?: components["schemas"]["RichSample"][];
    };
    /** RenameModifiedSampleRequest */
    RenameModifiedSampleRequest: {
      /**
       * Description
       * @description The new sample description
       */
      description: string;
    };
    /** RenameModifiedSampleResponse */
    RenameModifiedSampleResponse: {
      sample: components["schemas"]["RichSample"];
    };
    /**
     * Rich Sample
     * @description Enriched sample - can contain details about modified content.
     */
    RichSample: {
      sample_id?: components["schemas"]["SampleID"];
      /** Zap Id */
      zap_id?: string;
      step_id?: components["schemas"]["StepID"];
      /** Is Selected */
      is_selected?: boolean;
      /** Step Output */
      step_output?: Record<string, never>;
      step_status?: components["schemas"]["StepSampleStatus"];
      /**
       * Created At
       * Format: date-time
       */
      created_at?: string;
      /**
       * Modified At
       * Format: date-time
       */
      modified_at?: string;
      source: components["schemas"]["SampleSource"];
      /** Description */
      description?: string;
      /** Has changed */
      has_changed?: boolean;
    };
    /**
     * StepSampleStatus
     * @description Step sample status enumeration
     * @enum {unknown}
     */
    StepSampleStatus: "delayed" | "error" | "halted" | "filtered" | "success";
    /** SampleDuplicationPair */
    SampleDuplicationPair: {
      /**
       * SourceStepID
       * @description Source Step ID to duplicate from
       */
      source_id?: components["schemas"]["StepID"];
      /**
       * DestinationStepID
       * @description Destination Step ID to duplicate to
       */
      dest_id?: components["schemas"]["StepID"];
    };
    /** SampleID */
    SampleID: string;
    /**
     * SampleSource
     * @description An enumeration.
     * @enum {unknown}
     */
    SampleSource: "live" | "skipped" | "modified";
    /** SetSampleAsSelectedResponse */
    SetSampleAsSelectedResponse: {
      sample?: components["schemas"]["RichSample"];
    };
    /** ResetModifiedSampleContentResponse */
    ResetModifiedSampleContentResponse: {
      sample?: components["schemas"]["RichSample"];
    };
    /** SkipTestResponse */
    SkipTestResponse: {
      /** Samples */
      samples?: components["schemas"]["RichSample"][];
      metadata?: components["schemas"]["ExtendedMetaData"];
    };
    /** Source */
    Source: {
      /**
       * Pointer
       * @description A JSON Pointer ([RFC6901](https://jsonapi.org/format/#:~:text=a%20JSON%20Pointer%20%5BRFC6901%5D%20to%20the%20associated%20entity%20in%20the%20request%20document)) to the associated entity in the request document
       * @example /data/attributes/title
       */
      pointer?: string;
      /**
       * Parameter
       * @description A string indicating which URI query parameter caused the error.
       */
      parameter?: string;
    };
    /** StepID */
    StepID: string;
    /** ExtendedMetaData */
    ExtendedMetaData: {
      /**
       * Static Hook Url
       * Format: uri
       */
      static_hook_url?: string;
      /** Is Hook Subscription */
      is_hook_subscription?: boolean;
      /** Expires At */
      expires_at?: number;
      /** Session Id */
      session_id?: string;
    };
    /**
     * TriggerType
     * @description An enumeration.
     * @enum {string}
     */
    TriggerType: "polling" | "hook_static" | "hook_subscription" | "hook_to_poll";
    /** UpdateModifiedSampleResponse */
    UpdateModifiedSampleResponse: components["schemas"]["RichSample"];
    /**
     * UpdateModifiedSampleRequest
     * @description Output to update the Modified Sample to. Must have the same shape as the Original Sample's output
     */
    UpdateModifiedSampleRequest: Record<string, never>;
    /** UpdateZapSettingRequest */
    UpdateZapSettingRequest: {
      /** @description Value to give the Zap Setting */
      value: string;
    };
    /** UpdateZapSettingResponse */
    UpdateZapSettingResponse: components["schemas"]["ZapSetting"];
    /**
     * ZapSetting
     * @description Defines a single setting for a Zap
     */
    ZapSetting: {
      /** ID */
      id: string;
      /** Kind */
      kind: string;
      /** Value */
      value: string;
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: string[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
    /** ZapDraftSchema */
    ZapDraftSchema: {
      /**
       * Created At
       * Format: date-time
       */
      created_at?: string;
      /**
       * Last User Change At
       * Format: date-time
       */
      last_user_change_at?: string;
      /** Last Updated By Customuser Id */
      last_updated_by_customuser_id?: number;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at?: string;
      /**
       * Zap Id
       * @example d9b0fb24-f66c-4506-8160-532861785407
       */
      zap_id?: string;
      /** Zdl */
      zdl: Record<string, never>;
    };
    /**
     * ZapEditMode
     * @description Zap edit modes
     * @enum {string}
     */
    ZapEditMode: "guided" | "normal" | "simple" | "unknown";
    /**
     * ZapExecutionEngine
     * @description An enumeration.
     * @enum {string}
     */
    ZapExecutionEngine: "zdl-executor" | "node-runner";
    /** ZapRunMessage */
    ZapRunMessage: {
      /** Body */
      body?: string;
      status: components["schemas"]["ZapStatus"];
    };
    /** ZapRunResponse */
    ZapRunGetResponse: {
      /** Errors */
      errors?: components["schemas"]["BaseError"][];
      /** Messages */
      messages: components["schemas"]["ZapRunMessage"][];
    };
    /** ZapRunResponse */
    ZapRunPostResponse: {
      /** Success */
      success?: boolean;
    };
    /** ZapSubscription */
    ZapSubscription: {
      /** Step Id */
      step_id: string;
      /** Claim Id */
      claim_id?: string;
      trigger_type: components["schemas"]["TriggerType"];
      /** Hook Url */
      hook_url?: string;
      /** Created At */
      created_at: number;
      /** Expires At */
      expires_at?: number;
      /** Initialized */
      initialized: boolean;
    };
    /**
     * ZapKind
     * @description A set of kinds of Zaps. Once set a Zap cannot change its kind.
     * @enum {string}
     */
    ZapKind: "workflow" | "transfer";
    /**
     * ZapSortOrder
     * @description An enumeration.
     * @enum {string}
     */
    ZapSortOrder: "state" | "id" | "title" | "-title";
    /** ZapSchema */
    ZapSchema: {
      /** Account Id */
      account_id: number;
      /**
       * Created At
       * Format: date-time
       */
      created_at?: string;
      current_version?: components["schemas"]["ZapVersionSchema"];
      /** Customuser Id */
      customuser_id: number;
      /**
       * Deleted At
       * Format: date-time
       */
      deleted_at?: string;
      /** Description */
      description?: string;
      draft?: components["schemas"]["ZapDraftSchema"];
      edit_mode?: components["schemas"]["ZapEditMode"];
      execution_engine?: components["schemas"]["ZapExecutionEngine"];
      /** Folder Id */
      folder_id?: number;
      /**
       * Id
       * @example d9b0fb24-f66c-4506-8160-532861785407
       */
      id: string;
      /** Is Enabled */
      is_enabled: boolean;
      kind: components["schemas"]["ZapKind"];
      /**
       * Last Disabled At
       * Format: date-time
       */
      last_disabled_at?: string;
      /**
       * Last Enabled At
       * Format: date-time
       */
      last_enabled_at?: string;
      /** Last Updated By Customuser Id */
      last_updated_by_customuser_id?: number;
      /** Legacy Node Id */
      legacy_node_id?: number;
      /**
       * Source Url
       * Format: uri
       */
      source_url?: string;
      /** Title */
      title?: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at?: string;
      /** Project Id */
      project_id?: string;
    };
    /** ZDLSchema */
    ZDLSchema: {
      /** Zdl */
      zdl?: Record<string, never>;
    };
    /** BaseError */
    BaseError: {
      /**
       * Code
       * @description An application-specific error code
       */
      code?: string;
      /**
       * Detail
       * @description A human-readable explanation specific to this occurrence of the problem.
       */
      detail?: string;
      /**
       * Id
       * @description A unique identifier for this particular occurrence of the problem.
       */
      id?: string;
      links?: components["schemas"]["Links"];
      /**
       * Meta
       * @description An object containing non-standard meta-information about the error.
       */
      meta?: Record<string, never>;
      source?: components["schemas"]["Source"];
      /** Status */
      status: number;
      /**
       * Title
       * @description A short, human-readable summary of the problem.
       */
      title?: string;
    };
    /**
     * UpdateVersionSchema
     * @description Extra details required when updating a version.
     */
    UpdateVersionSchema: {
      /** Customuser Id */
      customuser_id: number;
      /** Description */
      description?: string;
    };
    /** UpdateZapSchema */
    UpdateZapSchema: {
      /**
       * Account Id
       * @deprecated
       * @description DEPRECATED. Use transfer to account endpoint.
       */
      account_id?: number;
      /**
       * Customuser Id
       * @deprecated
       * @description DEPRECATED. Use transfer to owner endpoint.
       */
      customuser_id?: number;
      /** Description */
      description?: string;
      /**
       * Folder Id
       * @deprecated
       * @description DEPRECATED. Use transfer to folder endpoint.
       */
      folder_id?: number;
      /** Legacy Node Id */
      legacy_node_id?: number;
      /** Source Url */
      source_url?: string;
      /** Title */
      title?: string;
      /** Zdl */
      zdl?: Record<string, never>;
    };
    /** MutateTemplateZapSerializer */
    MutateTemplateZapSerializer: {
      /** Zdl */
      zdl: Record<string, never>;
    };
    /**
     * ZapVersionSchema
     * @description Shorthand details for a Zap Version.
     */
    ZapVersionSchema: {
      /**
       * Created At
       * Format: date-time
       */
      created_at?: string;
      /** Created By Customuser Id */
      created_by_customuser_id?: number;
      /** Description */
      description?: string;
      /**
       * Id
       * @example d9b0fb24-f66c-4506-8160-532861785407
       */
      id: string;
      /**
       * Last Marked Current At
       * Format: date-time
       */
      last_marked_current_at?: string;
      /**
       * Subscription Claim Ids
       * @description Mapping of step id to subscription claim id
       * @example {
       *   "d9b0fb24-f66c-4506-8160-532861785407": "79cde9c6-05cb-42af-a13b-732dc8b7770c",
       *   "f87aba09-459a-46b9-96ac-be6d9def1770": "b4bf17f2-0878-4ae2-b880-02d51ae91aea"
       * }
       */
      subscription_claim_ids?: Record<string, never>;
      /** Version Number */
      version_number?: number;
      /**
       * Zap Id
       * @example d9b0fb24-f66c-4506-8160-532861785407
       */
      zap_id: string;
      /** Zdl */
      zdl?: Record<string, never>;
    };
    /** CreateZapSchema */
    CreateZapSchema: {
      /** Description */
      description?: string;
      /** Folder Id */
      folder_id?: number;
      /**
       * @description The kind of Zap. **NOTE**: This currently defaults to workflow, but will be a required field in the future
       * @default workflow
       */
      kind?: components["schemas"]["ZapKind"];
      /** Legacy Node Id */
      legacy_node_id?: number;
      /** Source Url */
      source_url?: string;
      /** Title */
      title?: string;
      /** Zdl */
      zdl?: Record<string, never>;
    };
    /** ZapVersionListMeta */
    ZapVersionListMeta: {
      /** Limit */
      limit: number;
      /** Cursor */
      cursor: string;
      /** Next Cursor */
      next_cursor: string;
    };
    /** ZapVersionListLinks */
    ZapVersionListLinks: {
      /** Next */
      next: string;
    };
    /** ZapListResponse */
    ZapListResponse: {
      /** Results */
      results: components["schemas"]["ZapSchema"][];
    };
    /** ZapVersionListResponse */
    ZapVersionListResponse: {
      links?: components["schemas"]["ZapVersionListLinks"];
      meta?: components["schemas"]["ZapVersionListMeta"];
      /** Results */
      results: components["schemas"]["ZapVersionSchema"][];
    };
    /** ZapVersionEntitlementResponse */
    ZapVersionEntitlementResponse: {
      /** Unentitled Versions Exist */
      unentitled_versions_exist: boolean;
    };
    /** ZapTransferFolderRequest */
    ZapTransferFolderRequest: {
      /** Zap Ids */
      zap_ids: string[];
      /** Folder Id */
      folder_id: number;
    };
    /** ZapTransferOwnerRequest */
    ZapTransferOwnerRequest: {
      /** Zap Ids */
      zap_ids: string[];
      /** Customuser Id */
      customuser_id: number;
    };
    /** ZapTransferAccountRequest */
    ZapTransferAccountRequest: {
      /** Zap Ids */
      zap_ids: string[];
      /** Account Id */
      account_id: number;
    };
    /** ZapTransferResponse */
    ZapTransferResponse: {
      /** Successes */
      successes: components["schemas"]["ZapSchema"][];
      /** Failures */
      failures: components["schemas"]["ZapSchema"][];
    };
    /**
     * ZapStatus
     * @description Zap statuses
     * @enum {string}
     */
    ZapStatus: "delayed" | "scheduled" | "pending" | "error" | "halted" | "throttled" | "held" | "filtered" | "skipped" | "success";
    ZapMetadata: {
      /** @description ID of the Zap */
      zap_id: string;
      /** @description The title of the Zap */
      title: string;
      /** @description The ID of the user who owns the Zap */
      owner_customuser_id: number;
      /**
       * Format: date-time
       * @description The last update date and time of the Zap
       */
      updated_at: string;
      /**
       * @description Indicates if the Zap has ever been published
       * (i.e. has a current_version)
       */
      is_published?: Record<string, never>;
      /**
       * @description An array of dictionaries containing the steps in the Zap.
       * The content matches the Zap layout (much like the ZDL structure).
       */
      steps: components["schemas"]["ZapMetadataStep"][];
    };
    ZapMetadataStep: {
      /** @description The title of the step */
      title?: string;
      /** @description The ID of the step */
      id: string;
      /** @description The app (selected_api) associated with the step */
      app: string;
      /** @description App action */
      action: string;
      /** @description Step type (read, write, etc.) */
      type: string;
      /** @description Optional list of child ZapMetadataSteps */
      steps?: unknown[];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Get Zap Metadata
   * @description Retrieve metadata for a specific Zap
   */
  get_zap_metadata_view: {
    parameters: {
      query?: {
        /** @description The container and ID in which the Zap is being viewed (e.g. 'canvas:1b7cdd38-9422-4f52-af40-293151417c56') */
        container?: string;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful response with Zap metadata */
      200: {
        content: {
          "application/json": components["schemas"]["ZapMetadata"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Delete Zap Draft & Samples
   * @description Deletes a Zap's Samples alongside its Draft
   */
  delete_draft_zdl_and_draft_zaps: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful response */
      204: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Duplicate Zap
   * @description Duplicates a Zap along with its Samples.
   */
  duplicate_zap_and_samples: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["DuplicateZapResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Duplicate Step Samples
   * @description Takes a list of 'from' and 'to' Step IDs and copies the samples between these steps.
   */
  duplicate_samples_for_steps: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DuplicateSamplesForStepsRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["DuplicateSamplesForStepsResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Step Needs
   * @description Grab the needs for a step.
   */
  get_needs: {
    parameters: {
      path: {
        zap_id: string;
        step_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetNeedsRequest"];
      };
    };
    responses: {
      /** @description Step needs successfully retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetNeedsResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Step Gives
   * @description Grab the gives (including custom gives) for a step, defaults to storage as long as the validation hash is still good. Stores them in the selected sample.
   */
  get_gives: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetGivesResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get All Published Zap Step Gives
   * @description Returns all published gives for the provided Zap Step.
   */
  get_published_gives: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetPublishedGivesResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get All Published Zap Step Samples
   * @description Returns all published samples for the provided Zap Step.
   */
  get_published_samples: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetPublishedSamplesResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get All Modified Zap Step Samples
   * @description Returns all modified samples for the provided Zap Step.
   */
  get_modified_samples: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetModifiedSamplesResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Deletes a modified sample
   * @description Deletes a modified sample
   */
  delete_modified_sample: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
        sample_id: string;
      };
    };
    responses: {
      /** @description Successfully deleted */
      204: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Update a Modified Zap Step Sample
   * @description Replaces the output and gives of the selected Modified Sample with the provided payload.
   */
  update_modified_sample: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
        sample_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateModifiedSampleRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateModifiedSampleResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get All Stored Zap Steps Samples
   * @description Returns all valid samples for the provided Zap Step.
   */
  get_samples: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetAllSamplesResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get All Stored Zap Steps Samples including Modified Samples
   * @description Returns all valid samples (including Modified samples) for the provided Zap Step.
   */
  get_all_samples: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetAllSamplesInclModifiedResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Stored Zap Steps' Selected Sample
   * @description This would return a single sample that has been selected, or 404 not found.
   */
  get_selected_sample: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetZapStepsSelectedResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create a Skipped Sample
   * @description This will create a skipped sample with our best guess of what the user will be able to map in following steps.
   */
  skip_and_create_sample: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["SkipTestResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Creates a modified sample from an existing draft sample
   * @description Creates a modified sample from an existing draft sample
   */
  create_modified: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
        sample_id: string;
      };
    };
    responses: {
      /** @description Successfully Duplicated */
      201: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Conflict (ex: maximum number of modified samples already exist) */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Creates a modified sample from the trigger output of the given Zap run
   * @description Creates a modified sample from the trigger output of the given Zap run
   */
  create_modified_from_zap_run: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
        zap_run_id: string;
      };
    };
    responses: {
      /** @description Successfully Duplicated */
      201: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Conflict (ex: maximum number of modified samples already exist) */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Renames a modified sample
   * @description Renames a modified sample
   */
  rename_modified_sample: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
        sample_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RenameModifiedSampleRequest"];
      };
    };
    responses: {
      /** @description Successfully Renamed */
      201: {
        content: {
          "application/json": components["schemas"]["RenameModifiedSampleResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Duplicates a modified sample
   * @description Duplicates a modified sample
   */
  duplicate_modified_sample: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
        sample_id: string;
      };
    };
    responses: {
      /** @description Successfully Duplicated */
      201: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Conflict (ex: maximum number of modified samples already exist) */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Set Sample as Selected
   * @description Sets a stored sample as the selected sample for the provided Zap Step.
   */
  mark_sample_as_selected: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
        sample_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SetSampleAsSelectedResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Reset a modified sample to it's original content
   * @description Overwrites the current output and gives of a modified sample with the original content.
   * Any changes made to the sample will be lost and the sample will be returned to it's original state.
   */
  reset_modified_sample: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
        sample_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ResetModifiedSampleContentResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Prepare Step Testing
   * @description Prepares for and enables collection of data for triggers (e.g. data coming
   * in via hooks etc.).
   *
   * More specifically a call to this endpoint (for a trigger step) will request
   * session details from App Platform and in doing so set things in motion so
   * that data coming in for the trigger step is collected and stored (prior to
   * this any incoming data would be ignored).
   *
   * **Notes:**
   *   - Is safe to call for an action step, it is not needed though so suggest it is skipped unless it’s a trigger step.
   *   - `expires_at` will be None for polling triggers.
   *   - This endpoint will return any cached metadata (i.e. from previous
   *     `prepare` calls), it will not overwrite the metadata unless the step
   *     has changed enough since the last call that the validation_hash has
   *     changed.
   *   - It is suggested to call `prepare` again after any step configuration
   *     changes. If the step has changed enough then any cached session for the
   *     step will be considered invalid. Calling the `run` endpoint without a
   *     valid cached session will result in a 400 error.
   */
  prepare_for_sampling: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["PreparedMetadataResponse"];
        };
      };
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["PreparedMetadataResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Test Zap Step & Stores Samples
   * @description Run (and in the process test) the provided Zap Step. Returns any
   * resulting new deduplicated samples.
   *
   * This endpoint is called the same regardless if it’s an action or trigger.
   * It will either return 0-MAX samples or error, it will never return metadata
   * details.
   *
   * **When calling this endpoint for a trigger/read step there are some details
   * to keep in mind:**
   *
   * A `200` response indicates that a step was tested successfully but no new
   * samples resulted (e.g. the response was a duplicate or no data returned) a
   * `201` response will contain samples.
   *
   * Receiving a `410`` status code indicates that the caller should call the
   * /prepare endpoint before then calling this endpoint again.
   *
   * A trigger step may return a 410 error on the following occasions:
   *
   * - **Session has expired for this trigger. Call prepare.**:
   *   Returned when a prepared session has expired. This is likely to happen
   *   (but not limited to) when there is a session_id in cache but App Platform
   *   considers it expired.
   *
   * - **No valid session found for trigger.**: Returned if there is no
   *   session in cache at all for this step. This could happen (but not limited
   *   to) when enough changes are made to a step and the `prepare` endpoint is
   *   not called before the `run` endpoint.
   *
   * The status code `202` is returned when the trigger steps execution has not
   * yet finished.
   * The suggested reaction to a `202` status response is to call (or poll)
   * again in the very near future and to continue to do so until a non-`202`
   * response is returned.
   *
   * **Note:** To test a trigger step one _must_ call
   * `/zaps/{zap_id}/steps/{step_id}/output/test/prepare` prior to calling this
   * endpoint.
   *
   * **Note:**
   *  (implementation detail) The successful collection of data for a
   *  polling trigger will result in the session ID being invalidated (by App
   *  Platform, no invalidation happens for other trigger types).
   *  The `run` endpoint glosses over this by ‘re-preparing’ for this step if
   *  this happens. (It’s possible that the session_id in a previously returned
   *  call to prepare may now differ if prepare is called again. This shouldn’t
   *  be an issue as session_id should only be used by the BE service).
   *
   * The status codes `202` and `410` will _only_ ever be returned for a trigger
   * step and not for action steps.
   */
  run_test_sample: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        step_id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["PreparedTestResponse"];
        };
      };
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["PreparedTestResponse"];
        };
      };
      /** @description Accepted */
      202: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Gone */
      410: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Zap Subscription & Claims
   * @description Returns the Zap's subscriptions, if any. Retrieve the information around the claim ids associated with steps for an enabled version of a Zap, this is done by munging up data from ZDL Storage (per Zap claim ids) with the data from the App Platform (claim id details). This includes webhook static hook URLs which may help the user send data.
   */
  get_subscriptions: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetZapSubscriptionsResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Zaps
   * @description Get Zaps for this exact user and account, or, in a folder they can see.
   *
   * Note:
   *     `folder_id` can be `0` which will be “Home Folder”, no other virtual
   *     folders are supported. Pagination is locked to 25 Zaps, with Zaps
   *     in reverse chronological order. If pagination cursor is `null`,
   *     there are no more Zaps to paginate through.
   *
   * When your Zap is enabled, you’ll have a `current_version: {zdl: {...}}`,
   * and when it is disabled, you’ll have a `draft: {zdl: {...}}`. For now,
   * you can **only have one or the other**, but once we move away from Nodes
   * you’ll be able to have both a live version and a draft!
   */
  get_zaps: {
    parameters: {
      query: {
        /** @description Filter Zaps belonging to a particular folder. */
        folder_id?: number;
        /**
         * @deprecated
         * @description **DEPRECATED** Comma separated list of apps to filter by. Consumers should use the `/v1/search/zaps` API instead.
         * @example TesterAPI,TesterAuthAPI
         */
        involves_app?: string;
        /** @description Filter for Zaps with a title matching this string. */
        title?: string;
        /** @description Optionally include any (soft) deleted Zaps when filtering. */
        include_deleted?: boolean;
        /** @description Only return Zaps after a particular cursor. */
        cursor?: string;
        /** @description Optionally include (soft) deleted Zaps within a specific timeframe. Note that this must be used in tandem with the `include_deleted` filter. */
        trash_days?: number;
        /** @description Comma separated list of Zap IDs to fetch. Note that regardless of the number of IDs provided, you will only receive 25 Zaps at a time. */
        zap_ids?: string[];
        /** @description Number of Zaps to fetch at a time. Note that you cannot fetch more than 25 Zaps at a time. */
        limit?: number;
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
        /** @description Filter for Zaps belonging to a customuser. */
        customuser_id?: number;
        /** @description Filter by a specific kind of Zap. If not supplied ANY kind of Zap will be returned. */
        kind?: components["schemas"]["ZapKind"];
        /** @description Specify the ordering scheme to be used in ordering results. */
        order_by?: components["schemas"]["ZapSortOrder"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapListResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create Zap
   * @description Create a new Zap for a customuser in an account accessible by that customuser.
   *
   * Since behind the scenes we still need to use auto-increment integer IDs,
   * you’ll be required to **initially** provide step IDs in the format of
   * `{”id”: “_GEN_{\d\w+}”}` and we’ll automatically generate / replace the
   * step ID and any dependent curlies with the new integer ID.
   * **You’ll then need to use the new IDs we generated in all your subsequent
   * ZDL calls, like update.** In the future, this requirement will go away and
   * you can manage the step IDs however you see fit.
   */
  create_zap: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateZapSchema"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["ZapSchema"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get Zap
   * @description Retrieve a Zap for a customuser.
   *
   * The Zap must be owned by the customuser or in a folder to which the
   * customuser has access.
   */
  get_zap: {
    parameters: {
      query: {
        include_deleted?: boolean;
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapSchema"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete Zap
   * @description Delete a Zap.
   *
   * Performs a soft delete by simply marking the `deleted_at` timestamp
   * on the Zap It is NOT removed from the database.
   *
   * This should effectively put the Zap into the trash.
   */
  delete_zap: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update Zap
   * @description Update a Zap.
   *
   * The following updates are permitted:
   *     * Draft ZDL is updated when the `zdl` field is supplied.
   *       If no draft exists, one is created
   *     * A Zap can be enabled or disabled by toggling the `is_enabled` field
   *
   * If you need to transfer the Zap to a different folder, account, or owner use
   * the respective transfer endpoint.
   */
  update_zap: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateZapSchema"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapSchema"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Update Template Zap
   * @description Update a Template Zap (using ZDL).
   *
   * The following updates are permitted:
   *     * ZDL document is required - only updating the Zap details is available
   *     * No title or other attributes are currently supported
   *     * No validation checks on "no auths allowed" and the like are
   *       currently supported
   */
  update_template_zap: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MutateTemplateZapSerializer"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapSchema"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Check Zap
   * @description Run checks on a Zap without enabling it.
   */
  zap_check: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Upgrade Required */
      426: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Delete the draft of the specified zap */
  zap_draft_delete: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful response */
      204: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Publishes a new version from a draft
   * @description Publishes a new version from a draft and enables the Zap. Note that as we straddle Node/ZDL the resulting Zap will be Node based and the created Version will contain all metadata except the ZDL (this will come later).
   */
  publish_zap_version: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["ZapVersionSchema"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Disables the zap
   * @description Disables the Zap
   */
  disable_zap: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapSchema"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Publish Version
   * @description Publishes the latest version of a Zap
   */
  publish_version: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["PublishVersionResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get Run Status */
  get_run_status: {
    parameters: {
      query: {
        /** @description Query for Zap run feedback matching specified status. */
        status?: components["schemas"]["ZapStatus"];
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapRunGetResponse"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Run Zap */
  run_zap: {
    parameters: {
      query: {
        /** @description Do not actually run the Zap, but return a truthy response */
        fake?: boolean;
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapRunPostResponse"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List versions for this zap
   * @description Lists versions for the zap in a paginated fashion
   */
  list_zap_versions: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
        /** @description The cursor from the previous page of results */
        cursor?: string;
        /**
         * @description The limit of how many versions to return on this page
         * @default 25
         */
        limit?: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapVersionListResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get the users entitlement details for this zap
   * @description Lists entitlement values for this zap
   */
  list_zap_versions_entitlement: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapVersionEntitlementResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Retrieves a specified version */
  zap_version_get: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        version_id: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapVersionSchema"];
        };
      };
    };
  };
  /**
   * Get Version
   * @description Retrieve a Zap version identified by ID.
   *
   * In order tp retrieve a Zap version, the requesting customuser must have
   * access to the underlying Zap .
   */
  get_version: {
    parameters: {
      path: {
        zap_id: string;
        zap_version_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapVersionSchema"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update Version
   * @description Record a new updated description for the given version record
   */
  update_version: {
    parameters: {
      path: {
        zap_id: string;
        zap_version_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateVersionSchema"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Enables a specific zap version */
  enable_zap_version: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        version_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapVersionSchema"];
        };
      };
      /** @description Not Found */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Transfer a list of zaps to a specified folder */
  zap_transfer_folder: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ZapTransferFolderRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapTransferResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Transfer a list of zaps to a specified owner */
  zap_transfer_owner: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ZapTransferOwnerRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapTransferResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Transfer a list of zaps to a specified account */
  zap_transfer_account: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ZapTransferAccountRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZapTransferResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Duplicate Zdl
   * @description Duplicate ZDL returning the ZDL ready to be submitted to Create Zap endpoint.
   *
   * This includes changes to the step ids to conform with the endpoint's
   * requirements (changing step ids to correct _GEN_{i}).
   */
  duplicate_zdl: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ZDLSchema"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ZDLSchema"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get Zap Settings
   * @description Returns an array of Zap level settings
   */
  get_settings: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": components["schemas"]["GetZapSettingsResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update Zap Setting
   * @description Updates a Zap Setting by ID
   */
  update_setting: {
    parameters: {
      query: {
        /** @description The account_id that the user is currently logged in as. */
        account_id: number;
      };
      path: {
        zap_id: string;
        /** @description The ID of the setting to update */
        setting_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateZapSettingRequest"];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateZapSettingResponse"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
}
